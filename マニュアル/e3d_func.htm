<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
<meta name="GENERATOR" content="JustSystems Homepage Builder Version 16.0.6.0 for Windows">
<meta http-equiv="Content-Type" content="text/html; charset=Shift_JIS">
<meta http-equiv="Content-Style-Type" content="text/css">
<TITLE></TITLE>
</HEAD>
<BODY>
<P><BR>
<FONT size="+2"><B>Easy3D For Win32 関数の説明</B></FONT><BR>
</P>
<P>
おおざっぱに説明しますと、<BR>
形状データに　*.sig ファイルを、モーションデータに *.qua ファイルを使用します。<BR>
それぞれのデータは、RokDeBone2で作成可能です。<BR>
（詳しくは、<A href="rokdebone.htm">RokDeBone2のページ</A>をご覧ください。）<BR>
<BR>
<BR>
さて、easy3d.dllの関数の説明ですが、<BR>
まず、E3DSigLoadで、<U>モデルデータ(sig file)を読み込むごとにhsid</U> というものが得られます。<BR>
(hsid とは、Handler Set ID の略です。)<BR>
各モデルデータを識別したり、モデルデータに対して処理を行う際は、<BR>
いつもこのhsid を使用します。<BR>
<BR>
また、E3DAddMotionで<U>モーションデータを読み込むごとにモーションの番号</U>が得られます。<BR>
モーションのセットや変更には、いつもこのモーション番号を使います。<BR>
<BR>
<BR>
カメラの操作方法は、3種類用意しました。<BR>
E3DSetCameraPos と、E3DSetCameraDeg、E3DSetCameraTwist を組で使用する方法と、<BR>
E3DSetCameraPos と、E3DSetCameraTarget、E3DSetCameraTwistを組で使用する方法と<BR>
E3DSetCameraPos<BR>
E3DCameraLookAt<BR>
E3DCameraOnNaviLine<BR>
E3DCameraDirUp<BR>
E3DCameraDirDown<BR>
E3DCameraDirRight<BR>
E3DCameraDirLeft<BR>E3DSetCameraTwist<BR>
を組で、使用する方法です。<BR>
<B>他の方法と混ぜて使用することは、想定していません。</B><BR>
<B><BR>
</B></P>
<P>
それぞれの、関数の役割と、引数の説明を表にしました。<BR>
<BR>
この表は実装順に記述してあるので非常にみにくいです。<BR>
<B>マニュアルフォルダの中のEasy3DFunctions.exeを使ってこの表を見てください。</B><BR>
<BR>
<BR>
</P>
<TABLE border="1" width="1076" cellspacing="0" cellpadding="2" id="_HPB_TABLE_1_A_060604083113" class="hpb-cnt-tb1">
  <TBODY>
    <TR>
      <TH class="hpb-cnt-tb-th1" width="157">関数名</TH>
      <TH class="hpb-cnt-tb-th1" width="99">種類</TH>
      <TH class="hpb-cnt-tb-th1" width="367">説明</TH>
      <TH class="hpb-cnt-tb-th1" width="313">引数</TH>
      <TH class="hpb-cnt-tb-th1" width="114">備考</TH>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DInit</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">初期化</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">Direct3Dの初期化をする。<BR>
      <BR>
      フルスクリーンにも対応しています。<BR>
      <BR>
      フルスクリーンの解像度は、<BR>
      指定したウインドウの幅に<BR>
      一番近いものを自動で選びます。<BR>
      <BR>
      ６４０×４８０、<BR>
      ８００×６００、<BR>
      １０２４×７６８、<BR>
      １２８０×１０２４、<BR>
      １４００×１０５０、<BR>
      １６００×１２００<BR>
	の中から選びます。<BR>
<BR>
	<BR>
      ＨＡＬ（ハードウェアの機能）が使えない場合は、エラーになります。<BR>
      <BR>
      指定したビット数が使えない場合にも、<BR>
      エラーになります。<BR>
      <BR>
      <BR>
      エラーでアプリケーションが終了するのが<BR>
      嫌な場合は、<BR>
      この命令を呼ぶ前に、E3DCheckFullScreenParamsを呼んで<BR>
	チェックすることをおすすめします。<BR>
      <BR>
      <BR>
      <BR>
      <BR>
      アンチエイリアスについて。<BR>
      multisamplenumは０または２から１６の値を指定してください。<BR>
      multisamplenumの値が大きいほど、<BR>
      画像のエッジがなめらかになります。<BR>
      ０を指定するとアンチエイリアスは使えません。<BR>
      <BR>
      multisamplenumに０以外を指定する場合は、<BR>
      その前に、<BR>
      E3DGetMaxMultiSampleNumで<BR>
      指定できる最大値を取得してください。<BR>
      <BR>
      <U><B>アンチエイリアスをオンにすると（０以外を指定すると）、<BR>
      ＢＭＰ保存や、ＡＶＩ保存の命令が使えなくなります。<BR>
      </B><BR>
      （E3DWriteDisplay2BMP、E3DCreateAVIFileと他のＡＶＩ関連関数が使用できなくなります。）<BR>
      </U><BR>
      <BR>
      アンチエイリアスを有効にするには、<BR>
	作成した全てのhsidに対して、<BR>
      E3DSetRenderState hsid, -1, D3DRS_MULTISAMPLEANTIALIAS, 1 を呼んでください。<BR>
      <BR>
      ver5003でinitcomflagを追加しました。<BR>
      通常はDirectMusicを使うためにCOMの初期化が必要なので１を指定してください。<BR>
      .NetFrameworkなどと共用する場合、Easy3Dより先にCOMの初期化をする場合などに０を指定してください。<BR>
      ０を指定するとE3DInit内でのCoInitialize呼び出しとE3DByeでのCoUninitialize呼び出しを省略します。<BR>
<BR>
      <BR>
      ver5.1.0.2でindex32bit引数を追加しました。<BR>
      index32bit引数に１を指定すると３２ビットインデックスモードで起動し、０を指定すると１６ビットインデックスモードで起動します。<BR>
      ３２ビットインデックスモードでは６５５３５/３ポリゴンまでの制限がなくなります。<BR>
      ３２ビットインデックスモードではビデオカードに能力が無い場合は起動できなくなります。<BR>
      多くのネットブックなどでは３２ビットインデックスモードは動かないようなので注意してください。<BR>
<BR>ver5.3.1.3でfullscreenflagの値指定を拡張。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] HINSTANCE　：　hinst<BR>
      　　アプリケーションのhinstanceを<BR>
      　　渡します。<BR>
      <BR>
      2. [IN] HWND　：　hwnd<BR>
      　　メインウインドウのハンドルを<BR>
      　　渡してください。<BR>
      <BR>
      3. [IN] int　：　fullscreenflag<BR>
      　　フルスクリーンにするときは１を、<BR>
      　　しないとき（ウインドウモード）は０を指定してください。<BR>　　E3DCheckFullScreenParamsでflagに２を指定した場合は、fullscreenflagにも２を指定してください。<BR>
      <BR>
      4. [IN] int　：　bits<BR>
      　　色数を決めるビット数を指定してください。<BR>
      　　１６あるいは、３２のみ有効です。<BR>
      　　fullscreenflagに１または２を指定したときのみ、結果に反映されます。<BR>
      <BR>
      <BR>
      5. [IN] int　：　multisamplenum<BR>
      　　マルチサンプルの数。<BR>
      　　詳しくは前記をご覧ください。<BR>
      <BR>
      <BR>
      6. [IN] int　：　gpuflag<BR>
      　　１を指定するとビデオカードに頂点シェーダー、<BR>
      　　ピクセルシェーダーがある場合には、<BR>
      　　それを使って頂点処理します。<BR>
      　　０を指定すると、ソフトウェアで頂点処理します。<BR>
      <BR>
      <BR>
      7. [IN] int　：　enablereverb<BR>
      　　１を指定するとステレオサウンドのリバーブが<BR>
      　　オンになります。<BR>
      　　０を指定するとリバーブがオフになります。<BR>
      <BR>
      8. [IN] int　：　initcomflag<BR>
      　　COMを初期化するかどうかのフラグ。<BR>
      　　通常は１。<BR>
      　　詳しくは前記をご覧ください。<BR>
      <BR>
      9. [IN] int　：　index32bit<BR>
      　　１を指定すると３２ビットインデックスモードになります。０を指定すると１６ビットインデックスモードになります。<BR>
      　　詳しくは前記をご覧ください。<BR>
      <BR>
      10. [OUT] int*　：　scidptr<BR>
      　　スワップチェインＩＤが代入されます。<BR>
      　　このＩＤはどの部分に描画を行うかを指定するのに使います。<BR>
      　　E3DChkInView, E3DRender, E3DBeginScene, E3DPresent 　　などで<BR>
      　　必要になります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1<BR>
      <BR>
      ver5.0.0.3で引数追加<BR>
      <BR>
      ver5.1.0.2で拡張<BR>
      <BR>
      ver5.3.1.3で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DBye</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">後処理</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">Direct3Dの後処理をする。<BR>
      <BR>
      作成したメモリなどの解放を行います。<BR>
      アプリケーションの終了時に呼んでください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="313">なし</TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DSigLoad</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">モデルデータ</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">形状データ（*.sig）を読み込んで、hsidを得る。</TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] char*　：　fname<BR>
      　　*.sig のパス文字列。<BR>
      <BR>
      2. [IN] int　：　adjustuvflag<BR>
      　　ＵＶ値を正規化するかどうかのフラグ。<BR>
      　　正規化する場合は１を指定。<BR>
      　　しない場合は０を指定。<BR>
      　　２を指定すると0.0から1.0の間にクランプします。<BR>
<BR>
      <BR>
      3. [IN] float　：　mult<BR>
      　　読み込み倍率を指定してください。<BR>
      　　等倍は１．０ｆ<BR>
      <BR>
      4. [OUT] int*　：　hsidptr<BR>
      　　読み込んだ形状データを識別するhsid<BR>
      　　が格納される。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1<BR>ver5.0.2.6で拡張<BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DCreateSwapChain</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">スワップチェイン</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">スワップチェインを作成します。<BR>
      <BR>
      スワップチェインとは、複数の画面に描画を行うためのものです。<BR>
      E3DInitで指定したウインドウとオブジェクト以外のところに、<BR>
      描画したい場合にこの命令を呼びます。<BR>
      <BR>
      この命令で取得したscidを、<BR>
      E3DChkInView, E3DBeginScene, E3DRender, E3DPresentなどに渡すことにより<BR>
      複数画面に３Ｄ描画できるようになります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] HWND　：　hwnd<BR>
      　　ウインドウのハンドルを<BR>
      　　渡してください。<BR>
      <BR>
      2. [OUT] int*　：　scidptr<BR>
      　　スワップチェインＩＤが代入されます。<BR>
      　　このＩＤは、どの部分に描画を行うかを指定するのに<BR>
      　　使います。<BR>
      　　E3DChkInView, E3DRender, E3DBeginScene, E3DPresent　　などで<BR>
      　　必要になります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DDestroySwapChain</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">スワップチェイン</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">スワップチェインを破棄します。<BR>
      <BR>
      E3DCreateSwapChainで作成したスワップチェインが、<BR>
      もういらなくなった場合に、呼んでください。<BR>
      <BR>
      E3DInitで取得したscidに対しては、呼び出さないでください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DCreateSwapChainで取得したＩＤを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DRender</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">描画</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">バックバッファにレンダリングする。<BR>
      <BR>
      <BR>
      変更したボーンの中で、<BR>
      一番親の番号をlastparentに指定すると、<BR>
      そのボーンツリーの影響を受ける頂点のみを<BR>
      抽出して、計算します。<BR>
      <BR>
      lastparentは、高速化のためのものです。<BR>
      E3DIKRotateBetaで取得できるlastparentの値を<BR>
      渡すことを想定しています。<BR>
      <BR>
      キャラクター全体が移動した場合や<BR>
      カメラが移動した場合には、0を渡してください。<BR>
      また、E3DRenderの初回の呼び出し時にも<BR>
      ０を渡してください。<BR>
      <BR>
      <B>lastparentを使用したくない場合は、<BR>
      ０をセットしてください。</B><BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      3. [IN] int　：　withalpha<BR>
      　　０を指定すると、不透明パーツのみレンダリングする。<BR>
      　　１を指定すると、半透明パーツのみレンダリングする。<BR>
      <BR>
      4. [IN] int　：　LightFlag<BR>
      　　sigのライティング計算を有効にしたいときは１を、<BR>
      　　無効にしたいときは０を指定してください。<BR>
      　　デフォルトは１です。<BR>
      <BR>
      5. [IN] int　：　transskip<BR>
      　　transskipに１をセットすると、<BR>
      　　行列演算処理がスキップされます。<BR>
      　　<B>不透明、半透明と、２回、E3DRenderを呼び出す場合は、<BR>
      　　２回目の呼び出し時に、transskipに１を指定してください。</B><BR>
      <BR>
      <BR>
      6. [IN] int　：　lastparent<BR>
      　　変更が生じた一番親のボーンの番号を指定します。<BR>
      　　詳しくは、前記をご覧ください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1<BR>
      <BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DPresent</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">描画</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">バックバッファの内容を、<BR>
      プライマリバッファに転送する。</TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DBeginScene</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">描画</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">アプリケーションでは、レンダリングを実行する前には必ずこのメソッドを呼び出し、<BR>
      レンダリングの終了時、<BR>
      および再度E3DBeginSceneを呼び出す前には、<BR>
      必ず E3DEndSceneを呼び出す。<BR>
      <BR>
      具体的には、<BR>
      E3DRender, E3DDrawText, E3DDrawBigTextを、<BR>
      E3DBeginSceneと、E3DEndSceneでサンドイッチするように記述する。<BR>
      <BR>
      ver5.2.1.0でskipflagを拡張しました。<BR>
      <BR>
      ver5.3.0.1でzbufscidを追加。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="313"><BR>
      1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　skipflag<BR>      　　skipflagに０を指定すると色の初期化とZバッファの初期化と背景の描画を行います。<BR>
      　　skipflagに１を足すと色の初期化とZバッファの初期化と背景の描画を行いません。<BR>
      　　skipflagに２を足すとシェーダー定数のビデオカードへの転送をキャンセルします。<BR>
      　　skipflagに４を足すと色の初期化は行いますがZバッファの初期化と背景の描画は行いません。　<BR>
      　<BR>
      3. [IN] int　：　zbufscid<BR>
      　　Zバッファーを指定します。<BR>
      　　デフォルト値は-1です。<BR>
      　　-1を指定したときは最初の引数のscidのZバッファが使用されます。<BR>
      　　正の値のzbufscidを指定すると指定したスワップチェインのZバッファが使用されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1<BR>
      ver5.2.1.0で拡張<BR>
      ver5.3.0.1で拡張。<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DEndScene</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">描画</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">このメソッドが成功すると、シーンがレンダリングされ、レンダリング後のシーンがデバイス サーフェスに保持される。</TD>
      <TD class="hpb-cnt-tb-cell2" width="313">なし</TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DCreateBG</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">背景</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">画面の一番奥に表示される背景をセットします。<BR>
      <BR>
      画像ファイルは、２つまで、指定できます。<BR>
      ２個目の画像は、雲や、もや用を想定しています。<BR>
      １つ目の画像と２つ目の画像は、モジュレートされて、表示されます。<BR>
      <BR>
      isroundに１をセットすると、<BR>
      背景が、視点の回転に対応して、回転するようになります。<BR>
      <BR>
      <BR>
      ビデオカードがマルチテクスチャに対応していない場合、<BR>
      または、モジュレート処理が出来ない場合は、<BR>
      1個目のテクスチャーしか表示しないように<BR>
      なっています。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] char*　：　filename1<BR>
      　　１つ目の画像ファイル名。<BR>
      <BR>
      <BR>
      3. [IN] char*　：　filename2<BR>
      　　２つ目の画像ファイル名。<BR>
      　　２つ目が不必要な場合は、存在しないファイル名を、<BR>
      　　渡してください。<BR>
      <BR>
      4. [IN] float　：　uanim<BR>
      5. [IN] float　：　vanim<BR>
      　　２枚目の画像の、ＵＶ座標を、毎フレーム、どれくらい、<BR>
      　　移動させるかを指定します。<BR>
      　　通常は、0から１までの値を指定してください。<BR>
      <BR>
      6. [IN] int　：　isround<BR>
      　　isroundに、１を指定すると、<BR>
      　　ビューの回転に対応して、<BR>
      　　一つ目の画像ファイルのＵＶ座標が、回転します。<BR>
      　　この際、画像ファイルの左端と、右端が、<BR>
      　　連続するようなデータでないと、<BR>
      　　つなぎ目が見えてしまいますので、注意してください。<BR>
      　　isroundに０を指定すると、<BR>
      　　１つ目の画像は、回転しません。<BR>
      <BR>
      7. [IN] float　：　fogdist<BR>
      　　フォグの計算に使う、カメラからの距離を指定します。<BR>
      　　この引数に、E3DSetLinearFogParamsで指定する<BR>
      　　endより小さい値を指定すれば、<BR>
      　　背景は、フォグの色に染まりながらも、<BR>
      　　うっすらと見えるように出来ます。<BR>
<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1<BR>
      <BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DSetBGU</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">背景</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">背景のＵＶ座標のＵ座標を指定します。<BR>
      <BR>
      画面の左端のＵ座標の値をstartu引数に、<BR>
      <BR>
      画面の右端のＵ座標の値をendu引数に、<BR>
      それぞれ、指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="313"><BR>
      1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] float　：　startu<BR>
      　　画面左端のＵ座標の値。<BR>
      <BR>
      3. [IN] float　：　endu<BR>
      　　画面右端のＵ座標の値。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DSetBGV</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">背景</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">背景のＵＶ座標のＶ座標を指定します。<BR>
      <BR>
      画面の一番上のＶ座標の値をstartv引数に、<BR>
      <BR>
      画面の一番下のＶ座標の値をendv引数に、<BR>
      それぞれ、指定してください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] float　：　startv<BR>
      　　画面左端のV座標の値。<BR>
      <BR>
      3. [IN] float　：　endv<BR>
      　　画面右端のV座標の値。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DDestroyBG</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">背景</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">背景を破棄します。</TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DAddMotion</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">モーション</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">モーションデータ(*.qua)を読み込む。</TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] int　：　hsid<BR>
      　　どのモデルデータに対するモーションかを指定する。<BR>
      <BR>
      2. [IN] char*　：　fname<BR>
      　　*.quaのパス文字列。<BR>
      <BR>
      3. [IN] float　：　mvmult<BR>
      　　モーションの移動成分に掛ける倍率<BR>
      <BR>
      4. [OUT] int*　：　motidptr<BR>
      　　読み込んだモーションを識別する番号が代入されます。<BR>
      <BR>
      5. [OUT] int*　：　maxframeptr<BR>
      　　読み込んだモーションの最大フレーム番号（総フレーム数 - 1 と同じ）が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DSetMotionKind</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">モーション</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">カレントの、モーション番号を指定する。<BR>
      （カレントモーションを変更する。）<BR>
      <BR>
      この関数を実行すると、<BR>
      モーションのフレーム番号は、<BR>
      ０にセットされる。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DGetMotionKind</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">モーション</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">カレントのモーション番号を取得する。</TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [OUT] int*　：　motidptr<BR>
      　　モーションを識別する番号が代入される。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DSetNewPose</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">モーション</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">カレントのモーションを<BR>
      E3DSetMotionStepでセットしたstepフレーム数分、<BR>
      進ませる。<BR>
      <BR>
      <U>nextframe</U>に<BR>
      次に再生するフレーム番号がセットされる。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [OUT] int*　：　nextframe<BR>
      　　次に再生されるフレーム番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DSetMotionStep</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">モーション</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">モーションのステップ数を指定する。<BR>
      例えば、stepに２を指定すると<BR>
      ２フレームごとに（１フレームおきに）<BR>
      モーションを再生するようになる。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号<BR>
      <BR>
      3. [IN] int　：　step<BR>
      　　何フレームごとにモーションを再生するかを指定する。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1" width="157">E3DChkConflictAABB</TD>
      <TD class="hpb-cnt-tb-cell2" width="99">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2" width="367">２つの形状データが、衝突しているかどうかを判定する。<BR>
      <BR>
      （判定の元になるデータは、<BR>
      E3DChkInView命令によって更新される。）<BR>
      <BR>
      <BR>
      hsid1が視野外にある場合は、inviewflagに１が、<BR>
      hsid2が視野外にある場合は、inviewflagに２が、<BR>
      両方とも視野外の場合は、inviewflagに３が、<BR>
      両方とも視野内の場合は、inviewflagに０が代入されます。<BR>
      <BR>
      現在は、<BR>
      <B>E3DChkConflictOBB</B>があります。<BR>
      パーツ同士のあたり判定が出来るようになりました。<BR>
      モデル全体のあたり判定も出来ます。<BR>
      モデル全体のあたり判定をする場合でも、<BR>
      <U>E3DChkConflictOBBの方が、パーツごとの計算をするので、この関数よりも計算精度が高いです。<BR>
      </U><BR>
      新しい、E3DChkConflictOBBをお使いください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="313">1. [IN] int　：　hsid1<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　hsid2<BR>
      　　形状データを識別するid<BR>
      <BR>
      3. [OUT] int*　：　confflag<BR>
      　　hsid1, hsid2で識別される形状同士が<BR>
      　　衝突している場合は１が、<BR>
      　　衝突していない場合は０がセットされる。<BR>
      <BR>
      4. [OUT] int*　：　inviewflag<BR>
      　　 hsid1が視野外にある場合はinviewflagに１を、<BR>
      　　hsid2が視野外にある場合はinviewflagに２を、<BR>
      　　両方とも視野外の場合は<BR>
      inviewflagに３を、<BR>
      　　両方とも視野内の場合は<BR>
      inviewflagに０を代入します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2" width="114">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConflictOBB</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">２つの形状データの指定したパーツ同士が、衝突しているかどうを判定します。<BR>
      <BR>
      partno1, partno2には、<BR>
      E3DGetPartNoByNameで取得した、<BR>
      パーツの番号を渡してください。<BR>
      <BR>
      partnoに-1を指定すると、<BR>
      モデル全体とあたり判定をします。<BR>
      <BR>
      <BR>
      （判定の元になるデータは、<BR>
      E3DChkInView命令によって、更新されます。）<BR>
      <BR>
      <BR>
      hsid1が視野外にある場合は、inviewflagに１が、<BR>
      hsid2が視野外にある場合は、inviewflagに２が、<BR>
      両方とも視野外の場合は、inviewflagに３が、<BR>
      両方とも視野内の場合は、inviewflagに０が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid1<BR>
      　　形状データを識別するid<BR>
      2. [IN] int　：　partno1<BR>
      　　hsid1のモデル中のパーツの番号<BR>
      <BR>
      3. [IN] int　：　hsid2<BR>
      　　形状データを識別するid<BR>
      4. [IN] int　：　partno2<BR>
      　　hsid2のモデル中のパーツの番号<BR>
      <BR>
      5. [OUT] int*　：　confflag<BR>
      　　hsid1, hsid2で識別される形状同士が<BR>
      　　衝突している場合は１が、<BR>
      　　衝突していない場合は０がセットされる。<BR>
      <BR>
      6. [OUT] int*　：　inviewflag<BR>
      　　 hsid1が視野外にある場合はinviewflagに１を、<BR>
      　　hsid2が視野外にある場合はinviewflagに２を、<BR>
      　　両方とも視野外の場合は<BR>
      inviewflagに３を、<BR>
      　　両方とも視野内の場合は<BR>
      inviewflagに０を代入します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBillboardAlpha</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボードの頂点のアルファ値を設定します。<BR>
      <BR>
      sigモデルデータのアルファの設定は<BR>
      E3DSetMaterialAlphaをお使いください。<BR>
      <BR>
      <BR>
      alphaval が１．０の時は、不透明に、<BR>
      alphavalが０．０の時は、完全に透明になります。<BR>
      <BR>
      <U>alphavalに１．０以外の値を指定した場合は、<BR>
      E3DRenderの2番目の引数withalphaに、<BR>
      １を指定して描画します。<BR>
      <BR>
      </U></TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bbid<BR>
      　　E3DCreateBillboardで取得した、<BR>
      　　ビルボードidを渡してください。<BR>
      <BR>
      2. [IN] float　：　alphaval<BR>
      　　頂点のアルファ値を指定します。<BR>
      　　<BR>
      　　頂点のアルファ値は、０．０から１．０の値で<BR>
      　　指定してください。<BR>
      　　範囲外の値は、クランプしてセットします。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetPos</TD>
      <TD class="hpb-cnt-tb-cell2">モデル位置</TD>
      <TD class="hpb-cnt-tb-cell2">形状データの位置をセットする。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　pos<BR>
      　形状データを　( pos.x, pos.y, pos.z) に移動する。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetPos</TD>
      <TD class="hpb-cnt-tb-cell2">モデル位置</TD>
      <TD class="hpb-cnt-tb-cell2">形状データの位置を取得する。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [OUT] D3DXVECTOR3*　：　pos<BR>
      　　形状データの位置を取得する。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetDir</TD>
      <TD class="hpb-cnt-tb-cell2">モデル向き</TD>
      <TD class="hpb-cnt-tb-cell2">形状データの向きを指定する。<BR>
      <S>X軸、Y軸、Z軸の順番に、<BR>
      指定した角度だけ回転します。</S><BR>
      <BR>
      ver5.2.2.9からZ,X,Y軸の順番で回転するようになりました。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　deg<BR>
      　　形状データの向きをX,Y,Z軸のそれぞれの角度（degree）で指定する。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.2.2.9で仕様変更<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRotateInit</TD>
      <TD class="hpb-cnt-tb-cell2">モデル向き</TD>
      <TD class="hpb-cnt-tb-cell2">形状データの向きを初期化します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRotateX</TD>
      <TD class="hpb-cnt-tb-cell2">モデル向き</TD>
      <TD class="hpb-cnt-tb-cell2">形状データを、X軸に関して、degx 度だけ回転します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] float　：　degx<BR>
      　　回転角度。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRotateY</TD>
      <TD class="hpb-cnt-tb-cell2">モデル向き</TD>
      <TD class="hpb-cnt-tb-cell2">形状データを、Ｙ軸に関して、degy 度だけ回転します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] float　：　degy<BR>
      　　回転角度。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRotateZ</TD>
      <TD class="hpb-cnt-tb-cell2">モデル向き</TD>
      <TD class="hpb-cnt-tb-cell2">形状データを、Z軸に関して、degz 度だけ回転します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] float　：　degz<BR>
      　　回転角度。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DTwist</TD>
      <TD class="hpb-cnt-tb-cell2">モデル向き</TD>
      <TD class="hpb-cnt-tb-cell2">形状データを、現在向いている方向を軸として、deg度だけ、回転します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] float　：　deg<BR>
      　　回転角度。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DPosForward</TD>
      <TD class="hpb-cnt-tb-cell2">モデル位置</TD>
      <TD class="hpb-cnt-tb-cell2">形状データを、現在向いている方向に、stepだけ移動する。<BR>
      <BR>
      ただし、形状データが、default状態で、<BR>
      Z軸の方向を向いていると仮定する。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] float　：　step<BR>
      　　移動距離を指定する。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCloseTo</TD>
      <TD class="hpb-cnt-tb-cell2">モデル位置</TD>
      <TD class="hpb-cnt-tb-cell2">hsid1で識別される形状をhsid2で識別される形状の方向に動かす。<BR>
      <BR>
      内部でE3DDirToTheOtherを呼び出します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid1<BR>
      　　移動する形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　hsid2<BR>
      　　hsid2で指定した形状データの方向に移動する。<BR>
      <BR>
      3. [IN] float　：　step<BR>
      　　移動距離を指定する。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDirToTheOtherXZ</TD>
      <TD class="hpb-cnt-tb-cell2">モデル向き</TD>
      <TD class="hpb-cnt-tb-cell2">hsid1で識別される形状をXZ平面でhsid2で識別される形状の方向を向くようにする。<BR>
      <BR>
      ただし、形状データが初期状態で<BR>
      Z軸の負の方向(0.0, 0.0, -1.0)を向いているものと仮定しています。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid1<BR>
      　　向きを変える形状データを、識別するid<BR>
      <BR>
      2. [IN] int　：　hsid2<BR>
      　　hsid2で指定した形状データの方向を向く。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDirToTheOther</TD>
      <TD class="hpb-cnt-tb-cell2">モデル向き</TD>
      <TD class="hpb-cnt-tb-cell2">E3DDirToTheOtherXZの３次元版。<BR>
      <BR>
      ただし、形状データが初期状態で<BR>
      Z軸の負の方向(0.0, 0.0, -1.0)を向いているものと仮定しています。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid1<BR>
      　　向きを変える形状データを、識別するid<BR>
      <BR>
      2. [IN] int　：　hsid2<BR>
      　　hsid2で指定した形状データの方向を向く。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSeparateFrom</TD>
      <TD class="hpb-cnt-tb-cell2">モデル位置</TD>
      <TD class="hpb-cnt-tb-cell2">hsid1で識別される形状を、hsid2で識別される形状と、逆の方向に、動かす。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid1<BR>
      　　移動する形状データを、識別するid<BR>
      <BR>
      2. [IN] int　：　hsid2<BR>
      　　hsid2で指定した形状データと反対方向に移動する。<BR>
      <BR>
      3. [IN] float　：　dist<BR>
      　　形状同士をどのくらいの距離、離すかを指定する。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCameraPos</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラの位置を取得する。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] D3DXVECTOR3*　：　posptr<BR>
      　　カメラの位置 を取得する。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetCameraPos</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラの位置を指定する。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　pos<BR>
      　　カメラを　( pos.x, pos.y, pos.z) に移動する。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCameraDeg</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラの向きを取得する。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] float*　：　degxzptr<BR>
      　　カメラのXZ平面での角度を取得する。<BR>
      <BR>
      2. [OUT] float*　：　degyptr<BR>
      　　カメラの仰ぎ角度を取得する。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetCameraDeg</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラの向きを指定する。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　degxz<BR>
      　　カメラのXZ平面での角度を指定する。<BR>
      <BR>
      2. [IN] float　：　degy<BR>
      　　カメラの仰ぎ角度を指定する。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetCameraTarget</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラの注視点を指定する。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　target<BR>
      　　カメラの注視点を(target.x, target.y, target.z)にセットする。<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　upvec<BR>
      　　カメラの上方向のベクトルを指定する。内部で、正規化して使用される。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkInView</TD>
      <TD class="hpb-cnt-tb-cell2">描画準備</TD>
      <TD class="hpb-cnt-tb-cell2">hsidで識別されるモデルが、視野内にあるかどうかを、判定します。<BR>
      <BR>
      結果は、E3DHSPの内部データに、セットされます。<BR>
      <BR>
      視野外のオブジェクトや、パーツは、<BR>
      E3DRender時に、<BR>
      自動的に、処理をスキップするようになります。<BR>
      <BR>
      <B><U>必ず、E3DSetPosや、E3DSetNewPoseより後、<BR>
      E3DRenderや、あたり判定より前に、<BR>
      呼び出してください。<BR>
      </U></B><BR>
      この命令を呼び出した後の*statptrには、<BR>
ひとつも視野内にパーツがない場合は０が、<BR>
少なくとも１つは視野内にパーツがある場合は１がセットされます。<BR>
<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      3. [OUT] int*　：　statptr<BR>
      　　視野内情報が格納される。<BR>
      　　詳しくは前記をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DEnableDbgFile</TD>
      <TD class="hpb-cnt-tb-cell2">デバッグ</TD>
      <TD class="hpb-cnt-tb-cell2">デバッグ情報を、dbg.txtに出力するように、します。</TD>
      <TD class="hpb-cnt-tb-cell2">なし</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetProjection</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">プロジェクションを指定する。<BR>
      <BR>
      この関数を呼び出さなかった場合は、<BR>
      near面：100.0, far面：10000.0, 視野角：45.0度<BR>
      がdefaultで適用される。<BR>
      <BR>
      farが大きいほど描画する範囲が多くなり描画速度は重くなる。<BR>
      また設定によっては距離の近い物同士の上下関係が崩れることがある。<BR>
      これを避けるには、なるべくnearを大きくしfarを小さくすることが有効である。ただしnear &lt; far を守ることは言うまでもない。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　near<BR>
      　　クリッピングの近い側の距離<BR>
      <BR>
      2. [IN] float　：　far <BR>
      　　クリッピングの遠い側の距離<BR>
      <BR>
      3. [IN] float　：　fovdeg<BR>
      　　視野角（degree）<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetKeyboardState</TD>
      <TD class="hpb-cnt-tb-cell2">キーボード</TD>
      <TD class="hpb-cnt-tb-cell2">256 個の仮想キーの状態を、指定されたバッファkeybufへコピーします。<BR>
      <BR>
      <U>keybuf は、この関数を使用する前に、<BR>
      int keybuf[256];<BR>
      で、確保してください。<BR>
      </U><BR>
      複数のキーの状態を、一度の呼び出しで、<BR>
      取得できます。<BR>
      <BR>
      例えば、Ａキーが押されているかどうかを<BR>
      確かめる場合は、<BR>
      E3DGetKeyboardState<BR>
      呼び出し後に、<BR>
      keybuf['A'] の値を調べます。<BR>
      （　’　を忘れずに。　）<BR>
      ０が入っていた場合は、押されていません。<BR>
      １が入っていた場合は、押されています。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　keybuf<BR>
      　　keybufに、キーの状態が、代入されます。<BR>
      　　keybufは、int keybuf[256]; で、<BR>
      　　作成されている必要があります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDrawText</TD>
      <TD class="hpb-cnt-tb-cell2">テキスト</TD>
      <TD class="hpb-cnt-tb-cell2">画面上の(pos.x, pos.y) にcol.r, col.g, col.b で指定した色でstrの文字列を書く。<BR>
      <BR>
      col.aは無視される。<BR>
      <BR>
      <U>英数字のみ。</U><BR>
      scaleが１.0のときは、１２ポイントの大きさ。<BR>
      <BR>
      E3DCOLOR4UCはusercoef.hで定義されている。<BR>
      <BR>
      \nで改行できます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR2　：　pos<BR>
      　　座標<BR>
      <BR>
      2. [IN] float　：　scale<BR>
      　　スケール。<BR>
      <BR>
      3. [IN] E3DCOLOR4UC　：　col <BR>
      　　色<BR>
      <BR>
      7. [IN] char*　：　str<BR>
      　　表示文字列。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDrawBigText</TD>
      <TD class="hpb-cnt-tb-cell2">テキスト</TD>
      <TD class="hpb-cnt-tb-cell2">画面上の(pos.x, pos.y) にcol.r, col.g, col.b で指定した色でstrの文字列を書く。<BR>
      <BR>
      col.aは無視される。<BR>
      <BR>
      <U>英数字のみ。</U><BR>
      scaleが１.0のときは、36ポイントの大きさ。<BR>
      <BR>
      E3DCOLOR4UCはusercoef.hで定義されている。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR2　：　pos<BR>
      　　座標<BR>
      <BR>
      2. [IN] float　：　scale<BR>
      　　スケール。<BR>
      <BR>
      3. [IN] E3DCOLOR4UC　：　col <BR>
      　　色<BR>
      <BR>
      7. [IN] char*　：　str<BR>
      　　表示文字列。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DWaitbyFPS</TD>
      <TD class="hpb-cnt-tb-cell2">同期</TD>
      <TD class="hpb-cnt-tb-cell2">指定したfpsに、近くなるように、waitします。<BR>
      <BR>
      ｆｐｓとは、1秒間に描画するのこと回数です。<BR>
      <BR>
      指定したｆｐｓ以上、<BR>
      処理を行わないようにするための命令です。<BR>
      <BR>
      遅いマシンが、速くなるわけではないので、<BR>
      注意してください。<BR>
      <BR>
      実際のｆｐｓが、retfps変数に、代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　ｆｐｓ<BR>
      　　指定したｆｐｓに近くなるようにwaitします。<BR>
      <BR>
      2. [OUT] int*　：　retfps<BR>
      　　実際のfpsが代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetFPS</TD>
      <TD class="hpb-cnt-tb-cell2">同期</TD>
      <TD class="hpb-cnt-tb-cell2">fpsを計測します。<BR>
      <BR>
      メインループの最後などで呼び出すことを想定しています。<BR>
      E3DGetFPSが呼ばれる時間間隔から、<BR>
      1秒間あたりに、何回呼び出されるかを計算します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　retfpsptr<BR>
      　　fpsが代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateLight</TD>
      <TD class="hpb-cnt-tb-cell2">ライト</TD>
      <TD class="hpb-cnt-tb-cell2">光源を作成します。<BR>
      <BR>
      光源の識別番号、lightIDが取得できます。<BR>
      以後、光源のパラメータの設定には、<BR>
      この、lightIDを使用します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　lightIDptr<BR>
      　　作成したライトを識別するIDが代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetDirectionalLight</TD>
      <TD class="hpb-cnt-tb-cell2">ライト</TD>
      <TD class="hpb-cnt-tb-cell2">lightIDで識別される光源に、平行光源のパラメータをセットする。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lightID<BR>
      　　光源を識別するid<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　dir<BR>
      　　平行光源の向きを<BR>
      　　ベクトル(dir.x, dir.y, dir.z)を正規化したベクトルに設定する。<BR>
      <BR>
      3. [IN] E3DCOLOR4UC　：　col<BR>
      　　平行光源の色を<BR>
      　　（col.r, col.g, col.b）に設定する。<BR>
      　　col.aは無視される。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetPointLight</TD>
      <TD class="hpb-cnt-tb-cell2">ライト</TD>
      <TD class="hpb-cnt-tb-cell2">lightIDで識別される光源に、ポイントライトのパラメータをセットする。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lightID<BR>
      　　光源を識別するid<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　pos<BR>
      　　ポイントライトの位置を<BR>
      　　（pos.x, pos.y, pos.z）に設定する。<BR>
      <BR>
      3. [IN] float　：　dist<BR>
      　　ポイントライトの光が届く距離を設定します。<BR>
      <BR>
      4. [IN] E3DCOLOR4UC　：　col<BR>
      　　ポイントライトの色を<BR>
      　　（col.r, col.g, col.b）に設定する。<BR>
      　　col.aは無視される。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyLight</TD>
      <TD class="hpb-cnt-tb-cell2">ライト</TD>
      <TD class="hpb-cnt-tb-cell2">ライトを破棄します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lightID<BR>
      　　削除する光源を、識別するid<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DClearZ</TD>
      <TD class="hpb-cnt-tb-cell2">描画</TD>
      <TD class="hpb-cnt-tb-cell2">Ｚバッファーをクリアーします</TD>
      <TD class="hpb-cnt-tb-cell2">なし</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyHandlerSet</TD>
      <TD class="hpb-cnt-tb-cell2">後処理</TD>
      <TD class="hpb-cnt-tb-cell2">E3DSigLoad, E3DAddMotionで作成した、<BR>
      オブジェクトを破棄します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMotionFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">E3DSetMotionKindの拡張版です。<BR>
      <BR>
      モーションの種類と、フレーム番号を<BR>
      セットすることが出来ます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号<BR>
      <BR>
      3. [IN] int　：　frameno<BR>
      　　フレーム番号<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateSprite</TD>
      <TD class="hpb-cnt-tb-cell2">スプライト</TD>
      <TD class="hpb-cnt-tb-cell2">スプライトを作成します。<BR>
      spriteIDで、スプライトを識別するＩＤを、<BR>
      取得できます。<BR>
      <BR>
      スプライトの操作時には、この、spriteIDを<BR>
      使用します。<BR>
      <BR>
      作成されるスプライトのサイズは、<BR>
      元の画像ファイルの大きさと、<BR>
      異なる場合があります。<BR>
      <BR>
      サイズは、E3DGetSpriteSize で、<BR>
      確認してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　画像ファイル名。<BR>
      <BR>
      2. [IN] int　：　transparentflag<BR>
      　　透過フラグ。<BR>
      <BR>
      　　画像ファイルのアルファをもとに透過する場合、<BR>
      　　あるいは、画像ファイルにアルファが無く透過もしない場合０を指定してください。<BR>
      <BR>
      　　１をセットすると黒色を透過色として色抜きします。<BR>
      <BR>
      　　２をセットするとtpcolで指定した色を透過色とします<BR>
      <BR>
      　　<B><U>この関数のtransparetflagの意味は他の関数のtransparentとは違うので気を付けてください。</U></B><BR>
      <BR>
      3. [IN] E3DCOLOR4UC*　：　tpcolptr<BR>
      　　transparentflag = 2 のとき透過色を指定します。<BR>
      　　透過色を指定しない場合は０を渡します。<BR>
      　　tpcolptr-&gt;aは無視されます。<BR>
      <BR>
      4. [OUT] int*　：　spriteIDptr<BR>
      　　作成したスプライトを識別するＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DBeginSprite</TD>
      <TD class="hpb-cnt-tb-cell2">スプライト</TD>
      <TD class="hpb-cnt-tb-cell2">スプライトを描画できるように、<BR>
      デバイスを準備します。<BR>
      <BR>
      E3DRenderSprite命令を、<BR>
      E3DBeginSpriteと、E3DEndSpriteで、<BR>
      サンドイッチするように、記述してください。<BR>
      <BR>
      E3DBeginSpriteとE3DEndSpriteは、<BR>
      E3DBeginSceneとE3DEndSceneの間に記述してください。<BR>
      <BR>
      スプライトを描画すると、レンダーステートが変化するので、<BR>
      hsidなどを描画した後、最後に、スプライトの描画命令を書くことをおすすめします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">なし</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DEndSprite</TD>
      <TD class="hpb-cnt-tb-cell2">スプライト</TD>
      <TD class="hpb-cnt-tb-cell2">
      E3DRenderSprite命令を、<BR>
      E3DBeginSpriteと、E3DEndSpriteで、<BR>
      サンドイッチするように、記述してください。</TD>
      <TD class="hpb-cnt-tb-cell2">なし</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRenderSprite</TD>
      <TD class="hpb-cnt-tb-cell2">スプライト</TD>
      <TD class="hpb-cnt-tb-cell2">spriteIDで識別される、スプライトを、レンダリングします。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　spriteID<BR>
      　　スプライトを識別するＩＤ。<BR>
      <BR>
      2. [IN] float　：　scalex<BR>
      3. [IN] float　：　scaley<BR>
      　　スプライトのｘ軸、ｙ軸方向の倍率を指定します。（等倍は１．０）<BR>
      <BR>
      4. [IN] D3DXVECTOR3　：　tra<BR>
      　　スプライトの描画位置（tra.x, tra.y）を指定します。<BR>
      　　指定した位置がスプライトの左上の座標となります。<BR>
      <BR>
      tra.zは描画時の奥行き情報。<BR>
      ３D描画との前後関係にも、反映されます。<BR>
      <BR>
      　　tra.zには0.0から1.0の<B>float</B>を指定してください。<BR>
      　　0.0のとき、一番手前に描画され、<BR>
      　　1.0のとき、一番奥に描画されます。<BR>
      　　（ビデオカードによっては１．０は表示されません。いちばん奥は0.99999などにしておくのが安全です。）<BR>
      <BR>
      　　0.0から1.0の間は、均等な効果ではありません。<BR>
      　　値を増やしても、あまり効果の無い場所や、<BR>
      　　少し、値を増やしただけで、効果が大きくなる範囲が　　あります。<BR>
      　　Easy3Dの場合は、0.99以降が、<BR>
      　　少し値を増やしただけで、<BR>
      　　効果が大きい範囲となります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSpriteSize</TD>
      <TD class="hpb-cnt-tb-cell2">スプライト</TD>
      <TD class="hpb-cnt-tb-cell2">spriteIDで識別される、スプライトの、サイズを取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　spriteID<BR>
      　　スプライトを識別するＩＤ。<BR>
      <BR>
      2. [OUT] int*　：　spriteWidthptr<BR>
      3. [OUT] int*　：　spriteHeightptr<BR>
      　　幅と高さが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetSpriteRotation</TD>
      <TD class="hpb-cnt-tb-cell2">スプライト</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateSprite命令で作成したスプライトを回転させます。<BR>
      <BR>
      （center.x, center.y）の座標を中心に回転します。<BR>
      （0, 0）を指定すると、スプライトの左上を中心に回転します。<BR>
      <BR>
      スプライトの中央を中心に回転したいときは、<BR>
      まず、E3DGetSpriteSize命令で、<BR>
      スプライトのサイズ、sizex, sizey を取得します。<BR>
      center.x = sizex / 2<BR>
      center.y = sizey / 2<BR>
      の値をこの関数に渡せば、ＯＫです。<BR>
      <BR>
      回転角度は、絶対量です。<BR>
      相対量ではありません。<BR>
      <BR>
      E3DSetSpriteRotation命令は、<BR>
      一度、呼び出せば、内部で、情報を記憶しますので、次に異なるパラメータで呼び出すまで、<BR>
      その値が有効になります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　spid<BR>
      　　スプライトデータを識別するＩＤ<BR>
      <BR>
      2. [IN] D3DXVECTOR2　：　center<BR>
      　　(center.x, center.y)の座標を中心に回転します。<BR>
      <BR>
      3. [IN] float　：　rotdeg<BR>
      　　rotdeg 度だけスプライトを回転します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetSpriteARGB</TD>
      <TD class="hpb-cnt-tb-cell2">スプライト</TD>
      <TD class="hpb-cnt-tb-cell2">スプライトに乗算する色を指定します。<BR>
      <BR>
      col.a に255より小さい値を渡せば、<BR>
      半透明のスプライトの描画が出来ます。<BR>
      <BR>
      スプライトの色を変えたくない場合には、<BR>
      col.r, col.g, col.bには、255を渡してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　spid<BR>
      　　スプライトデータを識別するＩＤ<BR>
      <BR>
      2. [IN] E3DCOLOR4UC　：　col<BR>
      　　スプライトに乗算する色を指定します。<BR>
      　　半透明にする場合には、<BR>
      　　col.aに255より小さい値を入れます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroySprite</TD>
      <TD class="hpb-cnt-tb-cell2">スプライト</TD>
      <TD class="hpb-cnt-tb-cell2">spriteIDで識別される、スプライトを、<BR>
      破棄します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　spriteID<BR>
      　　スプライトを識別するＩＤ。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConfBillboardBS</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボード</TD>
      <TD class="hpb-cnt-tb-cell2">指定した境界球（中心と半径）と、全てのビルボードとのあたり判定をします。<BR>
      <BR>
      hsidの代わりに、境界球を指定すること以外は、<BR>
      E3DChkConfBillboardと同じです。<BR>
      <BR>
      衝突したビルボードのＩＤが取得できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　center<BR>
      　　境界球の中心座標( center.x, center.y, center.z )<BR>
      <BR>
      2. [IN] float　：　r<BR>
      　　境界球の半径<BR>
      <BR>
      3. [IN] float　：　confrate<BR>
      　　ビルボードの境界球の半径に、掛ける係数<BR>
      　　半径　×　confrate<BR>
      　　で計算されます。<BR>
      <BR>
      6. [OUT] int*　：　resultptr<BR>
      　　あたり判定の結果が代入されます。<BR>
      　　当たった場合は１が、<BR>
      　　当たらなかった場合は０が代入されます。<BR>
      <BR>
      <BR>
      7. [OUT] int*　：　confbbidptr<BR>
      <BR>
      8. [IN] int　：　arrayleng<BR>
      　　衝突したビルボードのＩＤを格納するための配列<BR>
      　　confbbidptr = (int*)malloc( sizeof( int ) * arrayleng );<BR>
      　　などの命令で、配列を作成して、<BR>
      　　この関数に指定してください。<BR>
      <BR>
      　　arrayleng個以上のビルボードと、<BR>
      　　同時に衝突した場合には、エラーになるので、<BR>
      　　配列長のarraylengは、少し大きめの値にしてください。<BR>
      <BR>
      9. [OUT] int*　：　confnumptr<BR>
      　　衝突したビルボードの個数が代入されます。<BR>
      　　maxno = *confnumptr - 1<BR>
      　　とすると、<BR>
      　　*confbbidptr から、*(confbbidptr + maxno) までの間に、<BR>
      　　衝突したビルボードのＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConfBillboard</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボード</TD>
      <TD class="hpb-cnt-tb-cell2">hsidで識別されるモデルデータと、全てのビルボードのあたり判定をします。<BR>
      <BR>
      境界球による判定を行います。<BR>
      <BR>
      当たらなかった場合は、<BR>
      resultに０が代入され、<BR>
      当たった場合は、<BR>
      resultに１が代入されます。<BR>
      <BR>
      confrateで、ビルボードの境界球の大きさを変更することが出来ます。<BR>
      <BR>
      <BR>
      例えば、confrateに0.5を入れると、<BR>
      　実際の半径×0.5<BR>
      つまり、半分の半径で計算されます。<BR>
      <BR>
      confrateに小さな値を入れることで、<BR>
      モデルがビルボードの近くを<BR>
      すり抜けることが出来るようになります。<BR>
      <BR>
      <BR>
      衝突したビルボードのＩＤが取得できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別する番号<BR>
      <BR>
      2. [IN] float　：　confrate<BR>
      　　ビルボードの境界球の半径に、掛ける係数<BR>
      　　半径　×　confrate<BR>
      　　で計算されます。<BR>
      <BR>
      3. [OUT] int*　：　resultptr<BR>
      　　あたり判定の結果が代入されます。<BR>
      　　当たった場合は１が、<BR>
      　　当たらなかった場合は０が代入されます。<BR>
      <BR>
      4. [OUT] int*　：　confbbidptr<BR>
      <BR>
      5. [IN] int　：　arrayleng<BR>
      　　衝突したビルボードのＩＤを格納するための配列<BR>
      　　confbbidptr = (int*)malloc( sizeof( int ) * arrayleng );<BR>
      　　などの命令で、配列を作成して、<BR>
      　　この関数に指定してください。<BR>
      <BR>
      　　arrayleng個以上のビルボードと、<BR>
      　　同時に衝突した場合には、エラーになるので、<BR>
      　　配列長のarraylengは、少し大きめの値にしてください。<BR>
      <BR>
      6. [OUT] int*　：　confnumptr<BR>
      　　衝突したビルボードの個数が代入されます。<BR>
      　　maxno = *confnumptr - 1<BR>
      　　とすると、<BR>
      　　*confbbidptr から、*(confbbidptr + maxno) までの間に、<BR>
      　　衝突したビルボードのＩＤが代入されます。<BR>
      <BR>
      <BR>
</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConflictBS</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">境界球によるあたり判定を行います。<BR>
      判定の際に<U>E3DChkInViewでセットした<BR>
      データを使用します</U>。<BR>
      <BR>
      conflevelに１を指定した場合は、<BR>
      モデル単位の粗い判定のみを行います。<BR>
      <BR>
      conflevelに２を指定した場合は、<BR>
      パーツ単位の判定を行います。<BR>
      <BR>
      <BR>
      現在は、<BR>
      任意のパーツ同士のあたり判定の出来る、<BR>
      E3DChkConflictBSPart, E3DChkConflictBSPartArrayがあります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid1<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　hsid2<BR>
      　　形状データを識別するid<BR>
      <BR>
      3. [IN] int　：　conflevel<BR>
      　　１を指定した場合はモデル単位の判定を、<BR>
      　　２を指定した場合はパーツ単位の判定をします。<BR>
      <BR>
      4. [OUT] int*　：　confflagptr<BR>
      　　hsid1, hsid2で識別される形状同士が、<BR>
      　　衝突している場合は、１が、<BR>
      　　衝突していない場合は０がセットされる。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConflictBSPart</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">境界球によるあたり判定を、任意のパーツごとに行います。<BR>
      <BR>
      判定の際に、<U>E3DChkInViewでセットした<BR>
      データを使用します</U>。<BR>
      <BR>
      <BR>
      partno1, partno2には、<BR>
      E3DGetPartNoByNameで取得した<BR>
      パーツの番号を渡してください。<BR>
      <BR>
      partnoに-1を指定すると、<BR>
      モデル全体とあたり判定をします。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid1<BR>
      　　形状データを識別するid<BR>
      2. [IN] int　：　partno1<BR>
      　　hsid1のモデル中のパーツの番号<BR>
      <BR>
      3. [IN] int　：　hsid2<BR>
      　　形状データを識別するid<BR>
      4. [IN] int　：　partno2<BR>
      　　hsid2のモデル中のパーツの番号<BR>
      <BR>
      5. [OUT] int*　：　confflagptr<BR>
      　　hsid1, hsid2で識別される形状同士が、<BR>
      　　衝突している場合は、１が、<BR>
      　　衝突していない場合は０がセットされる。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateProgressBar</TD>
      <TD class="hpb-cnt-tb-cell2">プログレスバー</TD>
      <TD class="hpb-cnt-tb-cell2">メインウインドウの下の部分に、プログレスバーを作ります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">なし</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetProgressBar</TD>
      <TD class="hpb-cnt-tb-cell2">プログレスバー</TD>
      <TD class="hpb-cnt-tb-cell2">作業の達成率などを、<BR>
      プログレスバーに表示させます。<BR>
      <BR>
      newpos は、０から１００の間の数を、<BR>
      セットしてください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　newpos<BR>
      　　0から１００の値。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyProgressBar</TD>
      <TD class="hpb-cnt-tb-cell2">プログレスバー</TD>
      <TD class="hpb-cnt-tb-cell2">プログレスバーを削除します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">なし</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadGroundBMP</TD>
      <TD class="hpb-cnt-tb-cell2">地面</TD>
      <TD class="hpb-cnt-tb-cell2">BMPデータから、地面を生成します。<BR>
      <BR>
      詳しくは、<A href="e3dhsp_ground.htm">地面データの作り方</A>をご覧ください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename1<BR>
      　　地面の座標情報の元となる、ＢＭＰファイル名<BR>
      <BR>
      2. [IN] char*　：　filename2<BR>
      　　地面の道の情報の元となる、ＢＭＰファイル名<BR>
      <BR>
      3. [IN] char*　：　filename3<BR>
      　　地面の川の情報の元となる、ＢＭＰファイル名<BR>
      <BR>
      4. [IN] char*　：　filename4<BR>
      　　地面、道、川の模様を決める、ＢＭＰファイル名<BR>
      <BR>
      5. [IN] float　：　maxx<BR>
      　　地面のＸ座標の最大値<BR>
      <BR>
      6. [IN] float　：　maxz<BR>
      　　地面のＺ座標の最大値<BR>
      <BR>
      7. [IN] int　：　divx<BR>
      　　X方向の分割数<BR>
      <BR>
      8. [IN] int　：　divz<BR>
      　　Z方向の分割数<BR>
      <BR>
      9. [IN] float　：　maxheight<BR>
      　　地面の高さの最大値<BR>
      <BR>
      10. [OUT] int*　：　hsidptr<BR>
      　　作成した地面データを識別するＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCameraPosForward</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラを、向いている方向に、<BR>
      stepの距離だけ<BR>
      移動させます。<BR>
      <BR>
      stepにマイナスを与えると、<BR>
      後ろに進めます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　step<BR>
      　　進む距離を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBeforePos</TD>
      <TD class="hpb-cnt-tb-cell2">モデル位置</TD>
      <TD class="hpb-cnt-tb-cell2">E3DChkConfGroundで使用する座標を保存します。<BR>
      一つ前の座標を保存するための命令です。<BR>
      保存した値は、内部で、当たり判定命令で使用します。<BR>
      <BR>
      メインループの最後の部分などで、<BR>
      呼んでください。<BR>
      一番最初のE3DPosの直後でも、<BR>
      呼んでください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　charahsid<BR>
      　　形状データを識別するid<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConfGround</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">groundhsidで識別される地面と、charahsidで識別されるキャラクターとのあたり判定をします。<BR>
      <BR>
      groundhsidは、E3DLoadGroundBMP、<BR>
      または、E3DLoadMQOFileAsGroundで取得したものでなければいけません。<BR>
      <BR>
      キャラクターの現在の座標と、<B><U>E3DSetBeforePos</U></B>で保存された古い座標とを結ぶ線分と、<BR>
      地面の各ポリゴンとのあたり判定をします。<BR>
      <BR>
      地面の上を這うように動くためのモードと、<BR>
      飛行機のように飛ぶためのモードの<BR>
      ２種類あります。<BR>
      <BR>
      這うモードの時は、毎回、*adjustptrに<BR>
      地面の座標が返されます。<BR>
      飛ぶモードの時は、地面と衝突したときに、<BR>
      その座標が*adjustptrに返されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　charahsid<BR>
      　　移動する形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　groundhsid<BR>
      　　E3DLoadGroundBMP、<BR>
      　　または、E3DLoadMQOFileAsGroundで<BR>
      　　作成した形状データを<BR>
      　　識別するid<BR>
      <BR>
      3. [IN] int　：　mode<BR>
      　　０を指定すると、飛ぶモード<BR>
      　　１を指定すると、地面を這うモード<BR>
      <BR>
      4. [IN] float　：　diffmaxy<BR>
      　　一度の移動で登ることが出来る高さの最大値を<BR>
      　　指定してください。<BR>
      <BR>
      5. [IN] float　：　mapminy<BR>
      　　groundhsidで識別されるデータの一番低いＹ座標の値<BR>
      　　通常は、0.0です。<BR>
      <BR>
      6. [OUT] int*　：　resultptr<BR>
      　　あたり判定の結果が代入されます。<BR>
      　　<BR>
      　　mode == 0 のとき<BR>
      　　　　ぶつからなかった場合は*resutlptr = 0<BR>
      　　　　ぶつかった場合は、*resultptr = 1<BR>
      　　mode == 1のとき<BR>
      　　　　キャラクターの下に地面が無かった場合、<BR>
      　　　　または、全く移動しなかった場合、<BR>
      　　　　*resultptr = 0<BR>
      <BR>
      　　　　diffmaxyより高い高さを登ろうとしたとき、<BR>
      　　　　*resultptr = 1<BR>
      <BR>
      　　　　地面を下に降りたとき、<BR>
      　　　　または、diffmaxyより低い高さを登ったとき、<BR>
      　　　　*resultptr = 2<BR>
      <BR>
      　　となります。<BR>
      <BR>
      7. [OUT] D3DXVECTOR3*　：　adjust<BR>
      　　*resultptr != 0 のときに、<BR>
      　　　　mode == 0のときはぶつかった座標<BR>
      　　　　mode == 1のときは地面の座標が代入されます。<BR>
      <BR>
      <BR>
      8. [OUT] D3DXVECTOR3*　：　nptr<BR>
      　　*resultptr != 0 のときに、<BR>
      　　　　mode == 0のときはぶつかったポリゴン<BR>
      　　　　mode == 1のときは地面のポリゴンの<BR>
      　　　　法線ベクトルが代入されます。<BR>
      　　　　<BR>
      　　　　跳ね返る方向を決めるときなどに<BR>
      　　　　使用できるのではないかと思い、<BR>
      　　　　加えてみました。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConfGroundVec</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">befposとnewposを結ぶ線分と、groundhsidで識別される地面との<BR>
      あたり判定をします。<BR>
      <BR>
      線分の座標を、ユーザーが指定すること以外は、<BR>
      E3DChkConfGroundと全く、同じです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　befpos<BR>
      　　線分の始点を（befpos.x, befpos.y, befpos.z）で<BR>
      　　指定します。<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　newpos<BR>
      　　線分の終点を（newpos.x, newpos.y, newpos.z）で<BR>
      　　指定します。<BR>
      <BR>
      3. [IN] int　：　groundhsid<BR>
      　　E3DLoadGroundBMP、<BR>
      　　または、E3DLoadMQOFileAsGroundで<BR>
      　　作成した形状データを<BR>
      　　識別するid<BR>
      <BR>
      4. [IN] int　：　mode<BR>
      　　０を指定すると、飛ぶモード<BR>
      　　１を指定すると、地面を這うモード<BR>
      <BR>
      5. [IN] float　：　diffmaxy<BR>
      　　一度の移動で登ることが出来る高さの最大値を指定してください。<BR>
      <BR>
      6. [IN] float　：　mapminy<BR>
      　　groundhsidで識別されるデータの一番低いＹ座標の値<BR>
      <BR>
      7. [OUT] int*　：　resultptr<BR>
      　　あたり判定の結果が代入されます。<BR>
      　　<BR>
      　　mode == 0 のとき<BR>
      　　　　ぶつからなかった場合は、*resultptr = 0<BR>
      　　　　ぶつかった場合は、*resultptr = 1<BR>
      　　mode == 1のとき<BR>
      　　　　キャラクターの下に地面が無かった場合、<BR>
      　　　　または、全く移動しなかった場合、<BR>
      　　　　*resultptr = 0<BR>
      <BR>
      　　　　diffmaxyより高い高さを登ろうとしたとき、<BR>
      　　　　*resultptr = 1<BR>
      <BR>
      　　　　地面を下に降りたとき、<BR>
      　　　　または、diffmaxyより低い高さを登ったとき、<BR>
      　　　　*resultptr = 2<BR>
      <BR>
      8. [OUT] D3DXVECTOR3*　：　adjustptr<BR>
      　　*resultptr != 0 のときに、<BR>
      　　　　mode == 0のときはぶつかった座標<BR>
      　　　　mode == 1のときは地面の座標が代入されます。<BR>
      <BR>
      9. [OUT] D3DXVECTOR3*　：　nptr<BR>
      　　*resultptr != 0 のときに、<BR>
      　　　　mode == 0のときはぶつかったポリゴン<BR>
      　　　　mode == 1のときは地面のポリゴンの法線ベクトルが代入されます。<BR>
      　　　　<BR>
      跳ね返る方向を決めるときなどに使用できるのではないかと思い加えてみました。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetPartNoByName</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">モデル内のパーツの名前から、パーツの番号を取得します。<BR>
      <BR>
      パーツの名前は、RokDeBone2で確認してください。<BR>
      <BR>
      <U>ver1.0.6.1以前のRokDeBone2では、</U><BR>
      メタセコイアから読み込んだデータの、<BR>
      パーツの名前には、　&quot;　が付いているので、<BR>
      注意してください。<BR>
      <BR>
      昔のファイルの場合、<BR>
      例えば、名前が、&quot;obj1&quot; である場合、<BR>
      引数partname には、<BR>
      &quot;\&quot;obj1\&quot;&quot;<BR>
      というように、\&quot; を使用しなくては、いけません。<BR>
      （　現在のRokDeBone2で新規作成したファイルでは、<BR>
      パーツ名に”は付いていません。　）<BR>
      <BR>
      <BR>
      また、同じ名前のパーツが、複数ある場合、<BR>
      常に、一番最初に、見つかったパーツの番号が、取得されることに、注意してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] char*　：　partname<BR>
      　　RokDeBone2で表示される、パーツの名前。<BR>
      <BR>
      3. [OUT] int*　：　partnoptr<BR>
      　　名前がpartnameであるパーツの番号が代入される。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetVertNumOfPart</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">partnoで識別されるパーツに、いくつの頂点が含まれるかを取得します。<BR>
      <BR>
      E3DGetVertPos, E3DSetVertPos<BR>
      に渡す、vertno は、<BR>
      0 〜 (vertnum - 1) の間でなくては、なりません。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号<BR>
      <BR>
      3. [OUT] int*　：　vertnumptr<BR>
      　　パーツに含まれる頂点数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetVertPos</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">partnoで識別されるパーツ内の、頂点番号vertnoの、頂点の座標を取得します。<BR>
      <BR>
      ローカル座標とグローバル座標のどちらかを<BR>
      取得できます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　頂点の番号<BR>
      <BR>
      4. [IN] int　：　kind<BR>
      　　０を指定するとローカル座標<BR>
      　　１を指定するとグローバル座標が<BR>
      　　取得できます。<BR>
      <BR>
      5. [OUT] D3DXVECTOR3*　：　vertptr<BR>
      　　頂点の座標が代入されます。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetVertPos</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2"> partnoで識別されるパーツ内の、頂点番号vertnoの、頂点の座標（<U>ローカル座標</U>）をセットします。<BR>
      <BR>
      <BR>
      <U>ユーザーが、座標、姿勢を、<BR>
      全て、自分で管理することを想定した、<BR>
      上級者向けの機能です。</U><BR>
      <BR>
      <BR>
      例えば、目標地点に頂点座標を近づけていきたい場合などは、<BR>
      E3DSetPos hsid, 0.0, 0.0, 0.0<BR>
      E3DSetDir hsid, 0.0, 0.0, 0.0<BR>
      でワールド変換が行われないようにした状態で、<BR>
      E3DSetVertPosを使い、希望位置へ、<BR>
      頂点座標をセットする。<BR>
      などの、使用方法が、考えられます。<BR>
      <BR>
      <BR>
      AddMotionを行った、モデルデータにも、<BR>
      使用しないでください。<BR>
      （使用しても、ハングしたりはしませんが、<BR>
      あたり判定が、正確に行われません。）<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　頂点の番号<BR>
      <BR>
      4. [IN] D3DXVECTOR3　：　vert<BR>
      　　座標を指定の頂点にセットします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetPosOnGround</TD>
      <TD class="hpb-cnt-tb-cell2">モデル位置</TD>
      <TD class="hpb-cnt-tb-cell2"> E3DLoadGroundBMP、または、E3DLoadMQOFileAsGroundで作成した地面上の、適切な高さに、モデルデータを配置するための、関数です。<BR>
      <BR>
      (posx, mapmaxy, posz)と、<BR>
      (posx, mapminy, posz)を結ぶ線分と、<BR>
      地面データとの交点を求めて、<BR>
      その位置に、hsidのモデルデータを配置します。<BR>
      <BR>
      交点が複数ある場合は、<BR>
      (posx, mapmaxy, posz)から、一番近い交点が、選ばれます。<BR>
      <BR>
      <U>この命令を使う前に、少なくとも、一回は、<BR>
      E3DChkInView groundid<BR>
      が、呼ばれていないと、ちゃんと動作しません。<BR>
      </U> （groundid部分には、配置する地面のhsidを入れてください。）<BR>
      <BR>
      現バージョンではgroundidは、<BR>
      E3DLoadGroundBMP、<BR>または、E3DLoadMQOFileAsGround<BR>
      で取得したものしか、使用できません。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　配置したい形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　groundid<BR>
      　　E3DLoadGroundBMP、<BR>
      　　または、E3DLoadMQOFileAsGroundで<BR>
      　　作成した地面を識別するid<BR>
      <BR>
      3. [IN] float　：　mapmaxy<BR>
      　　地面データの高さの最大値<BR>
      <BR>
      4. [IN] float　：　mapminy<BR>
      　　地面データの高さの最小値<BR>
      <BR>
      5. [IN] float　：　posx<BR>
      6. [IN] float　：　posz<BR>
      　　地面の高さをＹとすると、<BR>
      　　（posx, Y,. posz）に、hsidのモデルデータを配置します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetPosOnGroundPart</TD>
      <TD class="hpb-cnt-tb-cell2">モデル位置</TD>
      <TD class="hpb-cnt-tb-cell2">地面パーツを指定して、地面にオブジェクトを配置します。<BR>
      <BR>
      パーツを指定すること以外は、<BR>
      E3DSetPosOnGroundと同じです。<BR>
      <BR>
      詳しくは、E3DSetPosOnGroundの説明をお読みください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　配置したい形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　groundid<BR>
      　　E3DLoadGroundBMP、<BR>
      　　または、E3DLoadMQOFileAsGroundで<BR>
      　　作成した地面を識別するid<BR>
      <BR>
      3. [IN] int　：　groundpart<BR>
      　　地面のパーツ番号を指定します。<BR>
      　　E3DGetPartNoByNameで取得した番号を<BR>
      　　指定してください。<BR>
      <BR>
      4. [IN] float　：　mapmaxy<BR>
      　　地面データの高さの最大値<BR>
      <BR>
      5. [IN] float　：　mapminy<BR>
      　　地面データの高さの最小値<BR>
      <BR>
      6. [IN] float　：　posx<BR>
      7. [IN] float　：　posz<BR>
      　　地面の高さをＹとすると、<BR>
      　　（posx, Y,. posz）に、hsidのモデルデータを配置します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateBillboard</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボード</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボードを作成します。<BR>
      <BR>
      <U>2000個まで</U>、ビルボードを作ることが出来ます。<BR>
      <BR>
      <BR>
      billboardidに、作成したビルボードを識別する<BR>
      番号が、代入されます。<BR>
      <BR>
      billboardidは、<BR>
      E3DSetBillboardPos,<BR>
      E3DSetBillboardOnGround,<BR>
      E3DDestroyBillboard,<BR>
      E3DChkConfBillboard<BR>
      の関数で、使用します。<BR>
      <BR>
      <U>billboardidは、hsidとは、全く異なるもの</U>なので、E3DSetPosなどの、hsidを使用する関数には、使えません。<BR>
      <BR>
      E3DCreateBillboardでは、<BR>
      transparentflagに、１をセットすれば、<BR>
      黒色を透過色として、扱えます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　ビルボードに貼り付けるテクスチャーのファイル名(フルパス)<BR>
      <BR>
      2. [IN] float　：　width<BR>
      　　ビルボードの幅。<BR>
      <BR>
      3. [IN] float　：　height<BR>
      　　ビルボードの高さ。<BR>
      <BR>
      4. [IN] int　：　transparentflag<BR>
      　　１を指定すると、<BR>
      　　テクスチャーの黒色（r = 0, g=0, b=0）を透過色として、<BR>
      　　扱います。<BR>
      　　<BR>
      　　０を指定すると、<BR>
      　　テクスチャーファイルの、<BR>
      　　アルファ値を元に、透過します。<BR>
      <BR>
      <BR>
      5. [IN] int　：　dirmode<BR>
      　　dirmodeに０を指定すると、<BR>
      　　ビルボードは、Ｙ軸に関してのみ、回転します。<BR>
      　　地面に立っている木などに使用してください。<BR>
      <BR>
      　　dirmodeの１を指定すると、<BR>
      　　ビルボードは、全方向に回転します。<BR>
      　　カメラの高さにかかわらず、カメラの方向を向かせたいもの<BR>
      　　例えば、火や煙などに、使用してください。<BR>
      <BR>
      6. [IN] int　：　orgflag<BR>
      　　ビルボードの原点の位置を指定します。<BR>
      <BR>
      　　orgflagに０を指定すると、<BR>
      　　原点は、ビルボードの四角形の下の辺の中心になります。<BR>
      　　地面に生やす木などの場合に、便利です。<BR>
      <BR>
      　　orgflagに１を指定すると、<BR>
      　　原点は、ビルボードの中心になります。<BR>
      　　爆発などの、特殊効果に使う場合に、便利です。<BR>
      <BR>
      <BR>
      7. [OUT] int*　：　billboardidptr<BR>
      　　作成したビルボードを識別する番号が、代入されます。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRenderBillboard</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボード</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateBillboard<BR>
      で作成されたビルボード全てを、<BR>
      描画します。<BR>
      <BR>
      各ビルボードは、<BR>
      視線の方向を向くようにセットされます。<BR>
      <BR>
      また、<BR>
      視点から、遠い方から順番に、描画されます。<BR>
      <BR>
      transskip引数の意味については<BR>
      E3DTransformBillboardの説明をお読みください。<BR>
      <BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　transskip<BR>
      　　１を指定すると描画準備の計算をスキップします。<BR>
      　　E3DTransformBillboardを使った場合に使用します。<BR>
      　　通常は０です。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBillboardPos</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボード</TD>
      <TD class="hpb-cnt-tb-cell2"> billboardidで識別されるビルボードの、位置を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　billboardid<BR>
      　　ビルボードを識別する番号<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　pos<BR>
      　　ビルボードの位置を、(pos.x, pos.y, pos.z)<BR>
      　　にセットします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBillboardOnGround</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボード</TD>
      <TD class="hpb-cnt-tb-cell2"> billboardidで識別されるビルボードの、位置を、指定したＸＺ座標の、地面の高さにセットします。<BR>
      <BR>
      <U>この命令を使う前に、少なくとも、一回は、<BR>
      E3DChkInView　scid, groundid, &amp;stat<BR>
      が呼ばれている必要があります。</U><BR>
      （groundid部分には、配置する地面のhsidを入れてください。）<BR>
      <BR>
      現バージョンではgroundidは、<BR>
      E3DLoadGroundBMP、<BR>または、E3DLoadMQOFileAsGround<BR>
      で取得したものしか、使用できません。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　billboardid<BR>
      　　ビルボードを識別する番号<BR>
      <BR>
      2. [IN] int　：　groundid<BR>
      　　groundidで識別される地面の上に、<BR>
      　　ビルボードが配置されます。<BR>
      <BR>
      3. [IN] float　：　mapmaxy<BR>
      　　地面データの一番大きなＹ座標<BR>
      <BR>
      4. [IN] float　：　mapminy<BR>
      　　地面データの一番小さなＹ座標<BR>
      　　（通常０．０）<BR>
      <BR>
      5. [IN] float　：　posx<BR>
      6. [IN] float　：　posz<BR>
      　　(posx, mapmaxy, posz)と、(posx, mapminy, posz)<BR>
      　　と地面データとの交点を求めて、<BR>
      　　地面上の適切な高さに、ビルボードを配置します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyBillboard</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボード</TD>
      <TD class="hpb-cnt-tb-cell2">billboardidで識別されるビルボードを、削除します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　billboardid<BR>
      　　ビルボードを識別する番号<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadMQOFileAsGround</TD>
      <TD class="hpb-cnt-tb-cell2">地面</TD>
      <TD class="hpb-cnt-tb-cell2">mqo ファイルを地面データとして、読み込みます。<BR>
      地面データを識別するidが、戻り値となります。<BR>
      取得したid は、E3DChkConfGroundなどの関数で、使用できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　読み込む、mqo ファイル名。<BR>
      <BR>
      2. [IN] float　：　mult<BR>
      　　形状データの座標に掛ける数値。<BR>
      　　座標値　＊　mult で計算されます。<BR>
      　　等倍は１．０<BR>
      <BR>
      3. [IN] int　：　adjustuvflag<BR>
      　　UV座標を正規化したいときは１を、<BR>
      　　そうでないときは、０を指定してください。<BR>
      　　何も指定しないときは、０として扱われます。<BR>
      　　２を指定すると0.0から1.0の間にクランプします。<BR>
      <BR>
      4. [IN] int　：　bonetype<BR>
      　　mqoにボーンが含まれている場合は<BR>
      　　ボーンのタイプを指定します。<BR>
      　　BONETYPE_RDB2を指定するとRokDeBone2形式の<BR>
      　　線分をボーンと認識するタイプになります。<BR>
      　　BONETYPE_MIKOを指定すると<BR>
      　　mikoto形式のタイプになります。<BR>
      　　省略するとBONETYPE_RDB2になります。<BR>
      　　これらの定数はusercoef.hで定義されています。<BR>
      <BR>
      5. [OUT] int*　：　hsidptr<BR>
      　　作成した地面を識別するhsidが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>ver5.0.2.6で拡張<BR>
<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSaveMQOFile</TD>
      <TD class="hpb-cnt-tb-cell2">モデルデータ</TD>
      <TD class="hpb-cnt-tb-cell2">hsidで指定したモデルのデータを、mqoの形式で出力します。<BR>
      <BR>
      地面データの出力などに、使用してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　出力するモデルのhsid<BR>
      <BR>
      2. [IN] char*　：　filename<BR>
      　　出力するファイル名<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBillboardInfo</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボード</TD>
      <TD class="hpb-cnt-tb-cell2">指定した番号の、ビルボード情報を、取得します。<BR>
      <BR>
      ビルボードの番号には、<BR>
      E3DCreateBillboardで取得した番号を、<BR>
      指定してください。<BR>
      　<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN, OUT] BBINFO*　：　bbinfoptr<BR>
      　　情報を取得したいビルボードの番号を<BR>
      　　bbinfo-&gt;bbidにセットしてから渡してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetNearBillboard</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボード</TD>
      <TD class="hpb-cnt-tb-cell2">指定した座標に、一番近いビルボードのIDを取得します。<BR>
      <BR>
      maxdist で指定した、距離より、遠いビルボードしか存在しない場合は、<BR>
      IDに、-1 が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　pos<BR>
      　　位置座標を、（pos.x, pos.y, pos.z）で指定します。<BR>
      <BR>
      <BR>
      2. [IN] float　：　maxdist<BR>
      　　maxdistで指定した距離より<BR>
      　　遠いビルボードしかない場合は、<BR>
      　　nearbbidに-1が代入されます。<BR>
      <BR>
      3. [OUT] int*　：　nearbbidptr<BR>
      　　（pos.x, pos.y, pos.z） に一番近く、<BR>
      　　maxdistより近いビルボードのＩＤを代入します。<BR>
      　　存在しない場合は-1を代入します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetInvisibleFlag</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">hsidで識別されるモデルのpartnoのパーツのInvisibleFlag(見えないフラグ)を取得します。<BR>
      <BR>
      <U>InvisibleFlagが、１になっているパーツは、あたり判定は行われますが表示はされません。</U><BR>
      進入禁止区域との境目に置く見えないオブジェクトとして使用することなどが、<BR>
      考えられます。<BR>
      <BR>
      partno にはE3DGetPartNoByNameで取得した番号を指定してください。<BR>
      <BR>
      また、hsidに負の値を渡し、partnoにビルボードのid を渡すと、<BR>
      ビルボードのInvisibleFlag を取得することが出来ます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するID<BR>
      　　ビルボードのInvisibleFlagを取得する場合は、負の値　　を渡してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツの番号。<BR>
      　　E3DGetPartNoByNameで取得した番号、<BR>
      　　または、ビルボードのＩＤ。<BR>
      <BR>
      3. [OUT] int*　：　flagptr<BR>
      　　指定したパーツのInvisibleFlag が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetInvisibleFlag</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">hsidで識別されるモデルのpartnoのパーツのInvisibleFlag(見えないフラグ)をセットします。<BR>
      <BR>
      partno にはE3DGetPartNoByNameで取得した番号を指定してください。<BR>
      <BR>
      また、hsidに負の値を渡しpartnoにビルボードのid を渡すと<BR>
      ビルボードのInvisibleFlag をセットすることが出来ます。<BR>
      <BR>
      InvisibleFlag == 0 のとき可視状態（デフォルト）で、<BR>
      InvisibleFlag == 1 のとき表示されずあたり判定だけとなります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するID<BR>
      　　ビルボードのInvisibleFlagを取得する場合は、<BR>
      　　負の値を渡してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツの番号。<BR>
      　　E3DGetPartNoByNameで取得した番号、<BR>
      　　または、ビルボードのＩＤ。<BR>
      <BR>
      3. [IN] int　：　flag<BR>
      　　指定したパーツのInvisibleFlag をセットします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMovableArea</TD>
      <TD class="hpb-cnt-tb-cell2">壁</TD>
      <TD class="hpb-cnt-tb-cell2">移動可能領域を、ＢＭＰファイルから、自動生成します。<BR>
      （色の付いた部分と、付いていない部分の<BR>
      境界部分に、地面に垂直な、非表示の壁ポリゴンを生成します。）<BR>
      <BR>
      E3DChkConfWall 命令と併用すれば、<BR>
      ＢＭＰで、濃い色を付けた部分のみ、移動できるようになります。<BR>
      <BR>
      <BR>
      メタセコイアデータで、<BR>
      壁データを作りたい場合は、<BR>
      メタセコイアのプラグイン、MakeWallをご使用ください。<BR>
      （おちゃっこＬＡＢのトップページにリンクがあります。）<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename1<BR>
      　　壁の座標情報の元となる、ＢＭＰファイル名<BR>
      <BR>
      2. [IN] float　：　maxx<BR>
      　　壁のＸ座標の最大値<BR>
      <BR>
      3. [IN] float　：　maxz<BR>
      　　壁のＺ座標の最大値<BR>
      <BR>
      4. [IN] int　：　divx<BR>
      　　X方向の分割数<BR>
      <BR>
      5. [IN] int　：　divz<BR>
      　　Z方向の分割数<BR>
      <BR>
      6. [IN] float　：　wallheight<BR>
      　　作成する壁の高さ<BR>
      <BR>
      7. [OUT] int*　：　hsidptr<BR>
      　　作成した壁データを識別するＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConfWall</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">E3DSetMovableArea またはE3DLoadMQOFileAsMovableAreaで作成した壁データとキャラクターのあたり判定を行います。<BR>
      <BR>
      キャラクターの現在の座標と、<B><U>E3DSetBeforePos</U></B>で保存された古い座標とを結ぶ線分と、<BR>
      壁の各ポリゴンとのあたり判定をします。<BR>
      <BR>
      壁に沿って位置を移動するために<BR>
      使用します。<BR>
      <BR>
      壁の外側から内側へは移動できますが、内側から外側へは移動できないようにします。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　charahsid<BR>
      　　移動する形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　groundhsid<BR>
      　　E3DSetMovableArea、<BR>
      　　または、E3DLoadMQOFileAsMovableAreaで<BR>
      　　作成した形状データを<BR>
      　　識別するid<BR>
      <BR>
      3. [IN] float　：　dist<BR>
      　　跳ね返る距離。<BR>
      　　distに大きな値を入れると、<BR>
      　　ぶつかった際に大きく跳ね返るようになります。<BR>
      <BR>
      4. [OUT] int*　：　resultptr<BR>
      　　あたり判定の結果が代入されます。<BR>
      　　壁とぶつかった場合は１が、<BR>
      　　ぶつからなかった場合は０が代入されます。<BR>
      <BR>
      5. [OUT] D3DXVECTOR3*　：　adjustptr<BR>
      　　result != 0 のときに<BR>
      　　修正後の座標が代入されます。<BR>
      <BR>
      6. [OUT] D3DXVECTOR3*　：　nptr<BR>
      　　result != 0 のときに、<BR>
      　　ぶつかった面の法線ベクトルの値が<BR>
      　　代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConfWallVec</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">E3DSetMovableArea,またはE3DLoadMQOFileAsMovableAreaで作成した壁データとキャラクターのあたり判定を行います。<BR>
      <BR>
      befposで指定した座標と<BR>
      newposで指定した座標を結ぶ線分と<BR>
      壁の各ポリゴンとのあたり判定をします。<BR>
      <BR>
      壁に沿って位置を移動するために<BR>
      使用します。<BR>
      <BR>
      壁の外側から内側へは移動できますが、内側から外側へは移動できないようにします。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　befpos<BR>
      　　線分の始点を（befpos.x, befpos.y, befpos.z）で<BR>
      　　指定します。<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　newpos<BR>
      　　線分の終点を（newpos.x, newpos.y, newpos.z）で<BR>
      　　指定します。<BR>
      <BR>
      3. [IN] int　：　groundhsid<BR>
      　　E3DSetMovableArea、<BR>
      　　または、E3DLoadMQOFileAsMovableAreaで<BR>
      　　作成した形状データを<BR>
      　　識別するid<BR>
      <BR>
      4. [IN] float　：　dist<BR>
      　　壁からの距離の最小値。<BR>
      　　distに大きな値を入れると、<BR>
      　　ぶつかった際に大きく跳ね返るようになります。<BR>
      <BR>
      5. [OUT] int*　：　resultptr<BR>
      　　あたり判定の結果が代入されます。<BR>
      　　壁とぶつかった場合は１が、<BR>
      　　ぶつからなかった場合は０が代入されます。<BR>
      <BR>
      6. [OUT] D3DXVECTOR3*　：　adjustptr<BR>
      　　result != 0 のときに、<BR>
      　　修正後の座標が代入されます。<BR>
      <BR>
      7. [OUT] D3DXVECTOR3*　：　nptr<BR>
      　　result != 0 のときに、<BR>
      　　ぶつかった面の法線ベクトルの値が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DVec3Normalize</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">指定したベクトルを、正規化た値を取得します。<BR>
      <BR>
      つまり、指定したベクトルの向きを持つ、<BR>
      大きさ１のベクトルが、取得できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　vec<BR>
      　　ベクトルを、(vec.x, vec.y, vec.z)で指定します。<BR>
      <BR>
      2. [OUT] D3DXVECTOR3*　：　newvecptr<BR>
      　　向きが(vec.x, vec.y, vec.z)で<BR>
      　　大きさが1なベクトルを代入します。<BR>
      　</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DVec2CCW</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">vec2 がvec1 に対して、反時計回りの時、<BR>
      resultに、１を代入し、<BR>
      時計回りの時、<BR>
      resultに、-1を代入する。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR2　：　vec1<BR>
      　　vec1を指定する。<BR>
      <BR>
      2. [IN] D3DXVECTOR2　：　vec2<BR>
      　　vec2を指定する。<BR>
      <BR>
      3. [OUT] int*　：　result<BR>
      　　vec2 がvec1 に対して、反時計回りの時<BR>
      　　resultに、１を代入し、<BR>
      　　時計回りの時resultに-1を代入する。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DVec3RotateY</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">ベクトルbefvecをＹ軸に関してdegy 度だけ回転したベクトルnewvec を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　befvec<BR>
      　　回転したいベクトルを、<BR>
      　　(befvec.x, befvec.y, befvec.z)で指定します。<BR>
      <BR>
      2. [IN] float　：　degy<BR>
      　　回転角度を指定します。<BR>
      　　degy の角度だけ回転します。<BR>
      <BR>
      3. [OUT] D3DXVECTOR3*　：　newvecptr<BR>
      　　回転後のベクトルが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadMQOFileAsMovableArea</TD>
      <TD class="hpb-cnt-tb-cell2">壁</TD>
      <TD class="hpb-cnt-tb-cell2">メタセコイアの、ＭＱＯファイルで作成した壁のデータを、移動可能領域情報として読み込みます。<BR>
      <BR>
      メタセコイアでデータを作る場合には次の２点に気を付けてください。<BR>
      <BR>
      １．壁データは<U>常に移動可能領域の内側を向く</U>ように面の向きを設定してください。<U>両面ポリゴンは不可</U>です。<BR>
      <BR>
      ２．壁データは少しの隙間もないように作成してください。<BR>
      <BR>
      <BR>
      自動的に壁データを作りたい場合は、<BR>
      メタセコイアのプラグインMakeWallをご使用ください。<BR>
      （おちゃっこＬＡＢのトップページにリンクがあります。）<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　読み込む、mqo ファイル名。<BR>
      <BR>
      2. [IN] float　：　mult<BR>
      　　形状データの座標に掛ける係数の数値。<BR>
      　　座標値　＊　mult で計算されます。<BR>
      　　等倍は１．０<BR>
      <BR>
      3. [OUT] int*　：　hsidptr<BR>
      　　作成した壁データを識別するhsidが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadSound</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">音のデータを読み込み音を識別する番号soundidを取得します。<BR>
      <BR>
      oggとwavを読み込めます。<BR>
      oggはステレオのみ。<BR>
      <BR>
      ３Dサウンドにも対応しています。<BR>
      ３Dサウンドはモノラルのみです。<BR>
      <BR>
      MIDIは読み込めません。<BR>
      <BR>
      <BR>
      ver5.3.0.3でoggdatanum引数追加。<BR>
      <BR>
      ver5.3.1.6でoggdatanum引数を削除（自動設定に変更）<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　読み込む、サウンド ファイル名。<BR>
      <BR>
      2. [IN] int　：　use3dflag<BR>
      　　３Ｄサウンドとして読み込む場合は１を指定してください。<BR>
      　　デフォルト値は０です。<BR>
      <BR>
      3. [IN] int　：　reverbflag<BR>
      　　リバーブを有効にしたいときは１を<BR>
      　　したくないときは０を指定します。<BR>
      <BR>
      4. [IN] int　：　bufnum<BR>
      　　同じＩＤのサウンドを同時にいくつ重ねて再生できるかを指定します。<BR>
      <BR>
      5. [OUT] int*　：　soundidptr<BR>
      　　作成した音データを識別する番号が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.3.0.0で仕様変更<BR>
      ver5.3.0.3で拡張<BR>
      ver5.3.1.6で修正<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DPlaySound</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">E3DLoadSoundで読み込んだ音データを再生します。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　再生したい音を識別する番号を、指定します。<BR>
      <BR>
      2. [IN] int　：　startsample<BR>
      　　再生開始位置をサンプル（周波数）単位で指定します。<BR>
      <BR>
      3. [IN] int　：　openo<BR>
      　　将来のバッチ処理用の引数です。<BR>
      　　現在は０を指定しておいてください。<BR>
      <BR>
      4. [IN] int　：　numloops<BR>
      　　繰り返し回数を指定します。<BR>
      　　無限ループは２５５を指定します。<BR>
      　　２５５以下でもあまり大きい値を指定するとハングすることがあります（２５５はハングしません）。<BR>
      　</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.3.0.0で仕様変更<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DStopSound</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">音の再生を停止します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　停止したい音を識別する番号を指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetSoundVolume</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">音の音量を設定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　volume<BR>
      　　音量を指定します。<BR>
      ソース音量との比率を指定します。<BR>
      <BR>
      2. [IN] int　：　soundid<BR>
      　　設定したい音を識別する番号を指定します。<BR>
      　　-1を指定すると、全ての音の音量を設定できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.3.0.0で仕様変更<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroySound</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">読み込んだ音データを破棄します。<BR>
      破棄した音はその後操作することは出来ません。<BR>
      ただ、再生を終了させる場合は<BR>E3DStopSound関数を使用してくださ</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　破棄したい音を識別する番号<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSoundVolume</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">現在の音量を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　音を識別する番号<BR>
      <BR>
      2. [OUT] float*　：　volptr<BR>
      　　音量(ソース音量との比率)が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.3.0.0で仕様変更<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSet3DSoundListenerMovement</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">リスナーの位置と向きを設定します。<BR>
      <BR>
      hsidにモデルデータの番号を渡した場合には、<BR>
      そのモデルデータの位置と向きが、<BR>
      リスナーの位置と向きとして設定されます。<BR>
      <BR>
      hsidに-1を渡した場合には、<BR>
      視点の位置と向きが<BR>
      リスナーの位置と向きとして設定されます。<BR>
      <BR>
      一回呼び出せばずっとhsidの更新情報を<BR>
      リスナーに反映させるわけでは<B>ありません</B>。<BR>
      <BR>
      情報の更新が必要になるたびに、<BR>
      呼び出してください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別する番号<BR>
      　　-1のときは視点をリスナーとします。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSet3DSoundMovement</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">
      ３Dサウンドの位置と速度を設定します。<BR>
      <BR>
      <U><B>E3DLoadSoundのuse3dflagに１を指定して<BR>
      読み込んだサウンドのみに対し有効です。<BR>
      </B><BR>
      </U></TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　３Ｄサウンドを識別する番号<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　pos<BR>
      　　３Ｄサウンドの位置を指定します。<BR>
      <BR>
      3. [IN] D3DXVECTOR3　：　v<BR>
      　　３Ｄサウンドの速度を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateNaviLine</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">ナビラインを作成します。<BR>
      <BR>
      ナビラインとは、複数のナビポイントからなる、双方向リンクリストのことです。<BR>
      <BR>
      ナビポイントとは、キャラクターの自動走行時に、位置を決める基準となるポイントのことです。<BR>
      <BR>
      この関数が成功すると、<BR>
      ナビラインを識別するためのＩＤ、nlidが得られます。<BR>
      <BR>
      失敗するとnlidに負の値が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　nlidptr<BR>
      　　作成したナビラインを識別するためのＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyNaviLine</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">ナビラインを削除します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　nlid<BR>
      　　削除するラインを識別するＩＤ<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DAddNaviPoint</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">ナビラインにナビポイントを追加します。<BR>
      <BR>
      成功すると新しいナビポイントを識別するためのＩＤ、npid が得られます。<BR>
      <BR>
      befnpidで指定したポイントの次の位置に<BR>
      追加できる他、<BR>
      先頭位置や最後の位置にも追加することができます。<BR>
      <BR>
      <BR>
      ナビポイントの編集には、<BR>
      GViewer.exeを使うと便利です。<BR>
      （おちゃっこＬＡＢでＤＬ可能です。）<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　nlid<BR>
      　　ラインを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　befnpid<BR>
      　　befnpidで指定したポイントの次の位置に、<BR>
      　　新しいポイントを追加します。<BR>
      <BR>
      　　befnpidに-1を指定すると<BR>
      　　ナビラインの最後に追加され、<BR>
      　　befnpidに-2を指定すると<BR>
      　　ナビラインの先頭に追加されます。<BR>
      <BR>
      3. [OUT] int*　：　npidptr<BR>
      　　新しく追加したナビポイントのＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRemoveNaviPoint</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">ナビラインからナビポイントを削除します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　nlid<BR>
      　　ラインを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　npid<BR>
      　　削除したいナビポイントのID<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetNaviPointPos</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">ナビポイントの座標を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　nlid<BR>
      　　ラインを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　npid<BR>
      　　ナビポイントを識別するID<BR>
      <BR>
      3. [OUT] D3DXVECTOR3*　：　posptr<BR>
      　　ナビポイントの座標が代入されます。<BR>
      　</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetNaviPointPos</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">ナビポイントの座標をセットします。<BR>
      この座標をもとに、<BR>
      キャラクターが移動することになります。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　nlid<BR>
      　　ラインを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　npid<BR>
      　　ナビポイントを識別するID<BR>
      <BR>
      3. [IN] D3DXVECTOR3　：　pos<BR>
      　　ナビポイントの座標を<BR>
      　　（pos.x, pos.y, pos.z）に設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetNaviPointOwnerID</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">ナビポイントのOwnerIDを取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　nlid<BR>
      　　ラインを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　npid<BR>
      　　ナビポイントを識別するID<BR>
      <BR>
      3. [OUT] int*　：　OwnerIDptr<BR>
      　　ナビポイントのOwnerIDが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetNaviPointOwnerID</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">ナビポイントのOwnerIDをセットします。<BR>
      <BR>
      ナビポイントに<BR>
      排他的な所有権を設定したいときなどに、<BR>
      自由に使用してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　nlid<BR>
      　　ラインを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　npid<BR>
      　　ナビポイントを識別するID<BR>
      <BR>
      3. [IN] int　：　OwnerID<BR>
      　　ナビポイントのOwnerIDに設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetNextNaviPoint</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">npidで指定したナビポイントの一つ後のナビポイントのＩＤを取得します。<BR>
      <BR>
      ナビラインはナビポイントを双方向リストで格納しています。<BR>
      <BR>
      <BR>
      一つ後のナビポイントが存在しない場合は、nextid には負の値が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　nlid<BR>
      　　ラインを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　npid<BR>
      　　ナビポイントを識別するID<BR>
      <BR>
      3. [OUT] int*　：　nextidptr<BR>
      　　一つ後のナビポイントのＩＤが代入されます。<BR>
      <BR>
      　　npid に-1が指定されている場合は、<BR>
      　　*nextidptrには、先頭のナビポイントのIDが代入されます<BR>
      　　</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetPrevNaviPoint</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">npidで指定したナビポイントの一つ前のナビポイントのＩＤを取得します。<BR>
      <BR>
      <BR>
      ナビラインはナビポイントを双方向リストで格納しています。<BR>
      <BR>
      <BR>
      一つ前のナビポイントが存在しない場合は、previd には負の値が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　nlid<BR>
      　　ラインを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　npid<BR>
      　　ナビポイントを識別するID<BR>
      <BR>
      3. [OUT] int*　：　previdptr<BR>
      　　一つ後のナビポイントのＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetNearestNaviPoint</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">指定した座標に一番近いナビポイントのＩＤを取得します。<BR>
      <BR>
      一番近いナビポイントの前後のポイントの<BR>
      ＩＤも取得できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　nlid<BR>
      　　ラインを識別するＩＤ<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　pos<BR>
      　　（pos.x, pos.y, pos.z）に一番近いナビポイントを探します。<BR>
      <BR>
      3. [OUT] int*　：　nearidptr<BR>
      　　一番近いナビポイントのＩＤが代入されます。<BR>
      <BR>
      4. [OUT] int*　：　previdptr<BR>
      　　一番近いナビポイントの前のポイントのＩＤが代入されます。<BR>
      <BR>
      5. [OUT] int*　：　nextidptr<BR>
      　　一番近いナビポイントの次のポイントのＩＤが代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DFillUpNaviLine</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">ナビポイントとナビポイントの間を、指定した分割数で補間します。<BR>
      <BR>
      Catmull-Romの公式で補間します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　nlid<BR>
      　　ラインを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　div<BR>
      　　何分割して補間するかを指定します。<BR>
      <BR>
      3. [IN] int　：　flag<BR>
      　　flagに１を指定すると、<BR>
      　　チェインの順番にナビポイントのＩＤをふり直します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetNaviLineOnGround</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン中の全てのナビポイントの座標を、地面の高さに設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　nlid<BR>
      　　ラインを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　grounhdis<BR>
      　　地面を識別するhsid<BR>
      <BR>
      3. [IN] float　：　mapmaxy<BR>
      　　地面データのＹ座標の最大値を指定します。<BR>
      <BR>
      4. [IN] float　：　mapminy<BR>
      　　地面データのＹ座標の最小値を指定します。<BR>
      　　実際の最小値より、少し小さな値を入れてください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DControlByNaviLine</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">ナビラインのデータを元に、キャラクターの位置と向きを自動的に設定するための関数です。<BR>
      <BR>
      引数のモードなどのパラメータを<BR>
      色々変化させることで、<BR>
      一つのナビラインから複数の（数え切れないくらいの）走行パターンを得ることが可能です。<BR>
      <BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　nlid<BR>
      　　ラインを識別するＩＤ<BR>
      <BR>
      3. [IN] int　：　ctrlmode<BR>
      　　ビットの和で、モードを指定します。<BR>
      <BR>
      　　ビット１が立っていた場合には、<BR>
      　　　位置を優先した制御が行われます。<BR>
      　　　引数maxdist, dirstep は無視されます。<BR>
      　　　出来るだけナビポイントの近くを通るようになります。<BR>
      <BR>
      　　ビット１が立っていない場合には、<BR>
      　　　向きを優先した制御が行われます。<BR>
      　　　dirstepで指定した角度より大きな角度では移動できなくなります。<BR>
      　　　ただし、そのままだとキャラクターが<BR>
      　　　ナビラインから遠くに離れすぎてしまうので引数maxdistでナビラインからどのくらい離れても良いかを指定します。<BR>
      　　　maxdistよりも遠くに離れた場合には、<BR>
      　　　dirstepで指定したよりも大きな角度でナビラインに近づくように修正されます。<BR>
      　　　<BR>
      　　　なので、dirstepに小さな値を指定するとジグザグにナビラインをたどるようになります。<BR>
      <BR>
      　　ビット４が立っていた場合には、<BR>
      　　　向きの設定はＸＺ平面のみで行われます。<BR>
      <BR>
      　　例えば、ctrlmode に５を指定した場合は、<BR>
      　　位置を優先した制御で、ＸＺ平面での向き設定をする<BR>
      　　ということになります。<BR>
      <BR>
      4. [IN] int　：　roundflag<BR>
      　　ナビラインの最後のナビポイントに移動した後、<BR>
      　　ナビラインの最初のナビポイントの位置を目指すかどうかを示します。<BR>
      <BR>
      　　１を指定すると円形のナビラインの場合は<BR>
      　　ずっとぐるぐる回ることになります。<BR>
      <BR>
      5. [IN] int　：　reverseflag<BR>
      　　１を指定すると、<BR>
      　　ナビラインのポイントを逆順にたどるようになります。<BR>
      <BR>
      6. [IN] float　：　maxdist<BR>
      　　ナビラインから、どのくらいまで離れても良いかを指定します。<BR>
      　　ctrlmodeのビット１が立っていない場合のみ有効です。<BR>
      <BR>
      7. [IN] float　：　posstep<BR>
      　　キャラクターを一度にどれくらいの距離を移動させるかを<BR>
      　　指定します。<BR>
      　　ただし、ナビポイント付近では、<BR>
      　　posstepより小さな距離しか移動させないことがあります。<BR>
      <BR>
      8. [IN] float　：　dirstep<BR>
      　　一度の移動で、最大何度まで回転できるかを<BR>
      　　指定します。<BR>
      　　回転角度の値を渡してください。<BR>
      　　<BR>
      9. [OUT] D3DXVECTOR3*　：　newposptr<BR>
      　　移動後の座標が代入されます。<BR>
      <BR>
      10. [OUT] D3DXQUATERNION*　：　newqptr<BR>
      　　移動後の姿勢を表すクォータニオンが代入されます。<BR>
      <BR>
      11. [IN] [OUT] int*　：　targetpointidptr<BR>
      　　現在目指しているナビポイントのＩＤを入れます。<BR>
      　　移動後は次に目指すべきナビポイントのＩＤが代入されます。<BR>
      <BR>
      　　ですので、一番最初の呼び出し時のみ自分でtargetpoinidを指定すればあとは同じ変数を渡すだけで、<BR>
      　　自動的に目指すべきポイントのＩＤが代入されていくことになります。<BR>
      <BR>
      　　targetpointidに存在しないナビポイントのＩＤを入れた場合は、<BR>
      　　（例えば-1など）<BR>
      　　自動的に目指すべきナビポイントを決定します。<BR>
      　　ですが、この場合、<BR>
      　　向きを重視したモードのときに<BR>
      　　動きがぎこちなくなることがあるので、<BR>
      　　なるべく-1などは使わない方が良いです。<BR>
      　　<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetDirQ</TD>
      <TD class="hpb-cnt-tb-cell2">モデル向き</TD>
      <TD class="hpb-cnt-tb-cell2">姿勢をクォータニオンで指定して設定します。<BR>
      <BR>
      E3DControlByNaviLineや、<BR>E3DGetDirQ<BR>
      で得た姿勢データを<BR>
      設定するときに使用してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] D3DXQUATERNION　：　q<BR>
      　　姿勢を表すクォータニオンを<BR>
      　　指定してください。<BR>
      　　</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetDirQ</TD>
      <TD class="hpb-cnt-tb-cell2">モデル向き</TD>
      <TD class="hpb-cnt-tb-cell2">姿勢をクォータニオンの形式で取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [OUT] D3DXQUATERNION*　：　qptr<BR>
      　　姿勢を表すクォータニオンが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetWallOnGround</TD>
      <TD class="hpb-cnt-tb-cell2">壁</TD>
      <TD class="hpb-cnt-tb-cell2">壁データを地面の高さに配置します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　whsid<BR>
      　　壁の形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　ghsid<BR>
      　　地面の形状データを識別するＩＤ<BR>
      <BR>
      3. [IN] float　：　mapmaxy<BR>
      　 地面データの最大の高さ<BR>
      <BR>
      4. [IN] float　：　mapminy<BR>
      　　地面データの最低の高さ<BR>
      <BR>
      5. [IN] float　：　wheight<BR>
      　　壁の高さ。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateNaviPointClearFlag</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">キャラクターがnlidで識別されるナビライン上の点を、どれだけ進んだかということを格納するためのデータを作成します。<BR>
      <BR>
      hsidで識別されるモデルのデータとして<BR>
      作成します。<BR>
      <BR>
      <BR>
      このデータはレースの順位を決定するときなどに役に立ちます。<BR>
      <BR>
      <BR>
      この命令は、<BR>
      E3DInitNaviPointClearFlag,<BR>
      E3DSetNaviPointClearFlag<BR>
      E3DGetOrder<BR>
      の命令を呼び出す前に呼び出されていないといけません。<BR>
      <BR>
      <U>複数回続けて呼び出してはいけません。</U><BR>
      作り直したい場合は、必ず、<BR>
      E3DDestroyNaviPointClearFlag<BR>
      を呼び出してから<BR>
      E3DCreateNaviPointClearFlag<BR>
      を呼び出してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　nlid<BR>
      　　ナビラインを識別するＩＤ<BR>
      <BR>
      3. [IN] int　：　roundnum<BR>
      　　ナビライン上を最大何周するのかを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyNaviPointClearFlag</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateNaviPointClearFlagで作成したデータを破棄します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DInitNaviPointClearFlag</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateNaviPointClearFlagで作成したデータを初期化します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetNaviPointClearFlag</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateNaviPointClearFlagで作成したデータに、現在どれだけのナビポイントを通過したかをセットします。<BR>
      <BR>
      キャラクターとナビポイントとの距離を元に、<BR>
      データをセットします。<BR>
      <BR>
      この関数を使う場合は、<BR>
      毎フレームこの関数を呼び出す必要があります。<BR>
      <BR>
      この関数でセットしたデータを元に、<BR>
      E3DGetOrderが順位を決定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　pos<BR>
      　　キャラクターの位置を指定します。<BR>
      <BR>
      3. [IN] float　：　maxdist<BR>
      　　ナビポイントとの距離がmaxdistより近かった場合、<BR>
      　　そのポイントをクリアー（通過）したと見なします。<BR>
      <BR>
      4. [OUT] int*　：　npidptr<BR>
      　　現在クリアーしているポイントの内、<BR>
      　　一番前方のポイントのＩＤが代入されます。<BR>
      <BR>
      5. [OUT] int*　：　roundptr<BR>
      　　キャラクターが何週目かが代入されます。<BR>
      <BR>
      6. [OUT] int*　：　distptr<BR>
      　　npidptrに代入されたＩＤのポイントから<BR>
      　　どれだけ距離が離れているかが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetOrder</TD>
      <TD class="hpb-cnt-tb-cell2">ナビライン</TD>
      <TD class="hpb-cnt-tb-cell2">E3DSetNaviPointClearFlagでセットされたデータを元に、順位情報を取得するための関数です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int*　：　hsidptr<BR>
      　　順位を調べたい形状データを識別するＩＤの配列を<BR>
      　　指定します。<BR>
      　　arraylengの長さの配列でなくてはなりません。<BR>
      <BR>
      　　例えば、<BR>
      　　hsidptr = (int*)malloc( sizeof(int) * arrayleng );<BR>
      　　という命令で、作成したデータを渡してください。<BR>
      <BR>
      2. [IN] int　：　arrayleng<BR>
      　　配列の長さを指定します。<BR>
      　　hsidptr, orderptr, clearnoptrは、<BR>
      　　全て、arraylengの長さの配列でなくてはなりません。<BR>
      <BR>
      3. [OUT] int*　：　orderptr<BR>
      　　順位順に、hsidが代入されます。<BR>
      　　*orderptr には、1位のhsidの番号が、<BR>
      　　*(orderptr + 1) には、2位のhsidの番号が代入されます。<BR>
      <BR>
      <BR>
      4. [OUT] int*　：　clearnoptr<BR>
      　　順位順に、クリアーしたポイントの数が代入されます。<BR>
      　　*clearnoptr には、<BR>
      　　1位のモデルがクリアーしたポイント数が、<BR>
      　　*(clearnoptr + 1) には、<BR>
      　　２位のモデルがクリアーしたポイント数が<BR>
      　　代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyAllBillboard</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボード</TD>
      <TD class="hpb-cnt-tb-cell2">全てのビルボードを破棄します。</TD>
      <TD class="hpb-cnt-tb-cell2">なし</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetValidFlag</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">RokDeBone2の　”このオブジェクトを無効にする”機能を、プログラムで行えるようにしました。<BR>
      <BR>
      無効にしたパーツは、描画やあたり判定の際に無視されるようになります。<BR>
      <BR>
      ジョイントに対してE3DSetValidFlagをした場合は、<BR>
      E3DJointRemakeを呼び出してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      　　-1を指定すると、ビルボードのフラグを設定できます。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　設定したいパーツの番号を指定します。<BR>
      <BR>
      　　E3DGetPartNoByNameで取得した番号を渡してください。<BR>
      <BR>
      　　hsidに-1を指定した場合は、<BR>
      　　E3DCreateBillboardで取得した、<BR>
      　　ビルボードidを渡してください。<BR>
      <BR>
      　　partnoに-1を渡すと、<BR>
      　　全てのパーツの有効無効をセットできます。<BR>
      <BR>
      3. [IN] int　：　flag<BR>
      　　flagに０を指定すると指定パーツが無効になります。<BR>
      　　flagに１を指定すると有効になります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBillboardDiffuse</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボードのdiffuse色をセットする関数です。<BR>
      <BR>
      指定した色を、<BR>
      そのまま設定、乗算して設定、加算して設定、<BR>
      減算して設定の、4種類出来ます。<BR>
      <BR>
      <U>その時点で、表示されている色に対して、<BR>
      乗算、加算、減算します。</U><BR>
      <BR>
      diffuseだけかえても、Specular, Ambientを変えないと意図した色にはならないと思いますので注意してください。<BR>
      （E3DSetBillboardSpecular, E3DSetBillboardAmbient, E3DSetBillboardEmissive,
      E3DSetBillboardSpecularPowerもご覧ください。）<BR>
      <BR>
      頂点単位で色の設定が出来ます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bbid<BR>
      　　ビルボードを識別するＩＤ。<BR>
      　　-1を指定すると全てのビルボードの色を設定できます。<BR>
      <BR>
      2. [IN] E3DCOLOR4UC　：　col<BR>
      　　指定したい色を（col.r, col.g, col.b）で指定します。<BR>
      <BR>
      　　setflagに乗算を指定した場合は、<BR>
      　　各成分に、r/255, g/255, b/255を乗算します。<BR>
      <BR>
      　　col.aは無視されます。<BR>
      <BR>
      3. [IN] int　：　setflag<BR>
      　　setflagが０のときは、<BR>
      　　パーツの色をcolにセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　パーツの色に（col.r/255, col.g/255, col.b/255）を乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　パーツの色にcolを足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　パーツの色からcolを減算します。<BR>
      <BR>
      <BR>
      4. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色をセットします。<BR>
      　　-1をセットした場合には<BR>
      　　bbidで指定したビルボード全体の色の設定をします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBillboardSpecular</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボードのspecular色をセットする関数です。<BR>
      <BR>
      指定した色を<BR>
      そのまま設定、乗算して設定、加算して設定、<BR>
      減算して設定の、4種類出来ます。<BR>
      <BR>
      <U>その時点で表示されている色に対して<BR>
      乗算、加算、減算します。</U><BR>
      <BR>
      <BR>
      頂点単位で色の設定が出来ます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bbid<BR>
      　　ビルボードを識別するＩＤ<BR>
      　　-1を指定すると全てのビルボードの色を設定できます。<BR>
      <BR>
      2. [IN] E3DCOLOR4UC　：　col<BR>
      　　指定したい色を（col.r, col.g, col.b）で指定します。<BR>
      <BR>
      　　setflagに乗算を指定した場合は、<BR>
      　　各成分に、r/255, g/255, b/255を乗算します。<BR>
      <BR>
      　　col.aは無視されます。<BR>
      <BR>
      3. [IN] int　：　setflag<BR>
      　　setflagが０のときは、<BR>
      　　パーツの色をcolにセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　パーツの色に（col.r/255, col.g/255, col.b/255）を乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　パーツの色にcolを足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　パーツの色からcolを減算します。<BR>
      <BR>
      <BR>
      4. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色をセットします。<BR>
      　　-1をセットした場合には<BR>
      　　bbidで指定したビルボード全体の色の設定をします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBillboardAmbient</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボードのambient色をセットする関数です。<BR>
      <BR>
      指定した色を<BR>
      そのまま設定、乗算して設定、加算して設定、<BR>
      減算して設定の4種類出来ます。<BR>
      <BR>
      <U>その時点で表示されている色に対して、<BR>
      乗算、加算、減算します。</U><BR>
      <BR>
      <BR>
      頂点単位で色の設定が出来ます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bbid<BR>
      　　ビルボードを識別するＩＤ<BR>
      　　-1を指定すると全てのビルボードの色を設定できます。<BR>
      <BR>
      2. [IN] E3DCOLOR4UC　：　col<BR>
      　　指定したい色を（col.r, col.g, col.b）で指定します。<BR>
      <BR>
      　　setflagに乗算を指定した場合は、<BR>
      　　各成分に、r/255, g/255, b/255を乗算します。<BR>
      <BR>
      　　col.aは無視されます。<BR>
      <BR>
      3. [IN] int　：　setflag<BR>
      　　setflagが０のときは、<BR>
      　　パーツの色をcolにセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　パーツの色に（col.r/255, col.g/255, col.b/255）を乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　パーツの色にcolを足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　パーツの色からcolを減算します。<BR>
      <BR>
      <BR>
      4. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色をセットします。<BR>
      　　-1をセットした場合には<BR>
      　　bbidで指定したビルボード全体の色の設定をします。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBlendingMode</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボードとスプライトの半透明モードを指定します。<BR>
      <BR>
      加算モードと、頂点アルファ値による半透明モードと<BR>
      頂点アルファを考慮した加算モードの３つから選べます。<BR>
      <BR>
      ver5.0.2.2でモードが４つ増えました。<BR>
      <BR>
      <B>ver5.1.0.1でオーバーレイ風、覆い焼き風モードが増えました。</B><BR>
      <BR>
      sigモデルデータの半透明モードの設定は<BR>
      E3DSetMaterialBlendingModeをお使いください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      　　-1を指定するとビルボードのモードを設定できます。<BR>
      <BR>
      　　-2を指定するとスプライトの設定が出来ます。<BR>
      <BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　設定したいパーツの番号を指定します。<BR>
      <BR>
      　　E3DGetPartNoByNameで取得した番号を渡してください。<BR>
      <BR>
      　　hsidに-1を指定した場合は、<BR>
      　　E3DCreateBillboardで取得した<BR>
      　　ビルボードidを渡してください。<BR>
      <BR>
      　　hsidに-2を指定した場合は、<BR>
      　　E3DCreateSpriteで取得した<BR>
      　　スプライトのidを渡してください。<BR>
      <BR>
      　　partnoに-1を渡すと、<BR>
      　　全てのパーツにモードをセットできます。<BR>
      <BR>
      3. [IN] int　：　blendmode<BR>
      　　０を指定すると、<BR>
      　　頂点アルファ値による半透明モードになります。<BR>
      <BR>
      　　１を指定すると<BR>
      　　アッドモードになります。<BR>
      <BR>
      　　２を指定すると<BR>
      　　頂点アルファを考慮したアッドモードになります。<BR>
      <BR>
      　　１０３を指定すると乗算モード。<BR>
      　　１０４を指定すると減算モード。<BR>
      　　１０５を指定するとスクリーンモード。<BR>
      　　１０６を指定するとネガ反転モードになります。<BR>
      <BR>
      　　１０７を指定するとオーバーレイ風合成モード。<BR>
      　　１０８を指定すると覆い焼き風モードになります。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.0.2.2で拡張<BR>
      ver5.1.0.1で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetRenderState</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">パーツごとにRenderStateを設定できます。<BR>
      <BR>
      描画の度に呼ぶ必要はありません。<BR>
      一度呼べば描画時に自動的に設定されます。<BR>
      <BR>
      <BR>
      上級者向けの関数です。<BR>
      詳しくは、DirectXのヘルプの<BR>
      SetRenderStateをご覧ください。<BR>
      <BR>
      D3DRS_ALPHABLENDENABLE<BR>
      は、E3DRenderのwithalpha引数を元に、<BR>
      自動的に呼び出すようにしているので、<BR>
      このタイプは指定しても反映されません。<BR>
      <BR>
      また、オリジナルの頂点計算を行っているため設定しても、効果のないものも多くあります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      　　-1を指定するとビルボードのステートを設定できます。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　設定したいパーツの番号を指定します。<BR>
      <BR>
      　　E3DGetPartNoByNameで取得した番号を渡してください。<BR>
      <BR>
      　　hsidに-1を指定した場合は、<BR>
      　　E3DCreateBillboardで取得した<BR>
      　　ビルボードidを渡してください。<BR>
      <BR>
      　　partnoに-1を渡すと<BR>
      　　全てのパーツにステートをセットできます。<BR>
      <BR>
      3. [IN] int　：　statetype<BR>
      　　設定するタイプを指定してください。<BR>
      <BR>
      4. [IN] int　：　value<BR>
      　　設定する値を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetScale</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">パーツ単位で形状を拡大縮小できます。<BR>
      <BR>
      特殊効果用を想定していますので、<BR>
      地面データには使用できません。<BR>
      <BR>
      <BR>
      <U>倍率は形状データ読み込み時の大きさに対する比率です。<BR>
      </U><BR>
      その時点で表示されている大きさに対する比率ではないので注意してください。<BR>
      <U><BR>
      </U></TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      　　-1を指定すると、ビルボードのスケールを設定できます。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　設定したいパーツの番号を指定します。<BR>
      <BR>
      　　E3DGetPartNoByNameで取得した番号を渡してください。<BR>
      <BR>
      　　hsidに-1を指定した場合は、<BR>
      　　E3DCreateBillboardで取得した<BR>
      　　ビルボードidを渡してください。<BR>
      <BR>
      　　partnoに-1を渡すと<BR>
      　　全てのパーツにスケールをセットできます。<BR>
      <BR>
      <BR>
      3. [IN] D3DXVECTOR3　：　scale<BR>
      　　Ｘ，Ｙ，Ｚのそれぞれの倍率を指定します。<BR>
      　　それぞれ、<BR>
      　　scale.x、<BR>
      　　scale.y、<BR>
      　　scale.z　倍されます。<BR>
      　　等倍は１．０。<BR>
      <BR>
      4. [IN] int　：　centerflag<BR>
      　　拡大縮小する際の中心を指定します。<BR>
      <BR>
      　　０を指定すると<BR>
      　　hsidで指定したモデル全体の中心を拡大の中心とします。<BR>
      <BR>
      　　１を指定すると<BR>
      　　それぞれのパーツの中心を拡大の中心とします。<BR>
      <BR>
      　　2を指定すると<BR>
      　　原点を拡大の中心とします。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetScreenPos3FVec</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">任意の３Ｄ座標からスクリーン（２Ｄ）座標を取得する関数。<BR>
      <BR>
      ラインの点の位置やボーンの位置に<BR>
      スプライトを表示したりできます。<BR>
<BR>
      <BR>
      ＃表示オブジェクトの頂点や<BR>
      パーツの中心の２Ｄ座標を取得する場合は、<BR>
      E3DGetScreenPos3Fをご利用ください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　pos3d<BR>
      　　3D座標を指定してください。<BR>
      <BR>
      3. [OUT] D3DXVECTOR3*　：　scposptr<BR>
      　　変換後の２Ｄ座標が（scposptr-&gt;x, scposptr-&gt;y）に代入されます。<BR>
      <BR>
      　　奥行き情報Zはscposptr-&gt;zに代入されます。<BR>
      <BR>
      　　２Ｄ座標がスクリーンの大きさの内側にあるかどうかは、<BR>
      　　ユーザーさんがチェックしてください。<BR>
      <BR>
      　　Zの値が０．０から１．０の間にないときは視野外を意味します。<BR>
      　　<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateQ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンを作成し、操作用のid を取得します。<BR>
      <BR>
      クォータニオンの各操作には、<BR>
      この関数で取得した qidを使用します。<BR>
      <BR>
      クォータニオンを知らない方は<BR>
      とりあえず、<BR>
      姿勢情報　（回転情報）を格納できる<BR>
      便利なもの<BR>
      とくらいに考えておいてください。<BR>
      <BR>
      <BR>
      モーションポイントや、モデルなどに<BR>
      クォータニオンをセットすることにより、<BR>
      任意の姿勢を持たせることが出来ます。<BR>
      <BR>
      作成方法は工夫してみましたが<BR>
      それほど高速ではありません。<BR>
      この関数はメインループの外で、<BR>
      あらかじめ呼んでおくことが、<BR>
      望ましいです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　qidptr<BR>
      　　新しいクォータニオンを作成し、<BR>
      　　そのクォータニオンを<BR>
      　　一意に識別する番号を　qid　に代入します。<BR>
      　　<BR>
      　　クォータニオン操作関数に<BR>
      　　この番号を渡して使用してください。<BR>
      　　<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyQ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンを削除します。<BR>
      <BR>
      この関数に渡したqidは使用できなくなります。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DInitQ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンを初期化します。<BR>
      <BR>
      姿勢情報が初期化されます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetQAxisAndDeg</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンを指定した軸に関して指定した角度だけ回転した姿勢をセットします。<BR>
      <BR>
      <U>既にqidにセットしてある姿勢情報は<BR>
      上書きされます（無視されます）。<BR>
      </U><BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　axis<BR>
      　　回転の軸のベクトルを、<BR>
      　　(axis.x, axis.y, axis.z)に指定します。　<BR>
      　　軸のベクトルは、内部で正規化されます。<BR>
      　<BR>
      3. [IN] float　：　deg<BR>
      　　指定した軸に関して<BR>
      　　deg度だけ回転した姿勢をセットします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetQAxisAndDeg</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンにセットされている姿勢情報を解析します。<BR>
      <BR>
      回転軸と回転角度が得られます。<BR>
      <BR>
      オイラー角を取得したい場合は<BR>
      E3DQtoEulerをご使用ください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      <BR>
      2. [OUT] D3DXVECTOR3*　：　axisptr<BR>
      　　回転の軸のベクトルを代入します。　<BR>
      <BR>
      3. [OUT] float*　：　degptr<BR>
      　　回転角度を代入します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRotateQX</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンの姿勢情報を、Ｘ軸に関して回転します。<BR>
      <BR>
      既にqidにセットしてある姿勢情報に対して<BR>
      さらにＸ軸回転することになります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      <BR>
      2. [IN] float　：　deg<BR>
      　　X軸に関してdeg度だけ回転します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRotateQY</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンの姿勢情報を、Ｙ軸に関して回転します。<BR>
      <BR>
      既にqidにセットしてある姿勢情報に対して<BR>
      さらにＹ軸回転することになります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      <BR>
      2. [IN] float　：　deg<BR>
      　　Ｙ軸に関してdeg度だけ回転します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRotateQZ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンの姿勢情報を、Ｚ軸に関して回転します。<BR>
      <BR>
      既にqidにセットしてある姿勢情報に対して<BR>
      さらにＺ軸回転することになります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      <BR>
      2. [IN] float　：　deg<BR>
      　　Ｚ軸に関してdeg度だけ回転します。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DMultQ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンの掛け算をします。<BR>
      <BR>
      例えば、<BR>
      qid1にＸ軸に関して３０度回転する姿勢が格納されていて、<BR>
      qid2にはＹ軸に関して２０度回転する姿勢が格納されていたとします。<BR>
      <BR>
      このとき、<BR>
      E3DMultQ( qid3, qid1, qid2 );<BR>
      という命令を呼んだとします。<BR>
      <BR>
      すると、<BR>
      qid3には、<BR>
      Ｘ軸に関して３０度回転した後に、<BR>
      さらにＹ軸に関して２０度回転した姿勢情報が<BR>
      格納されます。<BR>
      <BR>
      気を付けなければいけないのは、<BR>
      E3DMultQ( qid3, qid1, qid2 )<BR>
      と<BR>
      E3DMultQ( qid3, qid2, qid1 )<BR>
      では、qid3に格納される姿勢情報が異なる<BR>
      ということです。<BR>
      <BR>
      2番目の引数に指定した回転の後に、<BR>
      3番目の引数に指定した回転を適用するからです。<BR>
      <BR>
      回転の順番によって結果が異なるのは<BR>
      覚えておいてください。<BR>
      <BR>
      後から処理したい方を3番目の引数に<BR>
      いれればＯＫです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　resqid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      　　このidのクォータニオンに結果が代入されます。<BR>
      <BR>
      2. [IN] int　：　befqid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      <BR>
      3. [IN] int　：　aftqid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      <BR>
      　　befqidの回転の後にaftqidの回転をした結果を<BR>
      　　resqidで識別されるクォータニオンに代入します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DNormalizeQ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンを正規化します。<BR>
      <BR>
      様々なクォータニオンの操作を<BR>
      とてつもない回数繰り返していると、<BR>
      計算誤差などで<BR>
      クォータニオンの情報がおかしくなることがあります。<BR>
      <BR>
      例えば、E3DRotateQXをメインループで<BR>
      延々と繰り返す場合などに<BR>
      ひょっとしたら、不具合が出るかもしれません。<BR>
      <BR>
      そんなときは、<BR>
      ある程度の回数ごとに<BR>
      この関数を呼んでください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCopyQ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">srcqidで識別されるクォータニオンの情報を、dstqidで識別されるクォータニオンにコピーします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　dstqid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。&nbsp;<BR>
      <BR>
      2. [IN] int　：　srcqid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBoneNoByName</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">指定した名前を持つボーンを識別するidを取得します。<BR>
      <BR>
      該当するボーンが見つからなかった場合は、<BR>
      bonenoに-1が代入されます。<BR>
      <BR>
      ボーン以外の名前を指定した場合も、<BR>
      bonenoに-1が代入されます。<BR>
      <BR>
      <BR>
      複数のパーツやボーンに<BR>
      同じ名前があった場合、<BR>
      一番最初に見つかった物のidだけしか<BR>
      取得できません。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] char*　：　bonename<BR>
      　　ボーンの名前を渡してください。<BR>
      <BR>
      3. [OUT] int*　：　bonenoptr<BR>
      　　ボーンを識別するＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetNextMP</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">モーションポイントを識別するidを取得します。<BR>
      <BR>
      モーションポイントとは、<BR>
      RokDeBone2のモーションダイアログ中の<BR>
      下の方に白い長いウインドウがありますが、<BR>
      その中に表示されている<BR>
      点のことだと思ってください。<BR>
      <BR>
      モーションポイントは<BR>
      ユーザーさんがＩＫで設定した姿勢を<BR>
      保持しています。<BR>
      <BR>
      モーションポイントはボーンごとに作られています。<BR>
      <BR>
      気を付けて欲しいのは、<BR>
      RokDeBone2で白いウインドウ中に<BR>
      点が表示されていないフレーム番号には<BR>
      モーションポイントは存在しないということです。<BR>
      <BR>
      モーションポイントが無いフレーム番号の姿勢は<BR>
      どうなっているかというと、<BR>
      計算で求めています。<BR>
      <BR>
      <BR>
      モーションポイントはフレーム番号の小さい順に格納されています。<BR>
      <BR>
      E3DGetNextMPはprevmpidで指定した<BR>
      モーションポイントのフレーム番号を見て、<BR>
      そのフレーム番号の次に大きいフレーム番号を持つモーションポイントのidを取得します。<BR>
      <BR>
      prevmpidに-1を指定すると、<BR>
      一番小さいフレーム番号を持つモーションポイントのidが取得できます。<BR>
      <BR>
      prevmpidのモーションポイントが持つフレーム番号より大きいフレーム番号を持つモーションポイントが存在しない場合は<BR>
      mpidに-1が代入されます。<BR>
      <BR>
      <BR>
      つまり、取得したmpidを<BR>
      prevmpidに指定して<BR>
      再びE3DGetNextMPを呼び出す<BR>
      という作業を<BR>
      mpidに-1が代入されるまで繰り返せば、<BR>
      フレーム番号の小さい順に<BR>
      全てのモーションポイントのidが取得出来る<BR>
      ということになります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別するＩＤ<BR>
      　　E3DAddMotionで取得したmkを指定してください。<BR>
      <BR>
      3. [IN] int　：　boneno<BR>
      　　ボーンを識別するＩＤ<BR>
      　　E3DGetBoneNoByNameで取得した<BR>
      　　ボーンの番号を渡してください。<BR>
      <BR>
      4. [IN] int　：　prevmpid<BR>
      　　モーションポイントを識別するＩＤ<BR>
      　　E3DGetNextMPで取得したidを渡してください。<BR>
      <BR>
      　　-1を指定すると一番小さなフレーム番号を持つ<BR>
      　　モーションポイントのidがmpidに代入されます。<BR>
      <BR>
      5. [OUT] int*　：　mpidptr<BR>
      　　prevmpidの次に大きいフレーム番号を持つ<BR>
      　　モーションポイントのidが代入されます。<BR>
      <BR>
      <BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMPInfo</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">mpinfoptrで指定した構造体に、<BR>
情報が代入されます。<BR>
<BR>
      構造体MPINFO2はusercoef.hで定義されています。<BR>
      <BR>
      mpinfo.mpidはモーションポイントのID<BR>
      mpinfo.qidはモーションポイントのクォータニオン情報<BR>
      mpinfo.traはモーションポイントの移動情報<BR>
      mpinfo.framenoはモーションポイントのフレーム番号<BR>
      mpfino.interpolationはクォータニオンの補間方法。<BR>
      mpinfo.scaleはモーションポイントの拡大情報。<BR>
      mpinfo.userint1はユーザーデータ。<BR>
      <BR>
      mpinfo.qidには、<BR>
E3DCreateQで取得したqidを、<BR>
この関数の呼び出し前に、セットしておく必要があります。<BR>
      mpinfo.qidに格納されているqidで<BR>
識別されるクォータニオンに、<BR>
モーションポイントの姿勢情報が代入されます。<BR>
      mpinfo.mpidにもあらかじめ値をセットしておいてください。<BR>
      <BR>
      mpinfo.interpolationの<BR>
補間計算方法の情報は、<BR>
      mpidで識別されるモーションポイントと<BR>
      その次に大きいフレーム番号を持つモーションポイントの間の補間計算方法を示しています。<BR>
      ０の時は球面線形補間<BR>
      １の時はスプライン補間<BR>
となります。<BR>
<BR>
現バージョンでは、<BR>
      スプライン補間は大きな角度の補間時には<BR>
使用できません。<BR>
（望ましい結果が得られません）<BR>
ですので、<BR>
急激に変化することがあるかもしれない<BR>
      モーションポイント間の補間計算には<BR>
球面線形補間を使用することを、<BR>
おすすめします。<BR>
<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">・引数<BR>
      1. [IN] int　：　hsid<BR>
　　形状データを識別するＩＤ<BR>
<BR>
      2. [IN] int　：　motid<BR>
　　モーションを識別するＩＤ<BR>
　　E3DAddMotionで取得したmkを指定してください。<BR>
<BR>
      3. [IN] int　：　boneno<BR>
　　ボーンを識別するＩＤ<BR>
　　E3DGetBoneNoByNameで取得した<BR>
　　ボーンの番号を渡してください。<BR>
      <BR>
      4. [IN, OUT]　MPINFO2*　：　mpinfoptr<BR>
　　モーションポイントの情報を格納する配列。<BR>
      　　mpinfoptr-&gt;qidだけは、呼び出し前に<BR>
　　あらかじめ設定しておく必要があります。<BR>
<BR>
      　　mpinfoptr-&gt;qidで識別されるクォータニオンに<BR>
　　モーションポイントの姿勢情報が<BR>
　　代入されることになります。<BR>
</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMPInfo</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">mpidで識別されるモーションポイントに情報をセットします。<BR>
      <BR>
      mipptrにはMPINFO2構造体へのポインタを指定してください。<BR>
      mpinfo.mpidとmpinfo.qidには必ずあらかじめ値をセットしておいてください。<BR>
      <BR>
      <BR>
      flagptrには<BR>
      int flag[MPI2_MAX];で宣言した配列のポインタを渡してください。<BR>
      <BR>
      MPI2_で始まる定数はusercoef.hで定義されています。<BR>
<BR>
      mpinfoにセットされている情報を<BR>
      mpidで識別されるモーションポイントに<BR>
設定します。<BR>
<BR>
      mpinfoのどの成分に<BR>
何の情報をセットすれば良いかは<BR>
E3DGetMPInfoをご覧ください。<BR>
<BR>
      flagptrは部分的に情報をセットできるようにするために使用します。<BR>
<BR>
      flag[ MPI2_QUA ]が１の場合は、<BR>
      mpinfo.qidのクォータニオン情報を<BR>
モーションポイントにセットします。<BR>
      <BR>
      flag[ MPI2_TRA ]が１の場合は、<BR>
      mpinfo.traの移動量情報を<BR>
モーションポイントにセットします。<BR>
<BR>
      以下同様に、<BR>
      flag[MPI2_QUA] 〜flag[MPI2_USERINT1]<BR>
までに、セットしたい項目に１を、<BR>
セットしたくない項目に０を指定してください。<BR>
<BR>
      <BR>
      モーションポイントに情報をセットしただけではモデルのポーズに反映されません。<BR>
ポーズに反映させるためには、<BR>
E3DFillUpMotionを呼んでください。<BR>
<BR>
      だたし、E3DFillUpMotionは<BR>
      とても計算量が多く実行時間が長いので、<BR>
なるべく呼び出し回数は少なくしてください。<BR>
<BR>
つまり、必要なモーションポイントの操作が<BR>
全て終わってから、<BR>
      まとめて一回だけE3DFillUpMotionするように<BR>
してください。<BR>
</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別するＩＤ<BR>
      　　E3DAddMotionで取得したmkを指定してください。<BR>
      <BR>
      3. [IN] int　：　boneno<BR>
      　　ボーンを識別するＩＤ<BR>
      　　E3DGetBoneNoByNameで取得した<BR>
      　　ボーンの番号を渡してください。<BR>
      <BR>
      4. [IN]　MPINFO2*　：　mpinfoptr<BR>
      　　モーションポイントの情報を格納する配列。<BR>
      <BR>
      5. [IN]　int*　：　flagptr<BR>
      　　mpinfoのどの成分を有効にするのかを<BR>
      　　mpinfoflagの各成分で指定します。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DExistMP</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">framenoで指定したフレーム番号にモーションポイントがあるかどうかを調べます。<BR>
      <BR>
      見つかった場合は<BR>
      mpidにモーションポイントのidが代入され、<BR>
      無かった場合は-1が代入されます。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別するＩＤ<BR>
      　　E3DAddMotionで取得したmkを指定してください。<BR>
      <BR>
      3. [IN] int　：　boneno<BR>
      　　ボーンを識別するＩＤ<BR>
      　　E3DGetBoneNoByNameで取得した<BR>
      　　ボーンの番号を渡してください。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションポイントがあるかどうか、<BR>
      　　調べたいフレーム番号を指定します。<BR>
      <BR>
      5. [OUT] int*　：　mpid<BR>
      　　モーションポイントを識別するＩＤ。<BR>
      　　framenoが示すフレーム番号に<BR>
      　　モーションポイントがあった場合は、<BR>
      　　そのモーションポイントのidが代入されます。<BR>
      　　無かった場合は-1が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMotionFrameLength</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">motidで識別されるモーションのフレーム数を取得します。<BR>
      <BR>
      気を付けて欲しいのは<BR>
      フレーム番号は０から始まるので、<BR>
      最大のフレーム番号は<BR>
      leng - 1<BR>
      だということです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別するＩＤ<BR>
      　　E3DAddMotionで取得したmkを指定してください。<BR>
      <BR>
      3. [OUT] int*　：　leng<BR>
      　　モーションのフレーム数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMotionFrameLength</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">モーションのフレーム数をframelengに変更します。<BR>
      <BR>
      framelengが変更前のフレーム数より小さかった場合は、<BR>
      frameleng - 1より大きなフレーム番号を持つ<BR>
      モーションポイントは削除されます。<BR>
      <BR>
      ポーズの情報も削除されます。<BR>
      再構築する場合には<BR>
      E3DFillUpMotionを呼んでください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別するＩＤ<BR>
      　　E3DAddMotionで取得したmkを指定してください。<BR>
      <BR>
      3. [IN] int　：　frameleng<BR>
      　　モーションのフレーム数を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DAddMP</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">mpinfoで指定した情報を持つモーションポイントを新たに作成し、作成したモーションポイントを識別するidを取得します。<BR>
      <BR>
      mpinfoptrにはMPINFO2構造体へのポインタを渡してください。<BR>
      <BR>
      mpinfoのmpid以外の成分にあらかじめ値をセットして呼び出してください。<BR>
      mpinfoの、どの成分に、<BR>
      何の情報をセットすれば良いかは<BR>
      E3DGetMPInfoをご覧ください。<BR>
      <BR>
      <B>mpinfo[MPI2_FRAMENO]で指定したフレーム番号に、<BR>
      既に、モーションポイントが存在する場合は、エラーになりますので、<BR>
      注意してください。</B><BR>
      （呼び出し前にE3DExistMPで、<BR>
      チェックすると確実です。）<BR>
      <BR>
      <BR>
      新しいモーションポイントを識別するIDは<BR>
      mpinfoptr-&gt;mpidに代入されます。<BR>
      <BR>
      <BR>
      モーションポイントに情報をセットしただけではモデルのポーズに反映されません。<BR>
      ポーズに反映させるためには<BR>
      E3DFillUpMotionを呼んでください。<BR>
      <BR>
      だたし、E3DFillUpMotionは<BR>
      とても計算量が多く実行時間が長いので、<BR>
      なるべく呼び出し回数は少なくしてください。<BR>
      <BR>
      つまり、必要なモーションポイントの操作が<BR>
      全て終わってから<BR>
      まとめて一回だけE3DFillUpMotionするように<BR>
      してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別するＩＤ<BR>
      　　E3DAddMotionで取得したmkを指定してください。<BR>
      <BR>
      3. [IN] int　：　boneno<BR>
      　　ボーンを識別するＩＤ<BR>
      　　E3DGetBoneNoByNameで取得した<BR>
      　　ボーンの番号を渡してください。<BR>
      <BR>
      4. [IN, OUT]　MPINFO2*　：　mpinfoptr<BR>
      　　モーションポイントの情報を格納する配列。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDeleteMP</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">mpidで識別されるモーションポイントを削除します。<BR>
      <BR>
      この関数に渡したmpidは<BR>
      以後、使えなくなります。<BR>
      <BR>
      <BR>
      モーションポイントの情報を更新しただけではモデルのポーズに反映されません。<BR>
      ポーズに反映させるためには<BR>
      E3DFillUpMotionを呼んでください。<BR>
      <BR>
      だたし、E3DFillUpMotionは<BR>
      とても計算量が多く実行時間が長いので、<BR>
      なるべく呼び出し回数は少なくしてください。<BR>
      <BR>
      つまり、必要なモーションポイントの操作が<BR>
      全て終わってから<BR>
      まとめて一回だけE3DFillUpMotionするように<BR>
      してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別するＩＤ<BR>
      　　E3DAddMotionで取得したmotidを指定してください。<BR>
      <BR>
      3. [IN] int　：　boneno<BR>
      　　ボーンを識別するＩＤ<BR>
      　　E3DGetBoneNoByNameで取得した<BR>
      　　ボーンの番号を渡してください。<BR>
      <BR>
      4. [IN] int　：　mpid<BR>
      　　モーションポイントを識別するＩＤ<BR>
      　　E3DGetNextMPで取得したidを渡してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DFillUpMotion</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">モーションを指定したフレーム番号分だけ補間計算します。<BR>
      <BR>
      この計算の結果、<BR>
      モデルのポーズにモーションポイントの情報が反映されるようになります。<BR>
      <BR>
      bonenoで指定したボーンと<BR>
      その全ての子供ボーンの計算が行われます。<BR>
      <BR>
      そのため、<BR>
      <B><U>変更したボーンの内で<BR>
      一番親のボーンの番号で<BR>
      1回だけこの関数を呼び出せば<BR>
      良いことになります。</U><BR>
      <BR>
      </B></TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別するＩＤ<BR>
      　　E3DAddMotionで取得したmotidを指定してください。<BR>
      <BR>
      3. [IN] int　：　boneno<BR>
      　　ボーンを識別するＩＤ<BR>
      　　E3DGetBoneNoByNameで取得した<BR>
      　　ボーンの番号を渡してください。<BR>
      <BR>
      　　bonenoで指定したボーンと<BR>
      　　その子供ボーン全てのポーズを計算します。<BR>
      <BR>
      　　boneno に　-1を指定した場合は、<BR>
      　　全てのボーンの計算が行われます。<BR>
      <BR>
      　　ですが、<BR>
      　　bonenoを指定した方が<BR>
      　　計算量が少なくなります。<BR>
      <BR>
      <BR>
      4. [IN] int　：　startframe<BR>
      5. [IN] int　：　endframe<BR>
      　　フレーム番号が、<BR>
      　　startframeから、endframeまでの間の<BR>
      　　モデルのポーズを計算します。<BR>
      　　startframeとendframeには、<BR>
      　　モーションポイントが存在しなくても、<BR>
      　　計算可能です。<BR>
      <BR>
      　　endframeに-1を指定した場合は、<BR>
      　　startrframeから、最後のフレームまで<BR>
      　　計算されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCopyMotionFrame</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">srcmotidで識別されるモーションのフレーム番号srcframenoの全てのモーションポイントの情報を、dstmotidで識別されるモーションのフレーム番号dstframenoのモーションポイントへコピーします。<BR>
      <BR>
      dstframenoにモーションポイントが無い場合は作成されます。<BR>
      <BR>
      srcframenoにモーションポイントが無い場合は、<BR>
      計算で求めてdstframenoにコピーします。<BR>
      この場合、計算時間が余分にかかります。<BR>
      <BR>
      <BR>
      <BR>
      モーションポイントに情報をセットしただけではモデルのポーズに反映されません。<BR>
      ポーズに反映させるためには<BR>
      E3DFillUpMotionを呼んでください。<BR>
      <BR>
      だたし、E3DFillUpMotionは<BR>
      とても計算量が多く実行時間が長いので<BR>
      なるべく呼び出し回数は少なくしてください。<BR>
      <BR>
      つまり、必要なモーションポイントの操作が<BR>
      全て終わってから<BR>
      まとめて一回だけE3DFillUpMotionするように<BR>
      してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　srcmotid<BR>
      　　コピー元のモーションを識別するＩＤ<BR>
      　　E3DAddMotionで取得したmotidを指定してください。<BR>
      <BR>
      3. [IN] int　：　srcframeno<BR>
      　　コピー元のフレーム番号<BR>
      <BR>
      4. [IN] int　：　dstmotid<BR>
      　　コピー先のモーションを識別するＩＤ<BR>
      　　E3DAddMotionで取得したmotidを指定してください。<BR>
      <BR>
      5. [IN] int　：　dstframeno<BR>
      　　コピー先のフレーム番号<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetDirQ2</TD>
      <TD class="hpb-cnt-tb-cell2">モデル向き</TD>
      <TD class="hpb-cnt-tb-cell2">E3DGetDirQをqidで操作できるようにしたものです。<BR>
      <BR>
      qidで指定したクォータニオンに<BR>
      モデルデータの姿勢情報が<BR>
      格納されます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN, OUT] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetDirQ2</TD>
      <TD class="hpb-cnt-tb-cell2">モデル向き</TD>
      <TD class="hpb-cnt-tb-cell2">E3DSetDirQをqidで操作できるようにしたものです。<BR>
      <BR>
      qidで識別されるクォータニオンの<BR>
      姿勢情報を<BR>
      モデルデータにセットします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLookAtQ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">指定した向きを徐々に向くための姿勢情報を、クォータニオンにセットします。<BR>
      <BR>
      <U><FONT size="+1">この関数はこの関数の呼び出し前の<BR>
      クォータニオンの姿勢情報も計算に使用します。<BR>
      </FONT></U>ですので、<BR>
      qidには一回前にこの関数を呼び出したときと同じqidが渡されるものと仮定しています。<BR>
      <BR>
      qidを他のボーンの姿勢情報などの計算の際に使い回ししている場合は、<BR>
      計算したいボーンの姿勢情報を<BR>
      呼び出し前に<BR>
      E3DCopyQなどでコピーしておいてください。<BR>
      <BR>
      <BR>
      （basevecx, basevecy, basevecz）のベクトルを<BR>
      (vecx, vecy, vecz)の方向に向ける計算をします。<BR>
      <BR>
      キャラクター全体の姿勢の制御をする場合は、<BR>
      basevecには初期状態の向き<BR>
      つまり、(0, 0, -1)を与えればよいことになります。<BR>
      <BR>
      ボーンの姿勢を制御する場合には、<BR>
      初期状態のボーンの向き<BR>
      つまり、ボーンの座標から親ボーンの座標を<BR>
      引いたものをbasevecに与えれば、<BR>
      よいことになります。<BR>
      <BR>
      <BR>
      (vecx, vecy, vecz)には、<BR>
      向きたい位置座標から<BR>
      自分の位置座標を引いたものを<BR>
      与えてください。<BR>
      <BR>
      <BR>
      upflagの値によって４つのモードがあります。<BR>
      <BR>
      upflag == 0 のときは、<BR>
      上向き方向が常にＹ軸上方を向くように<BR>
      制御されます。<BR>
      <BR>
      upflag == 1 のときは、<BR>
      上向き方向が常にＹ軸下方を向くように<BR>
      制御されます。<BR>
      <BR>
      upflag == 2 のときは、<BR>
      上向き方向が連続した向きをとるように、<BR>
      制御されます。<BR>
      その結果、宙返りが可能となります。<BR>
      <BR>
      upflag == 3 のときは、<BR>
      上向き方向を特に制御しません。<BR>
      上向き方向は連続した向きをとりますが、<BR>
      その方向は拘束されません。<BR>
      <BR>
      飛行機の制御などにupflag 2を使用し、<BR>
      人型キャラなどの制御にupflag 0 を使用する<BR>
      ことをおすすめします。<BR>
      <BR>
      <B>upflag == 0とupflag== 1のときには、<BR>
      真上と真下を向かないようにしてください。<BR>
      </B><BR>
      upflag == 2とupflag==3のときは、<BR>
      真上と真下を向いても、大丈夫です。<BR>
      <BR>
      <BR>
      divnum引数に分割数を指定します。<BR>
      現在の位置と目標地点との間の間隔を<BR>
      1 / divnum ずつ、内分して、近づきます。<BR>
      <BR>
      既知のバグとして分割数が小さいと（１のとき）向きが動かなくなるという不具合があります。<BR>
      そのうち作り直す予定です。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      　　このidで識別されるクォータニオンに<BR>
      　　指定した方向を向くための情報が<BR>
      　　格納されます。<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　vec<BR>
      　　向きたい向きのベクトルを指定してください。<BR>
      　　位置ではなくて向きを指定してください。<BR>
      <BR>
      3. [IN] D3DXVECTOR3　：　basevec<BR>
      　　初期状態の向きを指定してください。<BR>
      <BR>
      4. [IN] int　：　upflag<BR>
      　　上方向の制御モードを指定してください。<BR>
      　　<BR>
      <BR>
      5. [IN] int　：　divnum<BR>
      　　内分する割合を指定してください。<BR>
      　　大きな値をいれるほど、<BR>
      　　細かく動きます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DMultQVec</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">(befvecx, befvecy, befvecz)というベクトルに対して、qidで識別されるクォータニオンによる回転をした後のベクトルを、(aftvecx,
      aftvecy, aftvecz)に代入します。<BR>
      <BR>
      <BR>
      例えば、初期状態で-Z方向を向いている<BR>
      モデルの場合、<BR>
      <BR>
      qidにE3DGetDirQ2呼び出しに使用した<BR>
      qidを渡し<BR>
      basevecに（0, 0, -1）を渡せば、<BR>
      aftvecに現在キャラクターが向いている向きが代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      　　このidで識別されるクォータニオンの<BR>
      　　回転変換をします。<BR>
      　　<BR>
      2. [IN] D3DXVECTOR3　：　befvec<BR>
      　　回転前のベクトルを指定してください。<BR>
      <BR>
      3. [OUT] D3DXVECTOR3*　：　aftvecptr<BR>
      　　クォータニオンでの回転後のベクトが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DTwistQ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンにねじりを加えます。<BR>
      <BR>
      basevecにはE3DLookAtQで説明したのと<BR>
      同じ、初期状態の向きを指定してください。<BR>
      <BR>
      <BR>
      ねじりの角度は、初期状態からの角度ではなく現在の姿勢に追加したい分だけの<BR>
      ねじりの角度を指定してください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      　　このidで識別されるクォータニオンに、<BR>
      　　指定した方向を向くための情報が、<BR>
      　　格納されます。<BR>
      <BR>
      2. [IN] float　：　twistdeg<BR>
      　　twistdeg  度だけ、ねじりを加えます。<BR>
      <BR>
      3. [IN] D3DXVECTOR3　：　basevec<BR>
      　　初期状態の向きを指定してください。<BR>
      　　E3DLookAtQで指定したのと同じbasevecを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DInitTwistQ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">E3DTwistQで与えたねじれを初期化します。<BR>
      <BR>
      basevecにはE3DLookAtQで説明したのと<BR>
      同じ、初期状態の向きを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      　　このidで識別されるクォータニオンの<BR>
      　　ねじれを初期化します。<BR>
      　　<BR>
      2. [IN] D3DXVECTOR3　：　basevec<BR>
      　　初期状態の向きを指定してください。<BR>
      　　E3DLookAtQで指定したのと同じbasevecを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetTwistQ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">E3DTwistQで与えたねじれの角度の合計を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      　　このidで識別されるクォータニオンの<BR>
      　　ねじれを取得します。<BR>
      <BR>
      2. [OUT] float*　：　twistptr<BR>
      　　ねじれ角度の合計の値を<BR>
      　　代入します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRotateQLocalX</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンをローカルなＸ軸に関して回転します。<BR>
      <BR>
      現在の姿勢に対して更に回転します。<BR>
      <BR>
      E3DRotateQXと違うのは、<BR>
      姿勢変換を行う前のＸ軸に関して<BR>
      回転できる点です。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      　　このidで識別されるクォータニオンに、<BR>
      　　回転を加えます。<BR>
      <BR>
      2. [IN] float　：　deg<BR>
      　　deg 度だけ、回転を加えます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRotateQLocalY</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンをローカルなＹ軸に関して回転します。<BR>
      <BR>
      現在の姿勢に対して更に回転します。<BR>
      <BR>
      E3DRotateQYと違うのは、<BR>
      姿勢変換を行う前のＹ軸に関して<BR>
      回転できる点です。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      　　このidで識別されるクォータニオンに、<BR>
      　　回転を加えます。<BR>
      <BR>
      2. [IN] float　：　deg<BR>
      　　deg 度だけ、回転を加えます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRotateQLocalZ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンをローカルなＺ軸に関して回転します。<BR>
      <BR>
      現在の姿勢に対して更に回転します。<BR>
      <BR>
      E3DRotateQZと違うのは、<BR>
      姿勢変換を行う前のＺ軸に関して<BR>
      回転できる点です。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      　　このidで識別されるクォータニオンに、<BR>
      　　回転を加えます。<BR>
      <BR>
      2. [IN] float　：　deg<BR>
      　　deg 度だけ、回転を加えます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBonePos</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンの位置情報を取得します。<BR>
      <BR>
      poskind == 0のときはローカル座標(ボーン変形なし)<BR>
      poskind == 1のときはグローバル座標<BR>
      poskind == 2のときはローカル座標（ボーン変形あり）<BR>
      が取得できます。<BR>
      <BR>
      bonenoには、E3DGetBoneNoByName<BR>
      で取得した番号を指定してください。<BR>
      <BR>
      <BR>
      マルチレイヤーモーションを使用する場合は、<BR>
      この命令は使えません。<BR>
      E3DGetCurrentBonePosをお使いください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別するＩＤ<BR>
      　　E3DGetBoneNoByNameで取得した<BR>
      　　ボーンの番号を渡してください。<BR>
      　　<BR>
      3. [IN] int　：　poskind<BR>
      　　ローカル座標と、グローバル座標の<BR>
      　　どちらを取得するかを指定します。<BR>
      <BR>
      4. [IN] int　：　motid<BR>
      　　モーションを識別するＩＤ<BR>
      　　E3DAddMotionで取得したmotidを指定してください。<BR>
      <BR>
      5. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定してください。<BR>
      　　E3DSetNewPose呼び出し時に現在のフレーム番号が取得できるので<BR>
      　　参考にしてください。<BR>
      <BR>
      <BR>
      6. [OUT] D3DXVECTOR3*　：　pos<BR>
      　　ボーンの座標が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateLine</TD>
      <TD class="hpb-cnt-tb-cell2">ライン</TD>
      <TD class="hpb-cnt-tb-cell2">線を作成してlineidを取得します。<BR>
      lineidは線オブジェクトを一意に識別するための番号です。<BR>
      <BR>
      E3DCreateLine、E3DDestroyLine<BR>
      E3DSetLineColor、E3DAddPoint2Line<BR>
      E3DDeletePointOfLine、E3DSetPointPosOfLine<BR>
      E3DGetPointPosOfLine<BR>
      E3DGetNextPointOfLine<BR>
      E3DGetPrevPointOfLine<BR>
      に渡すlineidは、この関数で取得したlineidを<BR>
      使用してください。<BR>
      <BR>
      pointposには、<BR>
      D3DXVECTOR3 pointpos[ pointnum ];<BR>
      で確保したデータを渡してください。<BR>
      <BR>
      pointnumには、点の数を入れてください。<BR>
      <B>点の数の最大値は６５５３５です。</B><BR>
      <B>pointnumが２より小さい場合は、エラーになります。</B><BR>
      pointpos[点の番号].xにＸ座標、<BR>
      pointpos[点の番号].yにＹ座標、 <BR>
      pointpos[点の番号].z にＺ座標<BR>
      を入れて、初期化しておいてください。<BR>
      <BR>
      <BR>
      作成した線は、<BR>
      E3DRenderで描画できます。<BR>
      hsidの代わりにlineidを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3*　：　pointpos<BR>
      　　線を構成する点の座標を指定してください。<BR>
      　　メモリの確保の仕方、値のセットの仕方は、<BR>
      　　左の記述をご覧ください。<BR>
      <BR>
      2. [IN] int　：　pointnum<BR>
      　　初期化する点の数を指定してください。<BR>
      　　pointposのデータを確保する際に使った点の数を渡してください。<BR>
      <BR>
      3. [IN] int　：　maxpointnum<BR>
      　　Lineは、E3DAddPoint2Line命令で、<BR>
      　　点の数を増やすことが可能です。<BR>
      　　最大何個まで、点の数を増やせるかを指定してください。<BR>
      　　（点の数の合計です。）<BR>
      　　<BR>
      　　ビデオメモリは、pointnumではなくて、<BR>
      　　maxpointnumでアロケートされます。<BR>
      <BR>
      4. [IN] int　：　linekind<BR>
      　　線の種類を指定します。<BR>
      　　LINELISTの場合は２を、<BR>
      　　LINESTRIPの場合は３を指定してください。<BR>
      　　LINELIST, LISTSTRIPについての説明は、<BR>
      　　<A href="linekind.htm">線の種類の説明</A>をご覧ください。<BR>
      <BR>
      5. [OUT] int*　：　lineid<BR>
      　　作成した線を識別する番号が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyLine</TD>
      <TD class="hpb-cnt-tb-cell2">ライン</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateLine で作成した線を削除します。<BR>
      削除したlineidは<BR>
      以降、どの命令にも使わないでください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lineid<BR>
      　　削除する線を識別する番号を渡します。<BR>
      　　E3DCreateLineで取得した番号を使ってください。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetLineColor</TD>
      <TD class="hpb-cnt-tb-cell2">ライン</TD>
      <TD class="hpb-cnt-tb-cell2">線の色を設定します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lineid<BR>
      　　線を識別する番号を渡します。<BR>
      　　E3DCreateLineで取得した番号を使ってください。<BR>
      <BR>
      2. [IN] E3DCOLOR4UC　：　col<BR>
      　　色を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DAddPoint2Line</TD>
      <TD class="hpb-cnt-tb-cell2">ライン</TD>
      <TD class="hpb-cnt-tb-cell2">線に点を追加し、追加した点を識別するpidを取得します。<BR>
      <BR>
      点の数の合計が<BR>
      E3DCreateLineに渡したmaxpointnum<BR>
      より大きくなるとエラーになります。<BR>
      <BR>
      取得したpidをE3DSetPointPosOfLine関数に<BR>
      渡して<BR>
      付け足した点の座標をセットしてください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lineid<BR>
      　　線を識別する番号を渡します。<BR>
      　　E3DCreateLineで取得した番号を使ってください。<BR>
      <BR>
      2. [IN] int　：　prevpid<BR>
      　　線の中のどこに、新しい点を追加するかを指定します。<BR>
      　　prevpidで指定した点の次の点として、<BR>
      　　新しい点を追加します。<BR>
      　　prevpidに-2を指定した場合には線の先頭に、<BR>
      　　prevpidに-1を指定した場合には線の最後に<BR>
      　　新しい点を追加します。<BR>
      <BR>
      3. [OUT] int*　：　pidptr<BR>
      　　新しく追加した点を識別する番号が代入されます。<BR>
      　　pidは線ごとに固有な値です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDeletePointOfLine</TD>
      <TD class="hpb-cnt-tb-cell2">ライン</TD>
      <TD class="hpb-cnt-tb-cell2">線の中の点を削除します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lineid<BR>
      　　線を識別する番号を渡します。<BR>
      　　E3DCreateLineで取得した番号を使ってください。<BR>
      <BR>
      2. [IN] int　：　pid<BR>
      　　削除する点を識別する番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetPointPosOfLine</TD>
      <TD class="hpb-cnt-tb-cell2">ライン</TD>
      <TD class="hpb-cnt-tb-cell2">線の中の点の座標をセットします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lineid<BR>
      　　線を識別する番号を渡します。<BR>
      　　E3DCreateLineで取得した番号を使ってください。<BR>
      <BR>
      2. [IN] int　：　pid<BR>
      　　点を識別する番号を渡します。<BR>
      <BR>
      3. [IN] D3DXVECTOR3　：　pos<BR>
      　　点の座標を渡してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetPointPosOfLine</TD>
      <TD class="hpb-cnt-tb-cell2">ライン</TD>
      <TD class="hpb-cnt-tb-cell2">線の中の点の座標を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lineid<BR>
      　　線を識別する番号を渡します。<BR>
      　　E3DCreateLineで取得した番号を使ってください。<BR>
      <BR>
      2. [IN] int　：　pid<BR>
      　　点を識別する番号を渡します。<BR>
      <BR>
      3. [OUT] D3DXVECTOR3*　：　posptr<BR>
      　　点の座標が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetNextPointOfLine</TD>
      <TD class="hpb-cnt-tb-cell2">ライン</TD>
      <TD class="hpb-cnt-tb-cell2">previdで指定した点の一つ後の点のＩＤを取得します。<BR>
      <BR>
      線は、点を双方向リストで格納しています。<BR>
      <BR>
      <BR>
      一つ後の点が存在しない場合は<BR>
      nextid には、負の値が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lineid<BR>
      　　線を識別する番号を渡します。<BR>
      　　E3DCreateLineで取得した番号を使ってください。<BR>
      <BR>
      2. [IN] int　：　previd<BR>
      　　点を識別する番号<BR>
      <BR>
      3. [OUT] int*　：　nextidptr<BR>
      　　previdの点の一つ後の点のＩＤが代入されます。<BR>
      <BR>
      　　previd に-1が指定されている場合は、<BR>
      　　nextidには、先頭の点のIDが代入されます<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetPrevPointOfLine</TD>
      <TD class="hpb-cnt-tb-cell2">ライン</TD>
      <TD class="hpb-cnt-tb-cell2">pidで指定した点の一つ前の点のＩＤを取得します。<BR>
      <BR>
      <BR>
      線は、点を双方向リストで格納しています。<BR>
      <BR>
      一つ前の点が存在しない場合は、<BR>
      previd には、負の値が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lineid<BR>
      　　線を識別する番号を渡します。<BR>
      　　E3DCreateLineで取得した番号を使ってください。<BR>
      <BR>
      2. [IN] int　：　pid<BR>
      　　点を識別するID<BR>
      <BR>
      3. [OUT] int*　：　previdptr<BR>
      　　pidの点の一つ後の点のＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DWriteDisplay2BMP</TD>
      <TD class="hpb-cnt-tb-cell2">出力</TD>
      <TD class="hpb-cnt-tb-cell2">バックバッファの内容をＢＭＰファイルに保存します。<BR>
      <BR>
      filenameには拡張子を除いた名前を<BR>
      指定してください。<BR>
      <BR>
      <BR>
      <U><B>E3DInitのmultisamplenumに０以外を指定した場合は、この命令は使えません。<BR>
      （エラーになります。）<BR>
      </B></U></TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　出力するＢＭＰ のパス文字列。<BR>
      　　拡張子を除いたパスを指定してください。<BR>
      　　この関数で自動的に”.bmp”が付加されます。<BR>
      <BR>
      　　既に同じファイル名が存在している場合は<BR>
      　　そのファイルは上書きされるので注意してください。<BR>
      <BR>
      2. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateAVIFile</TD>
      <TD class="hpb-cnt-tb-cell2">出力</TD>
      <TD class="hpb-cnt-tb-cell2">ＡＶＩファイルを初期化してaviidを取得します。<BR>
      <BR>
      aviidはＡＶＩファイルを識別するための番号です。<BR>
      <BR>
      この命令で作成したＡＶＩファイルに対して<BR>
      E3DWriteData2AVIFile命令で<BR>
      バックバッファの内容を書き込み、<BR>
      E3DCompleteAVIFile命令で<BR>
      終了処理をします。<BR>
      <BR>
      E3DWriteData2AVIFile命令、<BR>
      E3DCompleteAVIFile命令には、<BR>
      E3DCreateAVIFile命令で取得したaviidを<BR>
      渡してください。<BR>
      <BR>
      <BR>
      <U><B>E3DInitのmultisamplenumに０以外を指定した場合は、この命令は使えません。<BR>
      （エラーになります。）<BR>
      </B></U><BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを指定してください。<BR>
      <BR>
      2. [IN] char*　：　filename<BR>
      　　出力するＢＭＰ のパス文字列。<BR>
      <BR>
      　　拡張子を除いたパスを指定してください。<BR>
      　　この関数で自動的に”.avi”が付加されます。<BR>
      <BR>
      　　既に同じファイル名が存在している場合は、<BR>
      　　そのファイルは上書きされるので注意してください。<BR>
      <BR>
      3. [IN] int　：　datatype<BR>
      　　作成するデータの種類を指定します。<BR>
      　　現バージョンでは映像のみしか扱わないため、<BR>
      　　常に１を指定してください。<BR>
      <BR>
      4. [IN] int　：　compkind<BR>
      　　圧縮の種類を指定します。<BR>
      　　０を指定した場合は<BR>
      　　　　圧縮なし、<BR>
      　　１を指定した場合は<BR>
      　　　　cinepak Codec by Radiusによる圧縮、<BR>
      　　２を指定した場合には<BR>
      　　　　Microsoft Video 1による圧縮<BR>
      　　をします。<BR>
      <BR>
      5. [IN] int　：　framerate<BR>
      　　ＡＶＩファイルのフレームレートを指定してください。<BR>
      　　通常は、スクリプトプログラムのＦＰＳを指定します。<BR>
      　　６０ＦＰＳで表示している場合は、６０と指定します。<BR>
      <BR>
      <BR>
      6. [IN] int　：　frameleng<BR>
      　　ＡＶＩファイルのフレーム数の合計数。<BR>
      　　frameleng回だけ、E3DWriteData2AVIFileで<BR>
      　　データをファイルに書き込むことが出来ます。<BR>
      <BR>
      7. [OUT] int*　：　aviidptr<BR>
      　　作成したＡＶＩファイルを識別するための番号が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DWriteData2AVIFile</TD>
      <TD class="hpb-cnt-tb-cell2">出力</TD>
      <TD class="hpb-cnt-tb-cell2">バックバッファの内容をＡＶＩファイルに書き込みます。<BR>
      <BR>
      E3DCreateAVIFileで指定したframeleng回だけ<BR>
      この命令を呼ぶことが出来ます。<BR>
      <BR>
      frameleng回を超えた呼び出しは、<BR>
      エラーとなり無視されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　aviid<BR>
      　　AVIファイルを識別するための番号を指定してください。<BR>
      　　E3DCreateAVIFileで取得した番号を使用してください。<BR>
      <BR>
      3. [IN] int　：　datatype<BR>
      　　作成するデータの種類を指定します。<BR>
      　　現バージョンでは映像のみしか扱わないため、<BR>
      　　常に１を指定してください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCompleteAVIFile</TD>
      <TD class="hpb-cnt-tb-cell2">出力</TD>
      <TD class="hpb-cnt-tb-cell2">ＡＶＩファイルの終了処理をします。<BR>
      <BR>
      必要な回数E3DWriteData2AVIFile命令を<BR>
      呼び出した後に、この命令を呼び出してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　aviid<BR>
      　　AVIファイルを識別するための番号を指定してください。<BR>
      　　E3DCreateAVIFileで取得した番号を使用してください。<BR>
      <BR>
      3. [IN] int　：　datatype<BR>
      　　作成するデータの種類を指定します。<BR>
      　　現バージョンでは映像のみしか扱わないため、<BR>
      　　常に１を指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCameraLookAt</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラを向きたい方向に徐々に向けます。<BR>
      <BR>
      vecには注視点ではなくて、<BR>
      向きたい向きのベクトルを指定してください。<BR>
      <BR>
      例えば、注視点tを向きたい場合は、<BR>
      E3DGetCameraPosでカメラの位置を求め、<BR>
      引き算するだけでＯＫです。<BR>
      vec = t - campos<BR>
      のようにして計算し指定してください。<BR>
      <BR>
      <BR>
      upflagはE3DLookAtQでの用法と同じです。<BR>
      upflag == 0 のときは、<BR>
      上向き方向が常にＹ軸上方を向くように<BR>
      制御されます。<BR>
      <BR>
      upflag == 1 のときは、<BR>
      上向き方向が常にＹ軸下方を向くように<BR>
      制御されます。<BR>
      <BR>
      upflag == 2 のときは、<BR>
      上向き方向が連続した向きをとるように<BR>
      制御されます。<BR>
      その結果、宙返りが可能となります。<BR>
      <BR>
      upflag == 3 のときは、<BR>
      上向き方向を特に制御しません。<BR>
      上向き方向は連続した向きをとりますが<BR>
      その方向は拘束されません。<BR>
      <BR>
      <BR>
      divnum引数に分割数を指定します。<BR>
      現在の位置と目標地点との間の間隔を<BR>
      1 / divnum ずつ内分して近づきます。<BR>
      <BR>
      また、このページの最初に書いてある、<BR>
      カメラの使い方の所も、お読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　vec<BR>
      　　向きたいベクトルを指定してください。<BR>
      　　ベクトルの計算方法は前記をご覧ください。<BR>
      <BR>
      2. [IN] int　：　upflag<BR>
      　　上向き制御方法のモードを指定してください。<BR>
      　　詳しくは前記をご覧ください。<BR>
      <BR>
      3. [IN] int　：　divnum<BR>
      　　分割数を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCameraOnNaviLine</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラをナビラインに沿って動かします。<BR>
      <BR>
      mode引数に０を指定すると<BR>
      カメラの位置だけを制御します。<BR>
      <BR>
      mode引数に１を指定すると<BR>
      位置に加え向きも制御します。<BR>
      <BR>
      ループ移動や反対方向への移動も<BR>
      サポートしています。<BR>
      <BR>
      <BR>
      ナビラインの作成には<BR>
      GViewer.exeを使うと便利です。<BR>
      （おちゃっこＬＡＢでダウンロード可能です。）<BR>
      <BR>
      ナビラインは地面の高さに作成することが<BR>
      普通なのでナビラインからカメラまでの<BR>
      オフセット値を指定できるようにしました。<BR>
      <BR>
      例えば、地面から１０００だけ上方を<BR>
      カメラを動かしたいときは、<BR>
      地面の高さにナビラインを作成し<BR>
      この関数のオフセット引数に<BR>
      offsetx = 0 : offsety = 1000 : offsetz = 0<BR>
      の値を指定すればＯＫです。<BR>
      <BR>
      また、このページの最初に書いてある、<BR>
      カメラの使い方の所も、お読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　nlid<BR>
      　　ナビラインを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　mode<BR>
      　　位置だけを制御する場合は０を、<BR>
      　　位置と向きを制御する場合は１を指定してください。<BR>
      <BR>
      3. [IN] int　：　roundflag<BR>
      　　ナビラインの最後のナビポイントに移動した後<BR>
      　　ナビラインの最初のナビポイントの位置を目指すかどうかを示します。<BR>
      <BR>
      　　１を指定すると円形のナビラインの場合は、<BR>
      　　ずっとぐるぐる回ることになります。<BR>
      <BR>
      4. [IN] int　：　reverseflag<BR>
      　　１を指定すると<BR>
      　　ナビラインのポイントを逆順にたどるようになります。<BR>
      <BR>
      <BR>
      5. [IN] D3DXVECTOR3　：　offset<BR>
      　　ナビラインからカメラ位置までのオフセット値を指定します。<BR>
      <BR>
      6. [IN] float　：　posstep<BR>
      　　カメラを一度にどれくらいの距離を移動させるかを指定します。<BR>
      　　ただし、ナビポイント付近では<BR>
      　　posstepより小さな距離しか移動させないことがあります。<BR>
      <BR>
      7. [IN] int　：　dirdivnum<BR>
      　　向きたい向きまで徐々にカメラを向けるための<BR>
      　　引数です。<BR>
      　　目標までの角度を1/dirdivnumずつ内分して、<BR>
      　　徐々に向きを制御します。<BR>
      <BR>
      8. [IN] int　：　upflag<BR>
      　　E3DCameraLookAt関数のupflag引数と同じ意味です。<BR>
      　　詳しくは、E3DCameraLookAtの説明部分を<BR>
      　　お読みください。<BR>
      <BR>
      <BR>
      9. [IN] [OUT] 変数　：　targetpointid<BR>
      　　現在目指しているナビポイントのＩＤを入れます。<BR>
      　　移動後は次に目指すべきナビポイントのＩＤが代入されます。<BR>
      <BR>
      　　ですので、一番最初の呼び出し時のみ自分でtargetpoinidを指定すれば、<BR>
      　　あとは同じ変数を渡すだけで<BR>
      　　自動的に目指すべきポイントのＩＤが<BR>
      　　代入されていくことになります。<BR>
      <BR>
      　　targetpointidに<BR>
      　　存在しないナビポイントのＩＤを入れた場合は、<BR>
      　　（例えば-1など）<BR>
      　　自動的に目指すべきナビポイントを決定します。<BR>
      　　</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCameraDirUp</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラの現在向いている方向を、徐々に上の方向に向けます。<BR>
      <BR>
      現バージョンでは<BR>
      宙返りはサポートしていません。<BR>
      <BR>
      <BR>
      また、このページの最初に書いてある<BR>
      カメラの使い方の所もお読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　deg<BR>
      　　角度。<BR>
      <BR>
      2. [IN] int　：　divnum<BR>
      　　deg度の角度を1/divnumずつ内分して<BR>
      　　カメラを上方向に向けます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCameraDirDown</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラの現在向いている方向を、徐々に下の方向に向けます。<BR>
      <BR>
      現バージョンでは<BR>
      宙返りはサポートしていません。<BR>
      <BR>
      <BR>
      <BR>
      また、このページの最初に書いてある<BR>
      カメラの使い方の所もお読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　deg<BR>
      　　角度。<BR>
      <BR>
      2. [IN] int　：　divnum<BR>
      　　deg度の角度を1/divnumずつ内分して<BR>
      　　カメラを下方向に向けます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCameraDirRight</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラの現在向いている方向を、徐々に右の方向に向けます。<BR>
      <BR>
      <BR>
      また、このページの最初に書いてある<BR>
      カメラの使い方の所もお読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　deg<BR>
      　　角度。<BR>
      <BR>
      2. [IN] int　：　divnum<BR>
      　　deg度の角度を1/divnumずつ内分して<BR>
      　　カメラを、右方向に向けます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCameraDirLeft</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラの現在向いている方向を、徐々に左の方向に向けます。<BR>
      <BR>
      <BR>
      また、このページの最初に書いてある<BR>
      カメラの使い方の所もお読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　deg<BR>
      　　角度。<BR>
      <BR>
      2. [IN] int　：　divnum<BR>
      　　deg度の角度を1/divnumずつ内分して<BR>
      　　カメラを左方向に向けます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateFont</TD>
      <TD class="hpb-cnt-tb-cell2">テキスト</TD>
      <TD class="hpb-cnt-tb-cell2">フォントを作成し、フォントを識別するＩＤを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　height<BR>
      　　フォントの文字セルまたは文字の高さを論理単位で指定します。<BR>
      　　文字の高さとは、<BR>
      　　文字セルの高さから内部レディング（アクセント記号などのためのスペース）の<BR>
      　　高さを引いたものです。<BR>
      　　要求されたサイズを超えない最大のフォントを探して処理されます。<BR>
      <BR>
      2. [IN] int　：　width<BR>
      　　フォントの平均文字幅を論理単位で指定します。<BR>
      　　0 を指定すると、条件に最も近い値が選択されます。<BR>
      　　条件に最も近い値は、利用可能な各フォントの現在のデバイスでの<BR>
      　　縦横比とデジタル化された縦横比の差の絶対値を比較することにより<BR>
      　　決定されます。<BR>
      <BR>
      3. [IN] int　：　weight<BR>
      　　フォントの太さを表す 0 から 1000 までの範囲内の値を指定します。<BR>
      　　たとえば、400 を指定すると標準の太さになり、<BR>
      　　700 を指定すると太字になります。<BR>
      　　0 を指定すると、既定の太さが選択されます。<BR>
      <BR>
      4. [IN] int　：　bItalic<BR>
      　　斜体にするかどうかを指定します。<BR>
      　　１ を指定すると、斜体になります。 <BR>
      <BR>
      5. [IN] int　：　bUnderline<BR>
      　　下線を付けるかどうかを指定します。<BR>
      　　１ を指定すると、下線付きになります。<BR>
      <BR>
      6. [IN] int　：　bStrikeout<BR>
      　　取り消し線を付けるかどうかを指定します。<BR>
      　　１ を指定すると、取り消し線が付きます。<BR>
      <BR>
      7. [IN] char*　：　fontname<BR>
      　　フォントの名前が入った 文字列を指定します。<BR>
      　　文字列の長さは、 31 文字以下にしなければなりません。<BR>
      <BR>
      8. [OUT] int*　：　fontidptr<BR>
      　　作成したフォントを識別するための<BR>
      　　番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDrawTextByFontID</TD>
      <TD class="hpb-cnt-tb-cell2">テキスト</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateFontで作成したフォントにより、指定した位置、色で、テキストを表示します。<BR>
      <BR>
      \nで改行できます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　fontid<BR>
      　　E3DCreateFontで作成した、フォントの番号を指定します。<BR>
      <BR>
      3. [IN] POINT　：　pos<BR>
      　　テキストをする位置を指定します。<BR>
      <BR>
      4. [IN] char*　：　textstr<BR>
      　　表示したい文字列を指定します。<BR>
      <BR>
      5. [IN] E3DCOLOR4UC　：　col<BR>
      　　文字の透明度と色を指定します。<BR>
      <BR>
      6. [IN] int　：　bmode<BR>
      　　ブレンドモードを指定。<BR>
      　　ブレンドモードの数値は<BR>
      　　E3DSetBlendingModeのblendmode引数の説明をお読みください。<BR>
      　　この引数は省略可能。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.5.0.5で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDrawTextByFontIDWithCnt</TD>
      <TD class="hpb-cnt-tb-cell2">テキスト</TD>
      <TD class="hpb-cnt-tb-cell2">カウンター制御で一定間隔で徐々に文字列を表示します。<BR>
      <BR>
      eachcnt引数に一文字当たりの待機期間を<BR>
      指定します。<BR>
      この値とcurcntに指定したカウンターの値を<BR>
      比較して文字を表示します。<BR>
      <BR>
      curcntには、通常、この命令を呼び出すたびに<BR>
      １ずつ増えるカウンターの値を指定します。<BR>
      <BR>
      <BR>
      例えば、eachcntに１０を指定した場合には<BR>
      一文字当たり１０カウントだけ待機するので、<BR>
      １文字目はcurcntが１０になるまで表示されません。<BR>
      ２文字目はcurcntが２０になるまで表示されません。<BR>
      <BR>
      と、このように、curcntの値が増えるに従って<BR>
      徐々に表示文字長が増えていきます。<BR>
      <BR>
      <BR>
      現バージョンでは半角カタカナには、<BR>
      対応していません。<BR>
      <BR>\nで改行できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　fontid<BR>
      　　E3DCreateFontで作成したフォントの番号を指定します。<BR>
      <BR>
      3. [IN] POINT　：　pos<BR>
      　　テキストをする位置を指定します。<BR>
      <BR>
      4. [IN] char*　：　textstr<BR>
      　　表示したい文字列を指定します。<BR>
      <BR>
      5. [IN] E3DCOLOR4UC　：　col<BR>
      　　文字の透明度と色を指定します。<BR>
      <BR>
      6. [IN] int　：　eachcnt<BR>
      　　一文字当たりどれくらい待ってから表示するかを指定します。<BR>
      <BR>
      7. [IN] int　：　curcnt<BR>
      　　現在のカウンターを指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDrawTextByFontIDWithCntEach</TD>
      <TD class="hpb-cnt-tb-cell2">テキスト</TD>
      <TD class="hpb-cnt-tb-cell2">カウンター制御で文字ごとに表示タイミングを指定して文字列を表示します。<BR>
      <BR>
      <BR>
      cntarray引数に<BR>
      文字ごとの表示タイミングを指定した配列を<BR>
      指定してください。<BR>
      <BR>
      cntarrayの長さは<BR>
      E3DGetCharacterNum関数で<BR>
      textstrの文字数を取得して決定してください。<BR>
      <BR>
      cntarray中の表示タイミングと<BR>
      curcntに指定したカウンターの値を比べて、<BR>
      文字を表示するかどうかを決定します。<BR>
      <BR>
      <BR>
      cntarray[0]に１０を、<BR>
      cntarray[1]に２０を指定した場合には、<BR>
      curcntが１０になったときに１文字目が表示され、<BR>
      curcntが２０になったときに２文字目が表示されます。<BR>
      <BR>
      cntarray[1]にcntarray[0]より小さな値を入れることも可能です。<BR>
      その場合は、２文字目は１文字目よりも後で<BR>
      表示されることになります。<BR>
      <BR>
      <BR>
      現バージョンでは半角カタカナには<BR>
      対応していません。<BR>
      <BR>\nで改行できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　fontid<BR>
      　　E3DCreateFontで作成した、フォントの番号を指定します。<BR>
      <BR>
      3. [IN] POINT　：　pos<BR>
      　　テキストをする位置を指定します。<BR>
      <BR>
      4. [IN] char*　：　textstr<BR>
      　　表示したい文字列を指定します。<BR>
      <BR>
      5. [IN] E3DCOLOR4UC　：　col<BR>
      　　文字の透明度と色を指定します。<BR>
      <BR>
      6. [IN] int*　：　cntarray<BR>
      　　文字数分の要素数を持つ配列変数を指定します。<BR>
      　　それぞれの要素には、文字の表示タイミングを指定します。<BR>
      <BR>
      7. [IN] int　：　arrayleng<BR>
      　　cntarray中の要素数を指定します。<BR>
      <BR>
      8. [IN] int　：　curcnt<BR>
      　　現在のカウンターを指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCharacterNum</TD>
      <TD class="hpb-cnt-tb-cell2">テキスト</TD>
      <TD class="hpb-cnt-tb-cell2">１バイト文字、２バイト文字を判別してtextstr中の文字数を取得します。<BR>
      <BR>
      現バージョンでは半角カタカナには<BR>
      対応していません。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　textstr<BR>
      　　調べたい文字列を指定します。<BR>
      <BR>
      2. [OUT] int*　：　charanumptr<BR>
      　　文字の数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyFont</TD>
      <TD class="hpb-cnt-tb-cell2">テキスト</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateFontで作成したフォントを<BR>
      削除します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　fontid<BR>
      　　E3DCreateFontで作成したフォントの番号を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSlerpQ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンを球面線形補間します。<BR>
      <BR>
      startqid, endqid, resqid には<BR>
      E3DCreateQ で取得したＩＤを渡してください。<BR>
      <BR>
      resqidで識別されるクォータニオンに<BR>
      startqid, endqidの間の姿勢を、<BR>
      t の比率に基づいて補間計算し<BR>
      セットします。<BR>
      <BR>
      t の値が0.0 から1.0の間になるように指定してください。<BR>
      <BR>
      t が0.0のときは<BR>
      startqidと同じ姿勢がセットされます。<BR>
      <BR>
      t が1.0のときは<BR>
      endqidと同じ姿勢がセットされます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　startqid<BR>
      2. [IN] int　：　endqid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      　　startqidとendqidのクォータニオンの間の姿勢を<BR>
      　　補間計算してresqidのクォータニオンにセットします。<BR>
      <BR>
      <BR>
      3. [IN] float　：　t<BR>
      　　補間計算するクォータニオンのstartqidからの比率を指定してください。<BR>
      　　t の値は0.0から1.0の間の値を指定してください。<BR>
      <BR>
      4. [IN] int　：　resqid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      　　計算結果がresqidのクォータニオンに代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSquadQ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンをスプライン補間します。<BR>
      <BR>
      befqid, startqid, endqid, aftqid, resqidには、<BR>
      E3DCreateQ で取得したＩＤを渡してください。<BR>
      <BR>
      resqidで識別されるクォータニオンに<BR>
      startqid, endqidの間の姿勢を<BR>
      t の比率に基づいて補間計算し<BR>
      セットします。<BR>
      <BR>
      befqidにはstartqidの一つ前の姿勢を、<BR>
      aftqidにはendqidの一つ後の姿勢を<BR>
      セットしておいてください。<BR>
      <BR>
      この関数は大きく姿勢が変化する場合には<BR>
      向いていません。<BR>
      大きく変化する姿勢を補完する場合には<BR>
      E3DSlerpQを使用してください。<BR>
      または、２つを組み合わせて使用してください。<BR>
      <BR>
      <BR>
      t の値が0.0 から1.0の間になるように指定してください。<BR>
      <BR>
      t が0.0のときは、<BR>
      startqidと同じ姿勢がセットされます。<BR>
      <BR>
      t が1.0のときは、<BR>
      endqidと同じ姿勢がセットされます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　befqid<BR>
      2. [IN] int　：　startqid<BR>
      3. [IN] int　：　endqid<BR>
      4. [IN] int　：　aftqid<BR>
      <BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      　　startqidとendqidのクォータニオンの間の姿勢を<BR>
      　　補間計算してresqidのクォータニオンにセットします。<BR>
      <BR>
      　　befqidにはstartqidの一つ前の姿勢を、<BR>
      　　aftqidにはendqidの一つ後の姿勢を<BR>
      　　セットしておいてください。<BR>
      <BR>
      5. [IN] float　：　t<BR>
      　　補間計算するクォータニオンのstartqidからの比率を指定してください。<BR>
      　　t の値は0.0から1.0の間の値を指定してください。<BR>
      <BR>
      <BR>
      6. [IN] int　：　resqid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      　　E3DCreateQで取得したidを渡してください。<BR>
      　　計算結果がresqidのクォータニオンに代入されます。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSplineVec</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">
      位置座標を、スプライン補間計算します。<BR>
      <BR>
      <BR>
      startposとendposの間の座標を<BR>
      tvの比率に基づいて<BR>
      スプライン補間計算して<BR>
      resposに代入します。<BR>
      <BR>
      befposにはstartposの一つ前の座標を、<BR>
      aftposにはendposの一つ後の座標を<BR>
      セットしておいてください。<BR>
      <BR>
      <BR>
      t の値が0.0 から1.0の間になるように指定してください。<BR>
      <BR>
      t が0.0のときは、<BR>
      startposと同じ位置がセットされます。<BR>
      <BR>
      t が1.0のときは、<BR>
      endposと同じ位置がセットされます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　befpos<BR>
      2. [IN] D3DXVECTOR3　：　startpos<BR>
      3. [IN] D3DXVECTOR3　：　endpos<BR>
      4. [IN] D3DXVECTOR3　：　aftpos<BR>
      　　計算の元となる位置座標の配列を指定してください。<BR>
      　　詳しくは、前記をご覧ください。<BR>
      <BR>
      5. [IN] float　：　t<BR>
      　　補間計算する位置座標のstartposからの比率を指定してください。<BR>
      　　t の値は0.0から1.0の間の値を指定してください。<BR>
      <BR>
      6. [OUT] D3DXVECTOR3*　：　resposptr<BR>
      　　計算結果が代入される配列を指定してください。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDbgOut</TD>
      <TD class="hpb-cnt-tb-cell2">デバッグ</TD>
      <TD class="hpb-cnt-tb-cell2">dbg.txtに、指定した文字列を出力します。<BR>
      <BR>
      この命令を呼ぶ前に、<BR>
      一回だけE3DEnableDbgFileを<BR>
      呼ぶ必要があります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　dbgstr<BR>
      　　出力文字列を指定してください。<BR>
      <BR>
      2. [IN] ... <BR>
      　　printf形式と同様に指定してください。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBillboardDiffuse</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">任意のビルボードの任意の頂点のdiffuse色を取得します。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bbid<BR>
      　　ビルボードを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　vertno<BR>
      　　色を取得したい頂点の番号を指定します。<BR>
      <BR>
      3. [OUT] E3DCOLOR4UC*　：　colptr<BR>
      　　　指定した頂点のdiffuse色が代入されます。<BR>
      　　　colptr-&gt;aは無視されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBillboardAmbient</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">任意のビルボードの任意の頂点の、ambient色を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bbid<BR>
      　　ビルボードを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　vertno<BR>
      　　色を取得したい頂点の番号を指定します。<BR>
      <BR>
      3. [OUT] E3DCOLOR4UC*　：　colptr<BR>
      　　　指定した頂点のambient色が代入されます。<BR>
      　　　colptr-&gt;aは無視されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBillboardSpecular</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">任意のビルボードの任意の頂点の、specular色を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bbid<BR>
      　　ビルボードを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　vertno<BR>
      　　色を取得したい頂点の番号を指定します。<BR>
      <BR>
      3. [OUT] E3DCOLOR4UC*　：　colptr<BR>
      　　　指定した頂点のspecular色が代入されます。<BR>
      　　　colptr-&gt;aは無視されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBillboardAlpha</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">任意のビルボードの透明度を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bbid<BR>
      　　ビルボードを識別するＩＤ<BR>
      　　-1を指定すると、ビルボードの色を取得できます。<BR>
      <BR>
      2. [IN] int　：　vertno<BR>
      　　この引数は、現在使用されていません。<BR>
      　　適当な数字を入れてください。<BR>
      <BR>
      3. [OUT] float*　：　alphaptr<BR>
      　　指定したパーツの透明度が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSaveQuaFile</TD>
      <TD class="hpb-cnt-tb-cell2">出力</TD>
      <TD class="hpb-cnt-tb-cell2">読み込み済みのモーションをファイルに保存します。<BR>
      <BR>
      quatype引数でファイルのタイプを指定します。<BR>
      usercoef.hで定義されているQUATYPE_ で始まる定数を使います。<BR>
      QUATYPE_NUMはボーンの階層構造から計算した番号を基準にファイルを作ります。<BR>
      QUATYPE_NAMEはボーンの名前を基準にファイルを作ります。<BR>
      <BR>
      ver5.0.1.0より前のバージョンのquaファイルはQUATYPE_NUMです。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] 数値または、変数　：　quatype<BR>
      　　QUATYPE_ で始まる定数を指定。<BR>
      <BR>
      2. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] char*　：　filename<BR>
      　　保存ファイル名（パス）を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.0.1.0で引数追加。<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSaveSigFile</TD>
      <TD class="hpb-cnt-tb-cell2">出力</TD>
      <TD class="hpb-cnt-tb-cell2">形状データをsigファイルに保存します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] char*　：　filename<BR>
      　　保存ファイル名（パス）を指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DPickVert</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">画面上の２Ｄ座標を指定して、その座標に一番近い頂点を検出する関数です。<BR>
      <BR>
      全く同じ座標の頂点が見つかった場合には、<BR>
      複数のパーツ、複数の頂点の番号を<BR>
      取得するするようになっています。<BR>
      同じ座標でもＵＶだけが違う頂点などが<BR>
      存在するので複数取得できるようになっています。<BR>
      <BR>
      取得した情報の数がgetnumに代入されます。<BR>
      該当するデータが無い場合はgetnumに０が<BR>
      代入されます。<BR>
      <BR>
      getnumが０出ない場合には、<BR>
      maxindex = getnum - 1とすると<BR>
      pickpartarray[0] から、pickpartarray[maxindex]<BR>
      までに、パーツの番号が代入されます。<BR>
      pickvertarray[0]から、pickvertarray[maxindex]<BR>
      までに、頂点の番号が代入されます。<BR>
      <BR>
      <BR>
      pickarrayleng変数に、<BR>
      一度に取得できる情報の数をセットした後、<BR>
      <B>pickpartarray</B><BR>
      <B>pickvertarray</B><BR>
      のメモリを確保してください。<BR>
      <BR>
      rangex, rangey引数を調整することで、<BR>
      検出の感度を調整できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      3. [IN] POINT　：　pos<BR>
      　　画面上の２Ｄ座標を指定します。<BR>
      <BR>
      4. [IN] POINT　：　range<BR>
      　　検出距離を指定します。<BR>
      　　range.xには、Ｘ座標がどれだけ離れた点まで検索するかを指定します。<BR>
      　　range.yには、Ｙ座標がどれだけ離れた点まで検索するかを指定します。<BR>
      　　大きい値を指定すると<BR>
      　　指定した座標より遠い頂点まで検索します。<BR>
      <BR>
      　　感度の調整に使用してください。<BR>
      <BR>
      5. [OUT] int*　：　pickpartarray<BR>
      6. [OUT] int*　：　pickvertarray<BR>
      　　指定した座標に一番近いパーツ番号、<BR>
      　　頂点の番号がgetnum個だけ代入されます。<BR>
      <BR>
      7. [IN] int　：　pickarrayleng<BR>
      　　pickpartarray, pickvertarrayの配列の大きさを指定してください。<BR>
      <BR>
      8. [OUT] int*　：　getnumptr<BR>
      　　pickpartarray, pickvertarrayに、何個の値を代入したかを<BR>
      　　取得できます。<BR>
      <BR>
      　　例えば、*getnumptr が３だった場合には、<BR>
      　　pickpartarray[0], pickpartarray[1], pickpartarray[2]に値が代入されています。<BR>
      　　</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetOrgVertNo</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">mqoファイル内での頂点番号を取得する。<BR>
      <BR>
      パーツ内の頂点の数は、E3DGetVertNumOfPartのvertnumで取得されます。<BR>
      <BR>
      E3Dのプログラムでは、頂点の番号に０から(vertnum - 1)の頂点の番号を使用できます。<BR>
      <BR>
      この頂点の番号は表示用の最適化をした後の頂点の番号で、<BR>
      rok, mqoファイル内での頂点の番号と異なる場合があります。<BR>
      <BR>
      この関数は最適化後の頂点番号に対応するrok,mqoファイル内での頂点の番号を取得します。<BR>
      <BR>
      mqoの場合は、<BR>
      mqoファイル中のパーツごとの頂点の出現順番を返します。（０から始まる数字）<BR>
      <BR>
      rokの場合は<BR>
      rokファイル中の１から始まる頂点のインデックスを返します。<BR>
      rokの場合はパーツごとの番号ではなくて、<BR>
      頂点全体を通しての番号ですので<BR>
      注意してください。<BR>
      <BR>
      <BR>
      指定した頂点と同じ座標を持つ頂点の番号が代入されるので、場合によっては複数取得されます。<BR>
      <BR>
      この関数はE3Dのプログラムからim2ファイルを作る際などに使用することを想定して作りました。<BR>
      <BR>
      地面データには使わないでください。<BR>
      <BR>
      <BR>
      この関数を使う前に、<BR>
      <B>E3DChkIM2Status関数で、引数に<BR>
      １が返されることを確認してください。</B><BR>
      ０が返された場合は、sigファイルを新しい形式にコンバートする必要があります。<BR>
      <BR>
      orgarraylengに取得できる情報の数をセットして、<BR>
      orgnoarray = (int*)malloc( sizeof( int ) * orgarrayleng );<BR>
      で、メモリを確保してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　取得したいパーツの番号を指定します。<BR>
      <BR>
      　　E3DGetPartNoByNameで取得した番号を渡してください。<BR>
      <BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　調べたい頂点の番号を指定してください。<BR>
      <BR>
      <BR>
      4. [OUT] int*　：　orgnoarray<BR>
      　　この配列に元データの頂点の番号が代入されます。<BR>
      　　maxindex = getnum - 1とすると<BR>
      　　*orgnoarray から、*(orgnoarray + maxindex)までに<BR>
      　　頂点の番号が代入されます。<BR>
      <BR>
      5. [IN] int　：　arrayleng<BR>
      　　orgnoarrayをmallocしたときの、配列の要素数を指定してください。<BR>
      <BR>
      <BR>
      6. [OUT] int*　：　getnumptr<BR>
      　　orgnoarrayに代入した情報の数を取得できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkIM2Status</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響</TD>
      <TD class="hpb-cnt-tb-cell2">影響マップ情報（im2）が、利用可能かどうかを調べます。<BR>
      <BR>
      status引数に１が返された場合は<BR>
      利用可能。<BR>
      ０が返された場合は<BR>
      利用不可能です。<BR>
      <BR>
      ０が返された場合はsigファイルを新しい形式にコンバートする必要があります。<BR>
      <BR>
      <BR>
      E3DGetOrgVertNo, E3DLoadIM2File,<BR>
      E3DSaveIM2File関数などを使用する前に、<BR>
      このE3DChkIM2Status関数で、<BR>
      影響マップファイルの機能が使えるかどうかを<BR>
      調べてください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      <BR>
      2. [OUT] int*　：　statusptr<BR>
      　　影響マップ情報が利用可能かどうかが代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadIM2File</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響</TD>
      <TD class="hpb-cnt-tb-cell2">hsidで識別されるモデルデータにim2ファイルのボーン影響情報をセットします。<BR>
      <BR>
      この関数を使う前に、<BR>
      <B>E3DChkIM2Status関数で引数に<BR>
      １が返されることを確認してください。</B><BR>
      ０が返された場合はsigファイルを新しい形式にコンバートする必要があります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　hsidで識別されるモデルデータに、<BR>
      　　im2ファイルのボーン影響情報をセットします。<BR>
      <BR>
      2. [IN] char*　：　fname<BR>
      　　*.im2 のパス文字列。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSaveIM2File</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響出力</TD>
      <TD class="hpb-cnt-tb-cell2">hsidで識別されるモデルデータの影響マップ情報をim2ファイルに書き出します。<BR>
      <BR>
      <BR>
      この関数を使う前に<BR>
      <B>E3DChkIM2Status関数で引数に<BR>
      １が返されることを確認してください。</B><BR>
      ０が返された場合はsigファイルを新しい形式にコンバートする必要があります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　hsidで識別されるモデルデータの影響マップ情報を、<BR>
      　　im2ファイルに書き出します。<BR>
      <BR>
      2. [IN] char*　：　fname<BR>
      　　*.im2 のパス文字列。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetJointNum</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ジョイントの総数を取得します。<BR>
      <BR>
      E3DGetJointInfoで詳細情報を取得する際の<BR>
      配列データの大きさの決定などに<BR>
      使用してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [OUT] int*　：　jointnumptr<BR>
      　　ジョイントの総数が、代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetJointInfo</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ジョイントの詳細情報を一括取得します。<BR>
      <BR>
      jointinfo引数は、<BR>
      jointinfo = (JOINTINFO*)malloc( sizeof( JOINTINFO * jointmaxnum );<BR>
      で作成してください。<BR>
      <BR>
      JOINTINFO構造体はusercoef.hで定義されています。<BR>
      <BR>
      serialnoは、<BR>
      ジョイントのシリアル番号にアクセスするときに、<BR>
      使用します。<BR>
      ジョイントのシリアル番号とは、<BR>
      E3DGetPartNoByName あるいは、<BR>
      E3DGetBoneNoByName　<BR>
      で取得できる番号と同じものです。<BR>
      <BR>
      notuseは、<BR>
      ジョイントが無効になっているかどうかの<BR>
      フラグにアクセスするときに使用します。<BR>
      無効なときに１が有効なときに０が代入されています。<BR>
      <BR>
      parent, child, brother, sisterは、<BR>
      ジョイントの階層構造にアクセスするときに<BR>
      使用します。<BR>
      詳しくは、<BR>
      <A href="e3dhsp_jointtree.htm">ジョイントの階層構造のページ</A><BR>
      をご覧ください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [OUT] JOINTINFO*　：　jointinfo<BR>
      　　シリアル番号や、階層構造などを取得するための構造体へのポインタを渡してください。<BR>
      <BR>
      3. [IN] int　：　jointmaxnum<BR>
      　　jointinfo構造体の要素数を渡してください。<BR>
      <BR>
      4. [OUT] int*　：　jointgetnum<BR>
      　　何個のジョイントの情報を出力したかが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetFirstJointNo</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">相対値０のジョイントの、シリアル番号を取得します。<BR>
      <BR>
      ジョイント番号の相対値とは<BR>
      ボーンファイルやim2ファイルなどで<BR>
      使用します。<BR>
      各ファイルの説明をご覧ください。<BR>
      <A href="rdb2_bonefile.htm">ボーンファイルのページ</A><BR>
      <A href="rdb2_im2file.htm">im2ファイルのページ</A><BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [OUT] int*　：　firstnoptr<BR>
      　　相対値０のシリアル番号が代入されます。<BR>
      　　</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetDispObjNum</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">表示用オブジェクトの総数を取得します。<BR>
      E3DGetDispObjInfoで詳細情報を取得する際の<BR>
      配列データの大きさの決定などに<BR>
      使用してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [OUT] int*　：　dispobjnumptr<BR>
      　　表示オブジェクトの総数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetDispObjInfo</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">表示オブジェクトの詳細情報を一括取得します。<BR>
      <BR>
      まず、dispobjmaxnum変数に、<BR>
      E3DGetDispObjInfo関数で、<BR>
      表示オブジェクトの総数を取得してください。<BR>
      <BR>
      dispobjinfo引数は、<BR>
      <B>dispobjinfo = (DISPOBJINFO*)malloc( sizeof( DISPOBJINFO ) * dispobjmaxnum
      );</B><BR>
      で作成してください。<BR>
      <BR>
      DISPOBJINFO構造体はusercoef.hで定義されています。<BR>
      <BR>
      serialnoは、<BR>
      表示オブジェクトのシリアル番号にアクセスするときに使用します。<BR>
      表示オブジェクトのシリアル番号とは、<BR>
      E3DGetPartNoByName　<BR>
      で取得できる番号と同じものです。<BR>
      <BR>
      notuseは、<BR>
      表示オブジェクトが無効になっているかどうかの<BR>
      フラグにアクセスするときに使用します。<BR>
      無効なときに１が有効なときに０が代入されています。<BR>
      <BR>
      dispswitchは、<BR>
      表示オブジェクトのディスプレイスイッチの番号<BR>
      にアクセスするときに使用します。<BR>
      ディスプレイスイッチは、<BR>
      RokDeBone2で、パーツごとに設定可能です。<BR>
      <A href="rdb2_dispswitch.htm">ディスプレイスイッチのページ<BR>
      <BR>
      </A><BR>
      invisibleは、<BR>
      表示オブジェクトが表示されているかどうかのフラグにアクセスするときに使用します。<BR>
      詳しくは、<BR>
      E3DSetInvisibleFlag<BR>
      の説明をお読みください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [OUT] DISPOBJINFO*　：　dispobjinfo<BR>
      　　シリアル番号などを取得するための配列変数を渡してください。<BR>
      <BR>
      <BR>
      3. [IN] int　：　dispobjmaxnum<BR>
      　　データ取得用配列の大きさ（表示オブジェクトの数）を指定します。<BR>
      <BR>
      4. [OUT] int*　：　dispobjgetnumptr<BR>
      　　何個の表示オブジェクトの情報を出力したかが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DEnableTexture</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">一時的にテクスチャー表示をオンオフする関数です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号（シリアル番号）<BR>
      <BR>
      3. [IN] int　：　enableflag<BR>
      　　テクスチャーをオフにするときには０を、<BR>
      　　オンにするときには１を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DJointAddToTree</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">パーツに親子関係を設定します。<BR>
      childjointをparentjointの子供として、<BR>
      設定します。<BR>
      <BR>
      lastflagが０のときは長男として追加され、<BR>
      １のときは末っ子として追加されます。<BR>
      <BR>
      ジョイント以外に親子関係を設定しても<BR>
      現バージョンでは意味がありません。<BR>
      <BR>
      childjoint, parentjointは、<BR>
      E3DGetPratNoByNameまたは<BR>
      E3DGetJointInfoで取得した番号を<BR>
      使用してください。<BR>
      <BR>
      E3DJointRemake命令もお読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別する番号<BR>
      <BR>
      2. [IN] int　：　parentjoint<BR>
      3. [IN] int　：　childjoint<BR>
      　　parentjointの子供としてchildjointを設定します。<BR>
      <BR>
      4. [IN] int　：　lastflag<BR>
      　　０を指定するとparentjointの長男として、<BR>
      　　１を指定するとparentjointの末っ子として設定されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DJointRemoveFromParent</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">パーツの親子関係を取り除きます。<BR>
      <BR>
      rmjointで指定したパーツと<BR>
      その親のパーツとの関係を切り離します。<BR>
      <BR>
      rmjointの子供の情報はそのまま残ります。<BR>
      <BR>
      ジョイント以外に親子関係を設定しても<BR>
      現バージョンでは意味がありません。<BR>
      <BR>
      <BR>
      この命令で親が存在しないまま<BR>
      E3DSaveSigFileでファイルに保存すると、<BR>
      そのファイルは読み込みできなくなります。<BR>
      <BR>
      最終的にはE3DJointAddToTreeで、<BR>
      必ず親を設定するようにしてください。<BR>
      <BR>
      一番親のジョイントにしたい場合には、<BR>
      ジョイントではないフォルダ的な役割をしているパーツの番号を取得して<BR>
      それを親に設定してください。<BR>
      <BR>
      <BR>
      rmjointは、<BR>
      E3DGetPratNoByNameまたは、<BR>
      E3DGetJointInfoで取得した番号を<BR>
      使用してください。<BR>
      <BR>
      E3DJointRemake命令もお読みください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別する番号<BR>
      <BR>
      2. [IN] int　：　rmjoint<BR>
      　　rmjointとその親の関係を切り離します。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DJointRemake</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">親子関係や有効無効の変更をEasy3D内部の関連データに反映させます。<BR>
      <BR>
      一連のE3DJointAddToTreeや<BR>
      E3DJointRemoveFromParent命令や<BR>
      E3DSetValidFlagを<BR>
      呼び出した後に一回呼び出してください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別する番号<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSigImport</TD>
      <TD class="hpb-cnt-tb-cell2">形状データ</TD>
      <TD class="hpb-cnt-tb-cell2">hsidに読み込み済の形状データに<BR>
      filenameで指定した形状データを<BR>
      インポートします。<BR>
      <BR>
      <U><B>この命令を呼ぶと<BR>
      読み込み済のモーションデータが破棄されます。<BR>
      <BR>
      </B></U></TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別する番号<BR>
      <BR>
      2. [IN] char*　：　filename<BR>
      　　インポートする*.sig のパス文字列。<BR>
      <BR>
      3. [IN] int　：　adjustuvflag<BR>
      　　ＵＶ値を正規化するかどうかのフラグ。<BR>
      　　正規化する場合は１を指定。<BR>
      　　しない場合は０を指定。<BR>
      　　２を指定すると0.0から1.0の間にクランプします。<BR>
<BR>
      <BR>
      4. [IN] float　：　mult<BR>
      　　倍率の値を指定してください。<BR>
      　　等倍は、１．０。<BR>
      <BR>
      5. [IN] D3DXVECTOR3　：　offset<BR>
      　　読み込み位置のオフセット座標を指定します。<BR>
      　　ローカル座標で指定します。<BR>
      <BR>
      6. [IN] D3DXVECTOR3　：　rot<BR>
      　　追加形状を、Ｘ，Ｙ，Ｚそれぞれの軸に対して、<BR>
      　　rot.x, rot.y, rot.z度だけ、回転してから<BR>
      　　インポートを行います。<BR>
      　　回転順序はＺ，Ｙ，Ｘの順番です。<BR>
      <BR>
      パラメータの適用順序は、<BR>
      まず倍率を掛けて<BR>
      次に回転をして<BR>
      最後に移動します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>ver5.0.2.6で拡張<BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSigLoadFromBuf</TD>
      <TD class="hpb-cnt-tb-cell2">形状データ</TD>
      <TD class="hpb-cnt-tb-cell2">メモリから形状データのロードを行います。<BR>
      メモリ内にはsigファイルと同じフォーマットが<BR>
      入っているとみなして処理します。<BR>
      <BR>
      テクスチャファイルは通常読込と同様に<BR>
      ファイルから行います。<BR>
      <BR>
      resdirにはテクスチャの存在するフォルダのパスを指定してください。<BR>
      <B>最後に&quot;\\&quot;を付けるのを忘れないでください。</B><BR>
      <BR>
      例えば、<BR>
      &quot;C:\\hsp\\Meida\\&quot;<BR>
      <BR>
      などのように指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　resdir<BR>
      　　テクスチャーのあるフォルダ のパス文字列。<BR>
      　　最後に、&quot;\\&quot;が必要。<BR>
      <BR>
      2. [IN] char*　：　buf<BR>
      　　バッファのポインタ。<BR>
      <BR>
      3. [IN] int　：　bufleng<BR>
      　　バッファの中のデータの長さ<BR>
      <BR>
      4. [IN] int　：　adjustuvflag<BR>
      　　ＵＶ値を正規化するかどうかのフラグ。<BR>
      　　正規化する場合は１を指定。<BR>
      　　しない場合は０を指定。<BR>
      　　２を指定すると0.0から1.0の間にクランプします。<BR>
      <BR>
      5. [IN] float　：　mult<BR>
      　　倍率の値を指定してください。<BR>
      　　等倍は１．０。<BR>
      <BR>
      6. [OUT] int　：　hsidptr<BR>
      　　読み込んだ形状データを識別するhsidが代入されます。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>ver5.0.2.6で拡張<BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSigImportFromBuf</TD>
      <TD class="hpb-cnt-tb-cell2">形状データ</TD>
      <TD class="hpb-cnt-tb-cell2">メモリから形状データのインポートを行います。<BR>
      メモリ内にはsigファイルと同じフォーマットが<BR>
      入っているとみなして処理します。<BR>
      <BR>
      テクスチャファイルは通常読込と同様に<BR>
      ファイルから行います。<BR>
      <BR>
      resdirにはテクスチャの存在するフォルダのパスを指定してください。<BR>
      <B>最後に&quot;\\&quot;を付けるのを忘れないでください。</B><BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するhsid<BR>
      <BR>
      2. [IN] char*　：　resdir<BR>
      　　テクスチャーのあるフォルダ のパス文字列。<BR>
      　　最後に&quot;\\&quot;が必要。<BR>
      <BR>
      3. [IN] char*　：　buf<BR>
      　　バッファのポインタ<BR>
      <BR>
      4. [IN] int　：　bufleng<BR>
      　　バッファの中のデータの長さ<BR>
      <BR>
      <BR>
      5. [IN] int　：　adjustuvflag<BR>
      　　ＵＶ値を正規化するかどうかのフラグ。<BR>
      　　正規化する場合は１を指定。<BR>
      　　しない場合は０を指定。<BR>
      　　２を指定すると0.0から1.0の間にクランプします。<BR>
<BR>
<BR>
      <BR>
      6. [IN] float　：　mult<BR>
      　　倍率の値を指定してください。<BR>
      　　等倍は１．０。<BR>
      <BR>
      7. [IN] D3DXVECTOR3　：　offset<BR>
      　　読み込み位置のオフセット座標を指定します。<BR>
      　　ローカル座標で指定します。<BR>
      <BR>
      8. [IN] 変数または、数値　：　rot<BR>
      　　追加形状を、Ｘ，Ｙ，Ｚそれぞれの軸に対して、<BR>
      　　rotx, roty, rotz度だけ回転してから、<BR>
      　　インポートを行います。<BR>
      　　回転順序は、Ｚ，Ｙ，Ｘの順番です。<BR>
      　<BR>
      パラメータの適用順序は、<BR>
      まず倍率を掛けて、<BR>
      次に回転をして、<BR>
      最後に移動します。<BR>
<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>ver5.0.2.6で拡張<BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DAddMotionFromBuf</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">メモリからモーションデータのロードを行います。<BR>
      メモリ内にはquaファイルと<BR>
      同じフォーマットが入っているとみなして<BR>
      処理します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するhsid<BR>
      <BR>
      2. [IN] char*　：　buf<BR>
      　　バッファのポインタ<BR>
      <BR>
      3. [IN] int　：　bufleng<BR>
      　　バッファの中のデータの長さ<BR>
      <BR>
      4. [IN] float　：　mvmult<BR>
      　　モーションの移動成分に掛ける倍率<BR>
      <BR>
      5. [OUT] int*　：　motidptr<BR>
      　　読み込んだモーションを識別する番号<BR>
      <BR>
      6. [OUT] int*　：　maxframeptr<BR>
      　　読み込んだモーションの最大フレーム番号<BR>
      　　（総フレーム数 - 1 と同じ）<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCheckFullScreenParams</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">フルスクリーンのパラメータをチェックし、与えた条件に近いパラメータを取得します。<BR>
      <BR>
      validflagに１が返された場合のみ、<BR>
      bits, scsizeの値は有効です。<BR>
      <BR>
      validflagに０が返された場合には、<BR>
      ウインドウの大きさなどの条件を変えて、<BR>
      有効なパラメータが取得できるまで<BR>
      繰り返しこの命令を呼び出してください。<BR>
<BR>
      この命令はE3DInitよりも前に呼ぶことを前提にしています。<BR>
      <BR>
      この命令で取得したscsize.cxとscsize.cyでウインドウを作成した後、<BR>
      E3DInitのbits引数にvalidbitsを指定してフルスクリーン初期化してください。<BR>
      <BR>
      FULLSCPARAMS構造体はusercoef.hで定義されています。<BR>
      <BR>
      ver5.3.1.3でflag引数を追加。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] FULLSCPARAMS　：　srcparams<BR>
      　　使用したいフルスクリーンのパラメータを指定します。<BR>
      　　screenwにスクリーンの幅<BR>
      　　screenhにスクリーンの高さ<BR>
      　　bitsに色数を示すビット数を指定します。<BR>
      <BR>
      2. [OUT] FULLSCPARAMS*　：　validparamsptr<BR>
      　　scparamsで指定したパラメータに近い<BR>
      　　フルスクリーンが作れることが分かった場合にvalidparamsptr-&gt;validflagに<BR>
      　　１がセットされます。<BR>
      <BR>
      　　与えられたパラメータではフルスクリーンが作れないことが分かった場合にはvalidparamsptr-&gt;validflagに０がセットされます。<BR>
      <BR>
      validparamsのbits, scsize.cx, scsize.cyにはフルスクリーンの作成に有効なパラメータが返されます。<BR>
      　　srcparamsで指定したものとは<BR>
      　　多少異なる場合があります。<BR>
      <BR>
      　　これらの値は、validparamsptr-&gt;validflagに１が代入されているときのみ有効です。<BR>
      <BR>
      3. [IN] int　：　flag<BR>
      　　横：縦が４：３のウインドウサイズに自動的に調整したい場合は１を指定します。<BR>
      　　調整機能をオフにしてscreenw, screenh引数そのままの値で判定するには２を指定します。<BR>
      　　デフォルト値は１です。<BR>
      　　flagに２を指定した場合はE3DInitのfullscreenflagにも２を指定してください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.3.1.3で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaxMultiSampleNum</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">アンチエイリアスに必要なマルチサンプルの数の最大値を取得します。<BR>
      <BR>
      この関数はE3DInitよりも前に呼び出すことを<BR>
      想定しています。<BR>
      <BR>
      E3DInitに渡すmultisamplenumの値の決定に<BR>
      使用してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bits<BR>
      　　色数を決めるビット数を指定してください。<BR>
      <BR>
      2. [IN] int　：　iswindowmode<BR>
      　　ウインドウモードの時は１を<BR>
      　　フルスクリーンの時は０を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　maxmultisamplenumptr<BR>
      　　マルチサンプルの数の指定に有効な最大の値を代入します。<BR>
      　　０または、２から１６の値が代入されます。<BR>
      　　ハードウェアによって異なる値が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConfLineAndFace</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">任意の線分とsigの面との当たり判定をします。<BR>
      <BR>
      この当たり判定は<BR>
      hsidで指定したデータのボーン変形が<BR>
      必要になります。<BR>
      <BR>
      ですが、同じポーズで何回も当たり判定を行う場合などには、いちいちボーン変形を計算し直さない方が高速です。<BR>
      needtransに０を指定すると<BR>
      ボーン変形計算を省略することが出来ます。<BR>
      （ポーズが変わった場合や<BR>
      カメラ位置を変えた場合には<BR>
      needtransを１にしてください。）<BR>
      <BR>
      <BR>
      線分と面との当たりE3DChkConfLineAndFaceは、結構重い処理です。<BR>
      ですので、出来るだけ呼び出し回数を<BR>
      少なくするように心がけてください。<BR>
      呼び出し回数を少なくするための工夫として、<BR>
      まず、E3DChkConflictで<BR>
      おおざっぱな当たり判定を行い<BR>
      E3DChkConflictで当たっていると判定されたときのみ<BR>
      E3DChkConfLineAndFaceを呼び出す<BR>
      などの方法が有効です。<BR>
      <BR>
      <U>E3DChkInViewより後で呼び出してください。</U><BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　pos1<BR>
      2. [IN] D3DXVECTOR3　：　pos2<BR>
      <BR>
      線分をpos1とpos2で指定してください。<BR>
      <BR>
      3. [IN] int　：　hsid<BR>
      　　モデルデータを識別するＩＤ<BR>
      <BR>
      4. [IN] int　：　needtrans<BR>
      　　ボーン変形計算をするかどうかのフラグ<BR>
      　　詳しくは、前記をご覧ください。<BR>
      <BR>
      5. [OUT] int*　：　partnoptr<BR>
      6. [OUT] int*　：　facenoptr<BR>
      　　線分とhsidのモデルが衝突していた場合に、<BR>
      　　衝突したパーツの番号と面の番号が代入されます。<BR>
      　　衝突していなかった場合は-1が代入されます。<BR>
      <BR>
      7. [OUT] D3DXVECTOR3*　：　confpos<BR>
      　　衝突していた場合に、衝突した座標が代入されます。<BR>
      <BR>
      8. [OUT] D3DXVECTOR3*　：　nptr<BR>
      　　衝突していた場合に、衝突したhsidの面の法線ベクトルが代入されます。<BR>
      <BR>
      9. [OUT] int*　：　revfaceflagptr<BR>
      　　衝突していた面が裏面だった場合１が代入されます。<BR>
      　　表面だった場合は０が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DPickFace</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">２Ｄの画面の座標に対応する３Ｄモデルの座標を取得できます。<BR>
      <BR>
      マウスでクリックした場所に<BR>
      ３Ｄオブジェクトを移動させることなどに使用してください。<BR>
      <BR>
      E3DPickVertが３Ｄモデルの頂点を抽出するのに対し、<BR>
      E3DPickFaceは３Ｄモデルの面を抽出し<BR>
      ２Ｄ座標に対応する面上の３Ｄ座標を取得します。<BR>
      <BR>
      maxdist によってどのくらい遠くまで<BR>
      検索するかを指定できます。<BR>
      maxdistの値を小さくするほど<BR>
      処理は高速になります。<BR>
      <BR>
      <BR>
      <BR>
      <B>計算には、E3DChkInViewの結果を<BR>
      使用しています。<BR>
      </B><BR>
      ！！！注意！！！<BR>
      projectionのnearからの距離が10万を超えるデータにはこの命令は使えません。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      <BR>
      3. [IN] POINT　：　scpos<BR>
      　　画面上の２Ｄ座標を指定してください。<BR>
      <BR>
      4. [IN] float　：　maxdist<BR>
      　　どのくらいの距離まで３Ｄモデルの検索をするかを指定します。<BR>
      　　この値を小さくするほど処理は高速になります。<BR>
      <BR>
      5. [OUT] int*　：　partnoptr<BR>
      6. [OUT] int*　：　facenoptr<BR>
      　　2D座標に対応する３Ｄ座標が見つかった場合に、<BR>
      　　その３Ｄモデルのパーツの番号と面の番号が<BR>
      　　代入されます。<BR>
      <BR>
      　　見つからなかった場合は-1が代入されます。<BR>
      <BR>
      7. [OUT] D3DXVECTOR3*　：　pos3dptr<BR>
      　　２Ｄ座標に対応する３Ｄ座標が代入されます。<BR>
      　　partnoに-1以外の値が代入されているときのみこの値は意味を持ちます。<BR>
      <BR>
      8. [OUT] D3DXVECTOR3*　：　nptr<BR>
      　　2D座標に対応する３Ｄ座標を含む面の法線ベクトルが代入されます。<BR>
      <BR>
      　　ベクトルの大きさは１のものを代入します。<BR>
      <BR>
      　　partnoに-1以外の値が代入されているときのみ、<BR>
      　　この値は意味を持ちます。<BR>
      <BR>
      <BR>
      9. [OUT] float*　：　distptr<BR>
      　　視点と*pos3dptrとの距離が代入されます。<BR>
      　　partnoに-1以外の値が代入されているときのみ、<BR>
      　　この値は意味を持ちます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBBox</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">読み込んだモデルデータのバウンダリーボックスの取得が出来ます。<BR>
      <BR>
      カメラの設定やプロジェクションの設定をモデルの大きさに応じて変更する場合などに使ってください。<BR>
      <BR>
      mode引数で<BR>
      ローカル座標かグローバル座標かを<BR>
      指定できるようにする予定です。<BR>
      現在は、グローバル座標しか取得できません。<BR>
      <BR>
      この命令で使用する情報はE3DChkInViewで更新されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      　　ビルボードの情報を得たい場合は-1を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      　　-1を指定した場合は、モデル全体のバウンダリーボックスを取得します。<BR>
      <BR>
      　　hsidに-1を指定した場合は<BR>
      　　ビルボードのIDを指定してください。<BR>
      <BR>
      <BR>
      3. [IN] int　：　mode<BR>
      　　現在はサポートされていません。<BR>
      　　０を指定してください。<BR>
      <BR>
      4. [OUT] D3DXVECTOR3*　：　minptr<BR>
      5. [OUT] D3DXVECTOR3*　：　maxptr<BR>
      　　各座標の最小値の点を*minptrに<BR>
      　　最大値の点を*maxptrに代入します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetVertNoOfFace</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2"> facenoで指定した面に含まれる頂点の番号を３つ取得します。（３角形の頂点です）<BR>
      <BR>
      facenoにはE3DPickFaceなどで取得した<BR>
      面の番号を指定してください。<BR>
      <BR>
      E3DGetSamePosVertの説明も<BR>
      お読みください。<BR>
      <BR>
      TRIVNO構造体はusercoef.hで定義されています。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　faceno<BR>
      　　面を識別する番号を指定してください。<BR>
      <BR>
      4. [OUT] TRIVNO*　：　vertnoptr<BR>
      　　３角形の面を構成する３つの頂点の番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSamePosVert</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">同じ位置の頂点番号を取得する。<BR>
      <BR>
      モデルデータ中には同じ頂点座標で、<BR>
      ＵＶ座標だけ違う頂点が存在します。<BR>
      <BR>
      同じ位置の頂点の番号を取得する関数です。<BR>
      E3DGetVertNoOfFaceと組み合わせて<BR>
      使うことを想定しています。<BR>
      <BR>
      samevertno には見つかった頂点数分の<BR>
      頂点番号が代入されます。<BR>
      <BR>
      arraylengに５くらいの値を入れて、<BR>
      int samevertno[ arrayleng ];<BR>
      で配列を作成してください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　頂点を識別する番号を指定してください。<BR>
      <BR>
      4. [OUT] int*　：　samevertno<BR>
      　　配列を指定してください。<BR>
      　　見つかった頂点の番号が代入されます。<BR>
      <BR>
      5. [IN] int　：　arrayleng<BR>
      　　samevertno配列を作成したときの要素数を指定してください。<BR>
      <BR>
      6. [OUT] int*　：　samenumptr<BR>
      　　見つかった頂点の数が代入されます。<BR>
      　　つまり、maxindex = samenum - 1とすると<BR>
      　　samevertno[0] から　samevertno[maxindex]<BR>
      　　まで見つかった頂点の番号が代入されていることになります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRtscStart</TD>
      <TD class="hpb-cnt-tb-cell2">同期</TD>
      <TD class="hpb-cnt-tb-cell2">時間の計測。<BR>
      <BR>
      E3DRtscStartとE3DRtscStopはセットで使用します。<BR>
      <BR>
      E3DRtscStartを呼び出してから<BR>
      E3DRtscStopを呼び出すまでに<BR>
      プロセッサのタイムスタンプカウンタが<BR>
      どれくらい増えたかを取得できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">なし</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRtscStop</TD>
      <TD class="hpb-cnt-tb-cell2">同期</TD>
      <TD class="hpb-cnt-tb-cell2">時間の計測。<BR>
      <BR>
      E3DRtscStartとE3DRtscStopはセットで使用します。<BR>
      <BR>
      E3DRtscStartを呼び出してから<BR>
      E3DRtscStopを呼び出すまでに<BR>
      プロセッサのタイムスタンプカウンタが<BR>
      どれくらい増えたかを取得できます。<BR>
      <BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] DWORD*　：　timeptr<BR>
      　　E3DRtscStartを呼んでからの<BR>
      　　タイムスタンプカウンタの増分が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSaveSig2Buf</TD>
      <TD class="hpb-cnt-tb-cell2">モデル出力</TD>
      <TD class="hpb-cnt-tb-cell2">読み込み済の形状データをメモリ上に保存します。<BR>
      <BR>
      保存するためのバッファは<BR>
      ユーザーさん側が用意します。<BR>
      <BR>
      バッファの長さが分からないと<BR>
      保存操作が行えないため、<BR>
      <B><U>バッファ長の取得と実際の保存とで、<BR>
      合計２回、この関数を呼び出してください。</U></B><BR>
      <BR>
      bufsize引数に０を指定すると、<BR>
      保存を行わずに<BR>
      保存に必要なバッファの長さを取得します。<BR>
      <BR>
      バッファの長さを取得した後に、<BR>
      その長さをbufsize引数に指定して<BR>
      実際の保存を行ってください。<BR>
      <BR>
      <BR>
      実際のコードは、以下のようになります。<BR>
      <BR>
      E3DSaveSig2Buf( hsid, 0, 0, sigwritesize );<BR>
      <BR>
      sigbuf = (char*)malloc( sizeof( char ) * sigwritesize );<BR>
      <BR>
      E3DSaveSig2Buf( hsid2, sigbuf, sigwritesize, &amp;writesize1 );<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] char*　：　buf<BR>
      　　バッファのポインタを指定してください。<BR>
      <BR>
      3. [IN] int　：　bufsize<BR>
      　　０を指定すると、<BR>
      　　保存に必要なバッファの長さが、writesizeに代入されます。<BR>
      　　０以外を指定すると、<BR>
      　　バッファbufに形状データを保存します。<BR>
      <BR>
      4. [OUT] int*　：　writesizeptr<BR>
      　　bufsizeに０が指定されている場合には<BR>
      　　必要なバッファのサイズが代入されます。<BR>
      <BR>
      　　bufsizeに０以外が指定されている場合には、<BR>
      　　実際に保存したデータのバイト数を代入します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSaveQua2Buf</TD>
      <TD class="hpb-cnt-tb-cell2">モーション出力</TD>
      <TD class="hpb-cnt-tb-cell2">読み込み済のモーションデータをメモリ上に保存します。<BR>
      <BR>
      保存するためのバッファは<BR>
      ユーザーさん側が用意します。<BR>
      <BR>
      バッファの長さが分からないと<BR>
      保存操作が行えないため、<BR>
      <B><U>バッファ長の取得と実際の保存とで<BR>
      合計２回、この関数を呼び出してください。</U></B><BR>
      <BR>
      bufsize引数に０を指定すると、<BR>
      保存を行わずに<BR>
      保存に必要なバッファの長さを取得します。<BR>
      <BR>
      バッファの長さを取得した後に<BR>
      その長さをbufsize引数に指定して<BR>
      実際の保存を行ってください。<BR>
      <BR>
      <BR>
      実際のコードは以下のようになります。<BR>
      <BR>
      <BR>
      E3DSaveQua2Buf( quatype, hsid, mkid, 0, 0, &amp;quawritesize, quatype );<BR>
      <BR>
      quabuf = (char*)malloc( sizeof( char ) * quawritesize );<BR>
      <BR>
      E3DSaveQua2Buf( quatype, hsid, mkid, quabuf, quawritesize, &amp;writesize2
      );<BR>
      <BR>      quatype引数でファイルのタイプを指定します。<BR>
      usercoef.hで定義されているQUATYPE_ で始まる定数を使います。<BR>
      QUATYPE_NUMはボーンの階層構造から計算した番号を基準にファイルを作ります。<BR>
      QUATYPE_NAMEはボーンの名前を基準にファイルを作ります。<BR>
      <BR>
      ver5.0.1.0より前のバージョンのquaファイルはQUATYPE_NUMです。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] 数値または、変数　：　quatype<BR>
      　　QUATYPE_ で始まる定数を指定。<BR>
      <BR>
      2. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] char*　：　buf<BR>
      　　バッファの変数を指定してください。<BR>
      <BR>
      5. [IN] int　：　bufsize<BR>
      　　０を指定すると<BR>
      　　保存に必要なバッファの長さがwritesizeに代入されます。<BR>
      　　０以外を指定すると、<BR>
      　　バッファbufに、モーションデータを保存します。<BR>
      <BR>
      6. [OUT] int*　：　writesize<BR>
      　　bufsizeに０が指定されている場合には<BR>
      　　必要なバッファのサイズが代入されます。<BR>
      <BR>
      　　bufsizeに０以外が指定されている場合には、<BR>
      　　実際に保存したデータのバイト数を代入します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.0.1.0で引数追加。<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCameraShiftLeft</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラを左に平行移動します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　shift<BR>
      　　移動量。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCameraShiftRight</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラを右に平行移動します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　shift<BR>
      　　移動量。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCameraShiftUp</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラを上に平行移動します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　shift<BR>
      　　移動量。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCameraShiftDown</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラを下に平行移動します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　shift<BR>
      　　移動量。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCameraQ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラの回転変換を表すクォータニオンを<BR>
      取得します。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンのＩＤを渡してください。<BR>
      　　qidで識別されるクォータニオンに、<BR>
      　　カメラの回転情報を代入します。<BR>
      <BR>
      　　qidにはE3DCreateQで取得したＩＤを使用してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DInvQ</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">逆クォータニオンを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　srcqid<BR>
      2. [IN] int　：　dstqid<BR>
      　　クォータニオンのＩＤを渡してください。<BR>
      　　dstqidで識別されるクォータニオンに、<BR>
      　　srcqidで識別されるクォータニオンの逆クォータニオンを代入します。<BR>
      <BR>
      　　srcqid, dstqidには、<BR>
      　　E3DCreateQで取得したＩＤを使用してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetCameraTwist</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラをツイスト（ロール）させます。<BR>
      <BR>
      カメラの使い方は、この表の前に書いてある部分をお読みください。<BR>
      <BR>
      E3DSetCameraTwistはどのタイプのカメラ関数を使用している場合でも有効です。<BR>
      <BR>
      E3DSetCameraTargetを使用している場合には、<BR>
      E3DSetCameraTargetで指定した上方向のベクトルをさらにtwistdeg分ねじります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　twistdeg<BR>
      　　カメラをtwistdeg度だけ、ツイストします。<BR>
      　</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DIKRotateBeta</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">ＩＫによるジョイントの回転を行います。<BR>
      目標の座標などを指定すると、<BR>
      そこに近づくように回転します。<BR>
      <BR>
      <B><U>この関数はベータ版です。<BR>
      今後のバージョンアップで<BR>
      互換性のとれない変更をする場合がありますのでご注意ください。</U></B><BR>
      <BR>
      この関数では指定したモーションの1フレーム分の姿勢情報しか変更しません。<BR>
      モーション全体にＩＫ結果を反映させたい場合は、<BR>
      ＩＫ計算した前後のキーフレーム間で<BR>
      E3DFillUpMotionを呼び出す必要があります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　jointno<BR>
      　　ジョイントパーツを識別する番号を指定してください。<BR>
      　　E3DGetPartNoByNameなどで取得した値や、<BR>
      　　E3DGetJointInfoで取得したシリアル番号を指定してください。<BR>
      　　<B>ジョイント以外のパーツの番号を指定するとエラーになります。</B><BR>
      　　<BR>
      4. [IN] int　：　motionid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      5. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定してください。<BR>
      <BR>
      6. [IN] int　：　iklevel<BR>
      　　ＩＫ計算時の階層数を指定します。<BR>
      　　何階層、親をさかのぼってＩＫ計算するかを指定します。<BR>
      <BR>
      7. [IN] int　：　axiskind<BR>
      　　IKの回転の際の軸をどのように決定するかを指定します。<BR>
      　　０の時は視線に平行なベクトルを使います。<BR>
      　　１の時はaxis.x, axis.y, axis.zに指定した軸を使います。<BR>
      　　2の時は自動的に軸を設定します。<BR>
      　　<BR>
      8. [IN] D3DXVECTOR3　：　axis<BR>
      　　IKの回転軸を指定します。<BR>
      　　axiskindに１を指定したときのみ有効です。<BR>
      <BR>
      9. [IN] int　：　calclevel<BR>
      　　計算の細かさを指定します。<BR>
      　　正の整数を指定してください。<BR>
      　　値が大きいほど細かく動きますが、<BR>
      　　現バージョンでは、大きすぎても、うまくいきません。<BR>
      <BR>
      10. [IN] D3DXVECTOR3　：　target<BR>
      　　jointnoで指定したジョイントが、<BR>
      　　座標（targetx, targety, targetz）に近づくように回転します。　<BR>
      <BR>
      11. [OUT] D3DXVECTOR3*　：　resptr<BR>
      　　jointnoで指定したジョイントの計算後の座標が代入されます。<BR>
      <BR>
      12. [OUT] int*　：　lastparentptr<BR>
      　　姿勢の変更のあったボーンのうち、<BR>
      　　一番親の番号が代入されます。<BR>
      　　この値をE3DRenderに渡すと処理の高速化が出来ます。<BR>
      　　詳しくはE3DRenderのところの注意事項をお読みください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DIKRotateBeta2D</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">E3DIKRotateBetaの２Ｄ座標指定バージョンです。<BR>
      <BR>
      目標座標が２Ｄになった以外は<BR>
      E3DIKRotateBetaと同じです。<BR>
      詳しくは、E3DIKRotateBetaの説明を<BR>
      お読みください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　jointno<BR>
      　　ジョイントパーツを識別する番号を指定してください。<BR>
      　　E3DGetPartNoByNameなどで取得した値や、<BR>
      　　E3DGetJointInfoで取得したシリアル番号を指定してください。<BR>
      　　<B>ジョイント以外のパーツの番号を指定するとエラーになります。</B><BR>
      　　<BR>
      4. [IN] int　：　motionid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      5. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定してください。<BR>
      <BR>
      6. [IN] int　：　iklevel<BR>
      　　ＩＫ計算時の階層数を指定します。<BR>
      　　何階層親をさかのぼってＩＫ計算するかを指定します。<BR>
      <BR>
      7. [IN] int　：　axiskind<BR>
      　　IKの回転の際の軸をどのように決定するかを指定します。<BR>
      　　０の時は、視線に平行なベクトルを使います。<BR>
      　　１の時は、axis.x, axis.y, axis.zに指定した軸を使います。<BR>
      　　2の時は、自動的に軸を設定します。<BR>
      　　<BR>
      8. [IN] D3DXVECTOR3　：　axis<BR>
      　　IKの回転軸を指定します。<BR>
      　　axiskindに１を指定したときのみ有効です。<BR>
      <BR>
      9. [IN] int　：　calclevel<BR>
      　　計算の細かさを指定します。<BR>
      　　正の整数を指定してください。<BR>
      　　値が大きいほど細かく動きますが、<BR>
      　　現バージョンでは、大きすぎても、うまくいきません。<BR>
      <BR>
      10. [IN] D3DXVECTOR2　：　target2d<BR>
      　　jointnoで指定したジョイントが、<BR>
      　　指定した２Ｄ座標に近づくように回転します。<BR>
      <BR>
      11. [OUT] D3DXVECTOR3*　：　resptr<BR>
      　　jointnoで指定したジョイントの計算後の座標が代入されます。<BR>
      <BR>
      12. [OUT] int*　：　lastparentptr<BR>
      　　姿勢の変更のあったボーンのうち、<BR>
      　　一番親の番号が代入されます。<BR>
      　　この値をE3DRenderに渡すと処理の高速化が出来ます。<BR>
      　　詳しくは、E3DRenderのところの注意事項をお読みください。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMotionType</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">モーションのタイプを取得します。<BR>
      <BR>
      得られるタイプの意味は以下のようになります。<BR>
      １がフレーム番号固定(Stop)<BR>
２が最終フレーム番号まで進んだら固定(Clamp)<BR>
      ３が最終フレーム番号まで進んだら先頭フレームに戻る(Round)<BR>
      ４が最終フレーム番号まで進んだら先頭フレームの方向に逆進する（PingPong）<BR>
      ５が最終フレームまで進んだら指定フレームにジャンプする（Jump）<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　typeptr<BR>
      　　前記で説明したモーションの種類が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMotionType</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">モーションのタイプをセットします。<BR>
      <BR>
      typeに指定する値の意味は、以下のようになります。<BR>１がフレーム番号固定(Stop)<BR>
２が最終フレーム番号まで進んだら固定(Clamp)<BR>
      ３が最終フレーム番号まで進んだら先頭フレームに戻る(Round)<BR>
      ４が最終フレーム番号まで進んだら先頭フレームの方向に逆進する（PingPong）<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　type<BR>
      　　前記で説明したモーションの種類を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetIKTransFlag</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ＩＫ伝達禁止情報をジョイントから取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　jointid<BR>
      　　ジョイントを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　flagptr<BR>
      　　通常の場合は０が、<BR>
      　　ＩＫ伝達禁止の時は１が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetIKTransFlag</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ＩＫ伝達禁止情報をジョイントにセットします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　jointid<BR>
      　　ジョイントを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　flag<BR>
      　　通常の場合は０を、<BR>
      　　ＩＫ伝達禁止の時は１を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyAllMotion</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">E3DAddMotionで読み込んだモーションデータを、全て破棄します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetUserInt1OfPart</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">パーツに設定されているユーザーデータを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　dataptr<BR>
      　　ユーザーデータが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetUserInt1OfPart</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">パーツにユーザーデータをセットします。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　data<BR>
      　　ユーザーデータを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBSphere</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">パーツ毎の境界球情報を取得します。<BR>
      ボーン変形を考慮したグローバル座標系の<BR>
      値が取得できます。<BR>
      <BR>
      <B>E3DChkInViewの計算結果をもとにしています。</B><BR>
      <BR>
      表示用オブジェクトのみに対して有効です。<BR>
      （ボーンに対して呼んでも、無意味です。）<BR>
      <BR>
      BSPHERE構造体はusercoef.hで定義されています。<BR>
      <BR>partnoに-1を指定するとモデル全体の境界球を取得できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] BSPHERE*　：　bsptr<BR>
      　　centerに境界球の中心座標が代入されます。<BR>
      　　rに境界球の半径が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.4.1.4で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetChildJoint</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">指定したジョイントの子供ジョイントの数と子供のシリアル番号を取得します。<BR>
      <BR>
      <BR>
      childarray配列に<BR>
      子供の数分のシリアル番号が<BR>
      代入されます。<BR>
      <BR>
      子供の数より配列の長さが大きいように<BR>
      してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　parentno<BR>
      　　親のジョイントの番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　childarray<BR>
      　　子供ジョイントのシリアル番号が代入されます。<BR>
      　　arraylengがchildnumより小さい場合は、<BR>
      　　arrayleng個のシリアル番号しか代入されません。<BR>
      <BR>
      <BR>
      4. [IN] int　：　arrayleng<BR>
      　　childarray引数に格納できる要素数を指定してください。<BR>
      　　int childarray[100];とした場合は、<BR>
      　　１００を指定してください。<BR>
      <BR>
      　　childnum引数に代入される数が、arraylengより大きい場合は、<BR>
      　　配列の長さが足りないことになります。<BR>
      <BR>
      <BR>
      5. [OUT] int*　：　childnum<BR>
      　　子供ジョイントの数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyMotionFrame</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">指定したキーフレームを削除します。<BR>
      <BR>
      <B>モーションの変更を反映させるには、<BR>
      E3DFillUpMotionを呼ぶ必要があります。<BR>
      </B><BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　frameno<BR>
      　　削除するフレームの番号を指定してください。<BR>
      　　<B>-1を指定すると全てのキーフレームを削除します。</B><BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetKeyFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">指定したボーンのキーフレームのフレーム番号を全て取得します。<BR>
      <BR>
      <BR>
      framearrayには、<BR>
      int framearray[50];<BR>
      などで作成した大きめの配列を使用してください。<BR>
      <BR>
      配列の長さよりframenumが大きい場合にはエラーになりますので<BR>
      注意してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　boneno<BR>
      　　ボーンパーツを識別する番号を指定してください。<BR>
      <BR>
      <BR>
      4. [OUT] int*　：　framearray<BR>
      　　この配列にフレーム番号が代入されます。<BR>
      <BR>
      5. [IN] int　：　arrayleng<BR>
      　　framearrayをアロケートしたときの要素数を指定してください。<BR>
      <BR>
      6. [OUT] int*　：　framenum<BR>
      　　framearrayに格納した要素の数が代入されます。<BR>
      　　キーフレームの数です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DConvScreenTo3D</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">任意の２Ｄ座標を３Ｄ座標に変換します。<BR>
      <BR>
      マウスの位置に対応する３Ｄ座標を<BR>
      求める場合などに便利です。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　pos2d<BR>
      　　変換したいマウスの位置などを、<BR>
      　　(pos2d.x, pos2d.y)で指定します。<BR>
      <BR>
      　　pos2d.zは、<BR>
      　　カメラからどのくらいの距離の平面上の点を取得するかを指定します。<BR>
      <BR>
      　　<U>３Ｄ座標のＺの値ではありません。</U><BR>
      　　カメラからの距離を制御出来るものと考えてください。<BR>
      　　（距離の値とは違います。）<BR>
      <BR>
      　　0.0のときカメラに一番近い座標がえられます。<BR>
      　　1.0のときカメラから一番遠い（見える範囲での）<BR>
      　　座標がえられます。<BR>
      　　見える範囲とは<BR>
      　　E3DSetProjectionで指定した範囲のことです。<BR>
      <BR>
      　　実際のカメラの距離とこのzの値は<BR>
      　　比例関係にありません。<BR>
      <BR>
      　　zの値をちょっと大きくしただけで<BR>
      　　カメラからの距離が大きく変わったり、<BR>
      　　反対にzを大きく変えても<BR>
      　　カメラからの距離が少ししか変わらない領域もあります。<BR>
      <BR>
      　　０に近すぎる値では、<BR>
      　　見えないことがあるので注意してください。<BR>
      <BR>
      <BR>
      3. [OUT] D3DXVECTOR3*　：　pos3dptr<BR>
      　　上で指定した２Ｄ座標に対応する３Ｄ座標が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetUV</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャーのＵＶ座標をセットします。<BR>
      <BR>
      partnoには<BR>
      E3DGetPartNoByNameで取得した番号を、<BR>
      vertnoには<BR>
      E3DGetVertNumOfPartで取得した頂点数を<BR>
      vertnumとしたとき、<BR>
      0から(vertnum - 1)までの値を渡してください。<BR>
      <BR>
      <B>vertnoに-1を指定すると<BR>
      指定パーツの全ての頂点に対して<BR>
      処理を行うようにしました。<BR>
      </B><BR>
      UV構造体はusercoef.hで定義されています。<BR>
      <BR>
      ver5.0.1.6でビルボードに対応しました。<BR>
      <BR>
      ver5.0.2.7でclampflagを追加しました。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid。<BR>
      　　-1を渡すとビルボードの処理をします。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号。<BR>
      　　hsidに-1を渡した場合はビルボードIDを指定します。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　頂点の番号。<BR>
      <BR>
      　　-1を指定すると、全ての頂点に対して処理します。<BR>
      <BR>
      <BR>
      4. [IN] UV　：　uv<BR>
      　　設定したいＵＶ値の値を指定してください。<BR>
      　　通常は0.0から1.0の値。<BR>
      <BR>
      5. [IN] int　：　setflag<BR>
      　　setflag に０を指定すると、<BR>
      　　指定ＵＶ値をそのままセットします。<BR>
      <BR>
      　　setflagに１を指定すると、<BR>
      　　指定ＵＶ値を既存のＵＶ値に足し算します。<BR>
      <BR>
      6. [IN] 変数または、数値　：　clampflag<BR>
      　　１をセットするとUVの値を０．０から１．０の間にクランプします。<BR>
      　　０を指定するとクランプは行いません。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.0.1.6で拡張<BR>
      ver5.0.2.7で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetUV</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャーのＵＶ座標を取得します。<BR>
      <BR>
      partnoには<BR>
      E3DGetPartNoByNameで取得した番号を、<BR>
      vertnoには<BR>
      E3DGetVertNumOfPartで取得した頂点数を<BR>
      vertnumとしたとき、<BR>
      0から(vertnum - 1)までの値を渡してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　頂点の番号<BR>
      <BR>
      4. [OUT] UV*　：　uvptr<BR>
      　　ＵＶ座標の値が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DPickBone</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">指定した２Ｄ座標に近いジョイントの番号を取得します。<BR>
      <BR>
      ２Ｄ座標にはマウスの座標などを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] POINT　：　scpos<BR>
      　　２Ｄ座標を指定します。<BR>
      <BR>
      3. [OUT] int　：　jointnoptr<BR>
      　　指定した２Ｄ座標に近いジョイントがある場合には、<BR>
      　　そのジョイントのＩＤが代入されます。<BR>
      　　<BR>
      　　近くにジョイントがない場合には、０以下が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DShiftBoneTree2D</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">指定した２Ｄ座標に近づくようにボーンツリー全体を移動します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      3. [IN] int　：　jointno<BR>
      　　ジョイントを識別するＩＤ<BR>
      　　E3DPickBoneなどで取得した、<BR>
      　　ジョイントの番号を渡してください。<BR>
      <BR>
      4. [IN] int　：　motid<BR>
      　　モーションを識別するＩＤ<BR>
      　　E3DAddMotionで取得したmotidを指定してください。<BR>
      <BR>
      5. [IN] int　：　frameno<BR>
      　　ポーズを設定したいフレーム番号を指定してください。<BR>
      <BR>
      6. [IN] D3DXVECTOR2　：　target2d<BR>
      　　jointnoで指定したジョイントが<BR>
      　　指定した２Ｄ座標に近づくように<BR>
      　　ボーンツリー全体が移動します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRotateBillboard</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボード</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボードをカメラの方向を向けたまま回転します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　billboardid<BR>
      　　ビルボードを識別する番号<BR>
      <BR>
      2. [IN] float　：　rotdeg<BR>
      　　ビルボードをrotdeg度だけ<BR>
      　　回転します。<BR>
      <BR>
      3. [IN] int　：　rotkind<BR>
      <BR>
      　　rotkindに０を指定すると相対値モードになります<BR>
      　　現在のビルボードの向きに<BR>
      　　更に指定角度だけ回転を加えます。<BR>
      <BR>
      　　rotkindに１を指定すると絶対値モードになります。<BR>
      　　初期状態に対して指定角度だけ回転を加えます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBillboardUV</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボード</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボードのＵＶを設定します。<BR>
      <BR>
      横方向にunum個、縦方向にvnum個のタイル状に作ったテクスチャーの、タイルの番号を指定することで指定した画像のＵＶを設定します。<BR>
      <BR>
      タイル状のテクスチャ画像とタイル番号の対応は、<A href="e3dhsp_texturetile.htm">タイル番号の説明</A>をご覧ください。<BR>
      <BR>
      <BR>
      タイルの数が12個の場合は、<BR>
      タイルの番号は０から１１になりますが<BR>
      それより大きな値や小さな値を指定することも可能です。<BR>
      <BR>
      例えば、タイルの数が12個の場合、<BR>
      １２を指定すると<BR>
      タイル番号０が表示され<BR>
      13を指定すると<BR>
      タイル番号１が表示され<BR>
      -1を指定すると<BR>
      タイル番号１１が表示されるという具合に<BR>
      機能します。<BR>
      <BR>
      ver5.0.1.7でrevuflag引数を追加しました。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bbid<BR>
      　　ビルボードを識別するid<BR>
      <BR>
      2. [IN] int　：　unum<BR>
      3. [IN] int　：　vnum<BR>
      　　タイルの横と縦の個数<BR>
      <BR>
      4. [IN] int　：　tileno<BR>
      　　設定したいテクスチャのタイルの番号<BR>
      <BR>
      5. [IN] int　：　revuflag<BR>
      　　１を指定するとテクスチャを左右反転させます。０を指定するとそのまま。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.0.1.7で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateTexture</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">指定したファイルからテクスチャを作ります。画面と同じテクスチャを作ることも可能です。<BR>
      <BR>
      テクスチャの操作にはこの関数で取得した<BR>
      テクスチャのＩＤ、texidを使用してください。<BR>
      <BR>
      <BR>
      transparentに１（黒透過）を指定した場合には、<BR>
      黒透過処理が行われます。<BR>
      D3DPOOL_DEFAULTで、<BR>
      テクスチャを作成する場合にはtransparentに１を指定すると失敗することがあります。<BR>
      <BR>
      <BR>
      filenameに&quot;MainWindow&quot;を指定すると、<BR>
      バックバッファと同じ内容で<BR>
      同じ大きさのサーフェスを作成します。<BR>
      この際、poolに何を指定しても<BR>
      強制的にシステムメモリに作成します。<BR>
      また、このときtransparentに１を指定できません。<BR>
      <BR>
      &quot;MainWindow&quot;を指定した場合は、<BR>
      E3DSetTextureToDispObjは使えません。<BR>
      E3DCopyTextureToBackBufferを使ってください。<BR>
      <BR>
      <BR>
      &quot;MainWindow&quot;を指定したときはバックバッファと同じフォーマットで、それ以外は、D3DFMT_A8R8G8B8で作成します。<BR>
      <BR>DX8からDX9への移行時の変更の関係で、<BR>
      現在、&quot;MainWindow&quot;指定は使用できない状態です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　テクスチャファイル のパス文字列。<BR>
      <BR>
      2. [IN] int　：　pool<BR>
      　　どのメモリ位置にテクスチャを作成するかを指定します。<BR>
      <BR>
      　　D3DPOOL_DEFAULT　（普通はビデオメモリに作られます）<BR>
      　　D3DPOOL_MANAGED　（DirectXの管理（バックアップ有り））<BR>
      　　D3DPOOL_SYSTEMMEM　（システムメモリに作られます）<BR>
      　　の中から選びます。<BR>
      <BR>
      <BR>
      3. [IN] int　：　transparent<BR>
      　　透過情報を指定します。<BR>
      <BR>
      　　０を指定すると不透明のテクスチャ。<BR>
      　　１を指定すると黒色を透過するテクスチャ。<BR>
      　　２を指定するとテクスチャファイルのアルファに従って<BR>
      　　透過するテクスチャになります。<BR>
      <BR>
      <BR>
      4. [OUT] int*　：　texidptr<BR>
      　　作成したテクスチャを識別するＩＤ<BR>
      　　テクスチャ操作の際には、このＩＤを使用してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetTextureInfo</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">作成したテクスチャの情報を取得します。<BR>
      <BR>
      テクスチャのサイズは、<BR>
      ビデオカードによっては２の乗数のサイズしか<BR>
      確保できないので<BR>
      ファイルのサイズと異なる場合があります。<BR>
      <BR>
      <BR>
      TEXTUREINFO構造体はusercoef.hで定義されています。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN, OUT] TEXTUREINFO*　：　texinfo<BR>
      　　テクスチャ情報を受け取るポインタ<BR>
      　　texinfo.texidにテクスチャのIDをセットしてからこの関数に渡してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetTextureFromDispObj</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">読み込み済の３Ｄオブジェクトに設定されているテクスチャを取得します。<BR>
      <BR>
      sigモデルデータに対する操作には<BR>
      E3DGetTextureFromMaterialをお使いください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するＩＤ<BR>
      <BR>
      　　-1を指定すると、ビルボードの処理を行います。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツの番号。<BR>
      　　E3DGetPartNoByNameで取得した番号を指定してください。<BR>
      <BR>
      　　hsidに-1を指定した場合には、<BR>
      　　ビルボードのＩＤを指定してください。<BR>
      <BR>
      3. [OUT] int*　：　texidptr<BR>
      　　テクスチャを識別するID<BR>
      　　指定したパーツにテクスチャが貼られていない場合には、<BR>
      　　texidには-1が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetTextureToDispObj</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">読み込み済の３Ｄオブジェクトにテクスチャを設定します。<BR>
      <BR>
      sigモデルデータに対する操作には<BR>
      E3DSetTextureToMaterialをお使いください。<BR>
      <BR>
      <BR>
      テクスチャをセットしても<BR>
      ＵＶ座標は自動的に生成されません。<BR>
動的にテクスチャを設定する場合は、<BR>
      ＵＶ座標もE3DSetUVで設定するか、<BR>
      もしくは、<BR>
      あらかじめ、モデルに仮のテクスチャを貼っておいてＵＶ設定しておく必要があります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するＩＤ<BR>
      <BR>
      　　-1を指定すると、ビルボードの処理を行います。<BR>
      　　-2を指定するとスプライトの処理を行います。<BR>
      <BR>
      　　パーティクルの設定をする場合は<BR>
      　　パーティクルIDを指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツの番号。<BR>
      　　E3DGetPartNoByNameで取得した番号を指定してください。<BR>
      <BR>
      　　hsidに-1を指定した場合には、<BR>
      　　ビルボードのＩＤを指定してください。<BR>
      <BR>
      　　hsidに-2を指定した場合には<BR>
      　　スプライトのIDを指定してください。<BR>
      <BR>
      　　hsidにパーティクルIDを指定した場合には<BR>
      　　partnoには０を指定してください。<BR>
      <BR>
      3. [IN] int　：　texid<BR>
      　　貼り付けたいテクスチャのＩＤを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.5.0.4で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyTexture</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャを破棄します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　texid<BR>
      　　テクスチャを識別するＩＤ<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetLightSpecular</TD>
      <TD class="hpb-cnt-tb-cell2">ライト</TD>
      <TD class="hpb-cnt-tb-cell2">ライトのスペキュラー色を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lightid<BR>
      　　ライトを識別するＩＤ<BR>
      <BR>
      2. [IN] E3DCOLOR4UC　：　col<BR>
      　　スペキュラー色を指定します。<BR>
      　　col.aは無視されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateTextureFromBuf</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">メモリに読み込んだ絵のデータからテクスチャを作成します。<BR>
      <BR>
      filenameの代わりにバッファを指定し、<BR>
      &quot;MainWindow&quot;が扱えないこと以外は、<BR>
      E3DCreateTextureと同じです。<BR>
      <BR>
      E3DCreateTextureの説明を<BR>
      お読みください。<BR>
      <BR>
      <BR>
      例えば、以下のような使い方になります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　buf<BR>
      　　バッファのポインタ<BR>
      <BR>
      2. [IN] int　：　bufleng<BR>
      　　バッファの中のデータの長さ(バイト)<BR>
      <BR>
      3. [IN] int　：　pool<BR>
      　　どのメモリ位置にテクスチャを作成するかを指定します。<BR>
      <BR>
      　　D3DPOOL_DEFAULT　（普通はビデオメモリに作られます）<BR>
      　　D3DPOOL_MANAGED　（DirectXの管理（バックアップ有り））<BR>
      　　D3DPOOL_SYSTEMMEM　（システムメモリに作られます）<BR>
      　　の中から選びます。<BR>
      <BR>
      <BR>
      4. [IN] int　：　transparent<BR>
      　　透過情報を指定します。<BR>
      <BR>
      　　０を指定すると不透明のテクスチャ。<BR>
      　　１を指定すると黒色を透過するテクスチャ。<BR>
      　　２を指定するとテクスチャファイルのアルファに従って<BR>
      　　透過するテクスチャになります。<BR>
      <BR>
      <BR>
      5. [OUT] int*　：　texidptr<BR>
      　　作成したテクスチャを識別するＩＤが代入されます。<BR>
      　　テクスチャ操作の際には、このＩＤを使用してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadSoundFromBuf</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">メモリから音データを読み込みＩＤを取得します。<BR>
      <BR>
      メモリから読み込むこと以外は<BR>
      E3DLoadSoundと同じです。<BR>
      <BR>
      E3DLoadSoundの説明をお読みください。<BR>
      <BR>
      現在、oggにはこの命令は使えません。<BR>
      <BR>
      ver5.3.1.6でoggdatanum引数を削除。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　buf<BR>
      　　バッファのポインタ<BR>
      <BR>
      2. [IN] int　：　bufleng<BR>
      　　バッファの中のデータの長さ(バイト)<BR>
      <BR>
      3. [IN] int　：　type<BR>
      　　midiのときは１、それ以外は０を指定してください。<BR>
      <BR>
      4. [IN] int　：　use3dflag<BR>
      　　３Ｄサウンドとして読み込む場合は１を指定してください。<BR>
      　　デフォルト値は０。<BR>
      <BR>
      5. [IN] int　：　reverbflag<BR>
      　　リバーブをオンにしたいときは１を<BR>
      　　オフにしたいときは０を指定してください。<BR>
      <BR>
      6. [IN] int　：　bufnum<BR>
      　　同じＩＤのサウンドを同時にいくつ重ねて再生できるかを指定します。<BR>
      <BR>
      7. [OUT] int*　：　soundidptr<BR>
      　　作成した音データを識別する番号が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.3.0.0で仕様変更<BR>
      ver5.3.0.3で拡張<BR>
      ver5.3.1.6で修正<BR>
      <BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DTwistBone</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンをツイストします。<BR>
      <BR>
      指定したジョイントとその親のジョイントのベクトルを軸として回転します。<BR>
      <BR>
      boneno引数に指定したジョイントに<BR>
      親のジョイントがない場合は、<BR>
      この関数を呼んでも<BR>
      何も効果はありません。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号<BR>
      <BR>
      3. [IN] int　：　frameno<BR>
      　　操作するモーションのフレーム番号<BR>
      <BR>
      4. [IN] int　：　jointno<BR>
      　　ジョイントを識別する番号<BR>
      　　E3DGetPartNoByNameなどで取得した値や、<BR>
      　　E3DGetJointInfoで取得したシリアル番号を指定してください。<BR>
      　　<B>ジョイント以外のパーツの番号を指定すると<BR>
      　　エラーになります。</B><BR>
      <BR>
      <BR>
      5. [IN] float　：　twistdeg<BR>
      　　twistdeg 度だけツイストします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBoneQ</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンのクォータニオンを取得します。<BR>
      <BR>
      kind引数の値により、<BR>
      親のクォータニオンの影響を受けたものと<BR>
      受けていないものを取得できます。<BR>
      <BR>
      モーションを読み込んでいないときは<BR>
      エラーになります。<BR>
      <BR>
      指定したframenoにキーフレームがない場合は、<BR>
      補間計算した結果を取得します。<BR>
      <BR>
      エンドジョイント（子供を持たないジョイント）<BR>
      に対しても呼ぶことが出来ます。<BR>
      <BR>
      ボーン以外の番号をbonenoに入れると<BR>
      エラーになります。<BR>
      <BR>
      マルチレイヤーモーションを使用する場合は<BR>
      この命令は使えません。<BR>
      E3DGetCurrentBoneQをお使いください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      　　E3DGetBoneNoByNameまたは、<BR>
      　　E3DGetPartNoByNameで取得した番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　フレームの番号を指定してください。<BR>
      <BR>
      5. [IN] int　：　kind<BR>
      　　親の影響を受けたクォータニオンを<BR>
      　　取得する場合は１を指定してください。<BR>
      <BR>
      　　親の影響を受けていないクォータニオンを<BR>
      　　取得する場合は０を指定してください。<BR>
      <BR>
      　　親の影響を受け、<BR>
      　　更に、モデル全体の向きの影響を受けたクォータニオンを取得<BR>
      　　するには２を指定してください。<BR>
      <BR>
      <BR>
      6. [IN, OUT] int　：　qid<BR>
      　　クォータニオンを識別する番号。<BR>
      　　E3DCreateQで取得した番号を指定してください。<BR>
      <BR>
      　　qidで識別されるクォータニオンの内容に、<BR>
      　　指定したボーンのクォータニオンの内容を代入します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBoneQ</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンのクォータニオンをセットします。<BR>
      <BR>
      指定したフレームにモーションポイントが存在しない場合は、<BR>
      自動的にモーションポイントを作成した後、<BR>
      クォータニオンをセットします。<BR>
      <BR>
      E3DFillUpMotionを呼び出さないと<BR>
      他のフレームには反映されません。<BR>
      <BR>
      ver5.4.0.0でcurboneonlyフラグを追加しました。<BR>
      このフラグが０のとき（今までと同じ動作）は、クォータニオンをセットした後、親にさかのぼって姿勢の計算をします。<BR>
      この計算はE3DFillUpMotionでも行われるので、多数のボーンにSetBoneQをするとかなりのタイムロスになります。<BR>
      curboneonlyに１をセットするとこの計算をスキップします。<BR>
      curboneonlyに１をセットして多数のボーンの設定を行った後に、一回E3DFillUpMotionをすれば良いことになります。<BR>
<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      　　E3DGetBoneNoByNameまたは、<BR>
      　　E3DGetPartNoByNameで取得した番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　フレームの番号を指定してください。<BR>
      <BR>
      5. [IN] int　：　qid<BR>
      　　クォータニオンを識別する番号。<BR>
      　　E3DCreateQで取得した番号を指定してください。<BR>
      <BR>
      　　qidで識別されるクォータニオンの内容をボーンの姿勢にセットします。<BR>
      <BR>
      6. [IN] int　：　curboneonly<BR>
      　　前述をお読みください。<BR>
      　　デフォルト引数（0）。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.4.0.0で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DIsSoundPlaying</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">音が再生中かどうかを調べます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　音を識別する番号を、指定します。<BR>
      <BR>
      2. [OUT] int*　：　playingptr<BR>
      　　再生中の場合は１が、<BR>
      　　そうでない場合は０が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DIKTranslate</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">ＩＫで、ボーンの位置を移動します。<BR>
      <BR>RokDeBone2のＴボタンと同様に、<BR>
      一番親のボーン以外でこの関数を呼ぶと、<BR>
      モデルの形状が崩れます。<BR>
      形状を保ちたい場合はE3DIKRotateBetaを使用してください。<BR>
      <BR>
      位置にはグローバル座標を指定してください。<BR>
      <BR>
      モーションを読み込んでいないとエラーになります。<BR>
      <BR>
      framenoにモーションポイントがない場合は、<BR>
      自動的に作成した後に移動をセットします。<BR>
      <BR>
      ジョイント以外に対して呼ぶとエラーになります。<BR>
      <BR>
      他のフレームにも結果を反映させたい場合は、<BR>
      E3DFillUpMotionを呼んでください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      　　E3DGetBoneNoByNameまたは、<BR>
      　　E3DGetPartNoByNameで取得した番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　フレームの番号を指定してください。<BR>
      <BR>
      5. [IN] D3DXVECTOR3　：　pos<BR>
      　　ボーンを移動させたいグローバル座標を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetUVTile</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ひとつの画像にタイル画像を敷き詰めたテクスチャのＵＶ座標を、タイル番号でセットできます。<BR>
      <BR>
      タイル状のテクスチャ画像とタイル番号の対応は、<A href="e3dhsp_texturetile.htm">タイル番号の説明</A>をご覧ください。<BR>
      <BR>
      <BR>
      タイルの数が12個の場合は、<BR>
      タイルの番号は０から１１になりますが、<BR>
      それより大きな値や小さな値を指定することも可能です。<BR>
      <BR>
      例えば、タイルの数が12個の場合<BR>
      １２を指定すると、<BR>
      タイル番号０が表示され、<BR>
      13を指定すると<BR>
      タイル番号１が表示され、<BR>
      -1を指定すると<BR>
      タイル番号１１が表示されるという具合に<BR>
      機能します。<BR>
      <BR>
      5種類の投影、貼り付けをサポートします。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　表示パーツを識別する番号を指定してください。<BR>
      　　E3DGetPartNoByNameで取得した番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　texrule<BR>
      　　投影、貼り付けのモードを指定します。<BR>
      <BR>
      　　０を指定するとＸ軸投影<BR>
      　　１を指定するとＹ軸投影<BR>
      　　２を指定するとＺ軸投影<BR>
      　　３を指定すると円筒貼り付け<BR>
      　　４を指定すると球貼り付け<BR>
      　　です。<BR>
      <BR>
      <BR>
      4. [IN] int　：　unum<BR>
      　　テクスチャのタイル画像の<BR>
      　　横方向の個数を指定してください。<BR>
      <BR>
      5. [IN] int　：　vnum<BR>
      　　テクスチャのタイル画像の<BR>
      　　縦方向の個数を指定してください。<BR>
      <BR>
      6. [IN] int　：　tileno<BR>
      　　表示したいタイルの番号を指定してください。<BR>
      　　<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DImportMQOFileAsGround</TD>
      <TD class="hpb-cnt-tb-cell2">地面</TD>
      <TD class="hpb-cnt-tb-cell2">hsidに読み込み済の地面データに、<BR>
      filenameで指定した地面データを<BR>
      インポート（追加読み込み）します。<BR>
      <BR>
      <BR>
<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　読み込み済の地面モデルを識別する番号を<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] char*　：　filename<BR>
      　　読み込む、mqo ファイル名。<BR>
      <BR>
      3. [IN] int　：　adjustuvflag<BR>
      　　UV座標を正規化したいときは１を、<BR>
      　　そうでないときは、０を指定してください。<BR>
      　　２を指定すると0.0から1.0の間にクランプします。<BR>
<BR>
      <BR>
      4. [IN] float　：　mult<BR>
      　　形状データの座標に掛ける数値。<BR>
      　　座標値　＊　multで計算されます。<BR>
      　　等倍は１．０。<BR>
      <BR>
      5. [IN] D3DXVECTOR3　：　offset<BR>
      　　読み込み位置のオフセット座標を指定します。<BR>
      　　ローカル座標で指定します。<BR>
      <BR>
      6. [IN] D3DXVECTOR3　：　rot<BR>
      　　追加形状を、Ｘ，Ｙ，Ｚそれぞれの軸に対して<BR>
      　　rotx, roty, rotz度だけ回転してから<BR>
      　　インポートを行います。<BR>
      　　回転順序はＺ，Ｙ，Ｘの順番です。<BR>
      <BR>
      パラメータの適用順序は、<BR>
      まず倍率を掛けて、<BR>
      次に回転をして、<BR>
      最後に移動します。<BR>
</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.0.2.6で拡張<BR>
      <BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadMQOFileAsMovableAreaFromBuf</TD>
      <TD class="hpb-cnt-tb-cell2">壁</TD>
      <TD class="hpb-cnt-tb-cell2">移動可能領域を定義するデータをメモリから読み込みます。<BR>
      <BR>
      メモリから読み込むこと以外は、<BR>
      E3DLoadMQOFileAsMovableArea<BR>
      と同じです。<BR>
      E3DLoadMQOFileAsMovableArea<BR>
      の説明をお読みください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　buf<BR>
      　　バッファのポインタ<BR>
      <BR>
      2. [IN] int　：　bufleng<BR>
      　　バッファの中のデータの長さ<BR>
      <BR>
      3. [IN] float　：　mult<BR>
      　　形状データの座標に掛ける数値。<BR>
      　　座標値　＊　mult で計算されます。<BR>
      　　等倍は１．０。<BR>
      <BR>
      4. [OUT] int　：　hsidptr<BR>
      　　作成した壁データを識別するhsidが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkThreadWorking</TD>
      <TD class="hpb-cnt-tb-cell2">スレッド管理</TD>
      <TD class="hpb-cnt-tb-cell2">関数の最後に「Thread」が付いている関数は、新たにスレッドを作成します。<BR>
      <BR>
      この作成したスレッドが<BR>
      現在動作中であるかどうかをチェックするための関数です。<BR>
      <BR>
      スレッドが終了している場合には、<BR>
      スレッドの動作結果が<BR>
      returnval1, reteurnval2変数で取得できます。<BR>
      この変数は、hsidやモーションＩＤを取得するために使用します。<BR>
      <BR>
      スレッド読み込み関数に存在しないファイル名などを指定した場合などはエラーにならずに、<BR>
      hsidが代入される引数に-1が代入されるので注意してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　threadid<BR>
      　　スレッドを識別するＩＤ<BR>
      　　名前の最後にThreadが付いている関数で<BR>
      　　取得したＩＤを指定してください。<BR>
      <BR>
      2. [OUT] int*　：　workingptr<BR>
      　　スレッドが動作中かどうかが代入されます。<BR>
      　　動作中の場合は１が、<BR>
      　　動作が終了している場合には０が代入されます。<BR>
      <BR>
      　　workingが０の場合は、<BR>
      　　returnval1, returnval2に代入される値が意味を持ちます。<BR>
      <BR>
      3. [OUT] int*　：　returnval1<BR>
      4. [OUT] int*　：　returnval2<BR>
      　　スレッドの実行結果が代入されます。<BR>
      　　returnval1, returnval2に代入される値の<BR>
      　　意味については、<BR>
      　　各Thread作成関数の説明をお読みください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadMQOFileAsGroundThread</TD>
      <TD class="hpb-cnt-tb-cell2">地面</TD>
      <TD class="hpb-cnt-tb-cell2">スレッドを作成してE3DLoadMQOFileAsGroundを実行します。<BR>
      <BR>
      作成したスレッドを識別するためのＩＤが<BR>
      threadidに代入されます。<BR>
      <BR>
      スレッドの作成に失敗した場合には、<BR>
      threadidにマイナスの値が代入されます。<BR>
      <BR>
      threadidは、<BR>
      E3DChkThreadWorkingに使用することが<BR>
      出来ます。<BR>
      <BR>
      スレッド作成関数は全部で4098回まで<BR>
      呼ぶことが出来ます。<BR>
      （E3DChkThreadWorkingを除く）<BR>
      E3DFreeThreadの説明もご覧ください。<BR>
      <BR>
      スレッドが終了すると<BR>
      E3DChkThreadWorkingで取得される<BR>
      returnval1に、<BR>
      モデルデータを識別するhsidが代入されます。<BR>
      <BR>
      E3DLoadMQOFileAsGroundの説明もお読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　読み込む、mqo ファイル名。<BR>
      <BR>
      2. [IN] float　：　mult<BR>
      　　形状データの座標に掛ける数値。<BR>
      　　座標値　＊　mult で計算されます。<BR>
      　　等倍は１．０。<BR>
      <BR>
      3. [IN] int　：　adjustuvflag<BR>
      　　UV座標を正規化したいときは１を、<BR>
      　　そうでないときは０を指定してください。<BR>
      　　２を指定すると0.0から1.0の間にクランプします。<BR>
      <BR>
      4. [OUT] int*　：　threadidptr<BR>
      　　作成したスレッドを識別するＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.0.2.6で拡張<BR>
      <BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSigLoadThread</TD>
      <TD class="hpb-cnt-tb-cell2">形状データ</TD>
      <TD class="hpb-cnt-tb-cell2">スレッドを作成してE3DSigLoadを実行します。<BR>
      <BR>
      作成したスレッドを識別するためのＩＤが<BR>
      threadidに代入されます。<BR>
      <BR>
      スレッドの作成に失敗した場合には、<BR>
      threadidにマイナスの値が代入されます。<BR>
      <BR>
      threadidは<BR>
      E3DChkThreadWorkingに使用することが<BR>
      出来ます。<BR>
      <BR>
      スレッド作成関数は全部で4098回まで<BR>
      呼ぶことが出来ます。<BR>
      （E3DChkThreadWorkingを除く）<BR>
      E3DFreeThreadの説明もご覧ください。<BR>
      <BR>
      <BR>
      スレッドが終了すると、<BR>
      E3DChkThreadWorkingで取得される<BR>
      returnval1に、<BR>
      モデルデータを識別するhsidが代入されます。<BR>
      <BR>
      E3DSigLoadの説明も、お読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　fname<BR>
      　　*.sig のパス文字列。<BR>
      <BR>
      2. [IN] int　：　adjustuvflag<BR>
      　　ＵＶ値を正規化するかどうかのフラグ。<BR>
      　　正規化する場合は１を指定。<BR>
      　　しない場合は０を指定。<BR>
      　　２を指定すると0.0から1.0の間にクランプします。<BR>
      <BR>
      3. [IN] float　：　mult<BR>
      　　読み込み倍率を指定してください。<BR>
      　　等倍は１．０。<BR>
      <BR>
      4. [OUT] int*　：　threadidptr<BR>
      　　作成したスレッドを識別するＩＤが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>ver5.0.2.6で拡張<BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSigLoadFromBufThread</TD>
      <TD class="hpb-cnt-tb-cell2">形状データ</TD>
      <TD class="hpb-cnt-tb-cell2">スレッドを作成してE3DSigLoadFromBufを実行します。<BR>
      <BR>
      作成したスレッドを識別するためのＩＤが<BR>
      threadidに代入されます。<BR>
      <BR>
      スレッドの作成に失敗した場合には、<BR>
      threadidにマイナスの値が代入されます。<BR>
      <BR>
      threadidは<BR>
      E3DChkThreadWorkingに使用することが<BR>
      出来ます。<BR>
      <BR>
      スレッド作成関数は全部で4098回まで<BR>
      呼ぶことが出来ます。<BR>
      （E3DChkThreadWorkingを除く）<BR>      E3DFreeThreadの説明もご覧ください。<BR>
      <BR>
      スレッドが終了すると、<BR>
      E3DChkThreadWorkingで取得される<BR>
      returnval1に、<BR>
      モデルデータを識別するhsidが代入されます。<BR>
      <BR>
      E3DSigLoadFromBufの説明もお読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　resdir<BR>
      　　テクスチャーのあるフォルダ のパス文字列。<BR>
      　　最後に&quot;\\&quot;が必要。<BR>
      <BR>
      2. [IN] char*　：　buf<BR>
      　　バッファのポインタ<BR>
      <BR>
      3. [IN] int　：　bufleng<BR>
      　　バッファの中のデータの長さ<BR>
      <BR>
      4. [IN] int　：　adjustuvflag<BR>
      　　ＵＶ値を正規化するかどうかのフラグ。<BR>
      　　正規化する場合は１を指定。<BR>
      　　しない場合は０を指定。<BR>
      　　２を指定すると0.0から1.0の間にクランプします。<BR>
      <BR>
      5. [IN] float　：　mult<BR>
      　　倍率を指定してください。<BR>
      　　等倍は、１．０。<BR>
      <BR>
      6. [OUT] int*　：　threadidptr<BR>
      　　作成したスレッドを識別するＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>ver5.0.2.6で拡張<BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadMQOFileAsMovableAreaThread</TD>
      <TD class="hpb-cnt-tb-cell2">壁</TD>
      <TD class="hpb-cnt-tb-cell2">スレッドを作成してE3DLoadMQOFileAsMovableAreaを実行します。<BR>
      <BR>
      作成したスレッドを識別するためのＩＤが<BR>
      threadidに代入されます。<BR>
      <BR>
      スレッドの作成に失敗した場合には、<BR>
      threadidにマイナスの値が代入されます。<BR>
      <BR>
      threadidは<BR>
      E3DChkThreadWorkingに使用することが<BR>
      出来ます。<BR>
      <BR>
      スレッド作成関数は全部で4098回まで<BR>
      呼ぶことが出来ます。<BR>
      （E3DChkThreadWorkingを除く）<BR>      E3DFreeThreadの説明もご覧ください。<BR>
      <BR>
      スレッドが終了すると、<BR>
      E3DChkThreadWorkingで取得される<BR>
      returnval1に、<BR>
      モデルデータを識別するhsidが代入されます。<BR>
      <BR>
      E3DLoadMQOFileAsMovableAreaの説明もお読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　読み込む、mqo ファイル名。<BR>
      <BR>
      2. [IN] float　：　mult<BR>
      　　形状データの座標に掛ける数値。<BR>
      　　座標値　＊　mult で計算されます。<BR>
      　　等倍は１．０。<BR>
      <BR>
      3. [OUT] int*　：　threadidptr<BR>
      　　作成したスレッドを識別するＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadMQOFileAsMovableAreaFromBufThread</TD>
      <TD class="hpb-cnt-tb-cell2">壁</TD>
      <TD class="hpb-cnt-tb-cell2">スレッドを作成してE3DLoadMQOFileAsMovableAreaFromBufを実行します。<BR>
      <BR>
      作成したスレッドを識別するためのＩＤが<BR>
      threadidに代入されます。<BR>
      <BR>
      スレッドの作成に失敗した場合には、<BR>
      threadidにマイナスの値が代入されます。<BR>
      <BR>
      threadidは<BR>
      E3DChkThreadWorkingに使用することが<BR>
      出来ます。<BR>
      <BR>
      スレッド作成関数は全部で4098回まで<BR>
      呼ぶことが出来ます。<BR>
      （E3DChkThreadWorkingを除く）<BR>      E3DFreeThreadの説明もご覧ください。<BR>
      <BR>
      <BR>
      スレッドが終了すると、<BR>
      E3DChkThreadWorkingで取得される<BR>
      returnval1に、<BR>
      モデルデータを識別するhsidが代入されます。<BR>
      <BR>
      E3DLoadMQOFileAsMovableAreaFromBufの説明もお読みください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　buf<BR>
      　　バッファのポインタ<BR>
      <BR>
      2. [IN] int　：　bufleng<BR>
      　　バッファの中のデータの長さ<BR>
      <BR>
      3. [IN] float　：　mult<BR>
      　　形状データの座標に掛ける数値。<BR>
      　　座標値　＊　mult で計算されます。<BR>
      　　等倍は１．０。<BR>
      <BR>
      4. [OUT] int*　：　threadidptr<BR>
      　　作成したスレッドを識別するＩＤが代入されます。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadGroundBMPThread</TD>
      <TD class="hpb-cnt-tb-cell2">地面</TD>
      <TD class="hpb-cnt-tb-cell2">スレッドを作成してE3DLoadGroundBMPを実行します。<BR>
      <BR>
      作成したスレッドを識別するためのＩＤが<BR>
      threadidに代入されます。<BR>
      <BR>
      スレッドの作成に失敗した場合には、<BR>
      threadidにマイナスの値が代入されます。<BR>
      <BR>
      threadidは<BR>
      E3DChkThreadWorkingに使用することが<BR>
      出来ます。<BR>
      <BR>
      スレッド作成関数は全部で4098回まで<BR>
      呼ぶことが出来ます。<BR>
      （E3DChkThreadWorkingを除く）<BR>
      E3DFreeThreadの説明もご覧ください。<BR>
      <BR>
      <BR>
      スレッドが終了すると、<BR>
      E3DChkThreadWorkingで取得される<BR>
      returnval1に、<BR>
      モデルデータを識別するhsidが代入されます。<BR>
      <BR>
      E3DLoadGroundBMPの説明もお読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename1<BR>
      　　地面の座標情報の元となる、ＢＭＰファイル名<BR>
      <BR>
      2. [IN] char*　：　filename2<BR>
      　　地面の道の情報の元となる、ＢＭＰファイル名<BR>
      <BR>
      3. [IN] char*　：　filename3<BR>
      　　地面の川の情報の元となる、ＢＭＰファイル名<BR>
      <BR>
      4. [IN] char*　：　filename4<BR>
      　　地面、道、川の模様を決める、ＢＭＰファイル名<BR>
      <BR>
      5. [IN] float　：　maxx<BR>
      　　地面のＸ座標の最大値<BR>
      <BR>
      6. [IN] float　：　maxz<BR>
      　　地面のＺ座標の最大値<BR>
      <BR>
      7. [IN] int　：　divx<BR>
      　　X方向の分割数<BR>
      <BR>
      8. [IN] int　：　divz<BR>
      　　Z方向の分割数<BR>
      <BR>
      9. [IN] float　：　maxheight<BR>
      　　地面の高さの最大値<BR>
      <BR>
      10. [OUT] int*　：　threadidptr<BR>
      　　作成したスレッドを識別するＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DAddMotionThread</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">スレッドを作成してE3DAddMotionを実行します。<BR>
      <BR>
      作成したスレッドを識別するためのＩＤが<BR>
      threadidに代入されます。<BR>
      <BR>
      スレッドの作成に失敗した場合には、<BR>
      threadidにマイナスの値が代入されます。<BR>
      <BR>
      threadidは<BR>
      E3DChkThreadWorkingに使用することが<BR>
      出来ます。<BR>
      <BR>
      スレッド作成関数は全部で4098回まで<BR>
      呼ぶことが出来ます。<BR>
      （E3DChkThreadWorkingを除く）<BR>
      E3DFreeThreadの説明もご覧ください。<BR>
      <BR>
      <BR>
      スレッドが終了すると、<BR>
      E3DChkThreadWorkingで取得される<BR>
      returnval1に<BR>
      モーションをを識別するIDが代入されます。<BR>
      returnval2に<BR>
      最大フレーム番号が代入されます。<BR>
      <BR>
      この関数が終了するまで<BR>
      この関数に渡したhsidに対して<BR>
      モーションの再生命令などは使わないようにしてください。<BR>
      <BR>
      <BR>
      E3DAddMotionの説明もお読みください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　どのモデルデータに対するモーションかを指定する。<BR>
      <BR>
      2. [IN] char*　：　fname<BR>
      　　*.quaのパス文字列。<BR>
      <BR>
      3. [OUT] int*　：　threadidptr<BR>
      　　作成したスレッドを識別するＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DAddMotionFromBufThread</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">スレッドを作成してE3DAddMotionFromBufを実行します。<BR>
      <BR>
      作成したスレッドを識別するためのＩＤが<BR>
      threadidに代入されます。<BR>
      <BR>
      スレッドの作成に失敗した場合には、<BR>
      threadidにマイナスの値が代入されます。<BR>
      <BR>
      threadidは<BR>
      E3DChkThreadWorkingに使用することが<BR>
      出来ます。<BR>
      <BR>
      スレッド作成関数は全部で4098回まで<BR>
      呼ぶことが出来ます。<BR>
      （E3DChkThreadWorkingを除く）<BR>
      E3DFreeThreadの説明もご覧ください。<BR>
      <BR>
      <BR>
      スレッドが終了すると<BR>
      E3DChkThreadWorkingで取得される<BR>
      returnval1に<BR>
      モーションをを識別するIDが代入されます。<BR>
      returnval2に<BR>
      最大フレーム番号が代入されます。<BR>
      <BR>
      この関数が終了するまで<BR>
      この関数に渡したhsidに対して<BR>
      モーションの再生命令などは使わないようにしてください。<BR>
      <BR>
      <BR>
      E3DAddMotionFromBufの説明もお読みください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するhsid<BR>
      <BR>
      2. [IN] char*　：　buf<BR>
      　　バッファのポインタ<BR>
      <BR>
      4. [IN] int　：　bufleng<BR>
      　　バッファの中のデータの長さ<BR>
      <BR>
      5. [OUT] int*　：　threadidptr<BR>
      　　作成したスレッドを識別するＩＤが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetShaderType</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">シェーダーの種類を取得します。<BR>
      <BR>
      それぞれの値の意味は、<BR>
      E3DSetShaderTypeの説明をお読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するhsid<BR>
      <BR>
      2. [OUT] int*　：　shaderptr<BR>
      　　シェーダーの種類代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetShaderType</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">シェーダーの種類を設定します。<BR>
      <BR>
      シェーダーの種類は、<BR>
      usercoef.hのCOL_ で始まる定数で定義されています。<BR>
      <BR>
      COL_OLD<BR>
      　　従来のRokDeBone2の計算法<BR>
      　　emissiveは、無効。<BR>
      　　スペキュラーは、形だけの実装。<BR>
      　　一番高速。<BR>
      COL_PHONG<BR>
      　　Lambertのディフーズ<BR>
      　　Phongのスペキュラー<BR>
      　　emissive有り<BR>
      COL_BLINN<BR>
      　　Lambertのディフーズ<BR>
      　　Blinnのスペキュラー<BR>
      　　emissive有り<BR>
      COL_SCHLICK<BR>
      　　Lambertのディフーズ<BR>
      　　Schlickのスペキュラー<BR>
      　　emissive有り<BR>
      COL_MQCLASSIC<BR>
      　　メタセコイアのマテリアルで<BR>
      　　Classicを指定したときのモード<BR>
      　　emissive有り<BR>
      <BR>
      COL_TOON1<BR>
      　　ピクセルシェーダーを使用したトゥーン表示。<BR>      COL_PPHONG<BR>
      　　ピクセルシェーダーを使用したPhong表示。<BR>
      <BR>
      <BR>
      ver3.0.0.1での仕様変更により、現在は、COL_PHONGとCOL_TOON1とCOL_TOON0のみのサポートとなります。<BR>
<BR>
      ver5.2.1.5でCOL_PPHONGを追加しました。<BR>
      <BR>
      ver5.2.2.0でCOL_TOON1とCOL_TOON0は統合されCOL_TOON1となりました。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するhsid<BR>
      <BR>
      2. [IN] int　：　shader<BR>
      　　シェーダーの種類の指定をします。<BR>
      　　値の意味は、前記をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.2.1.5で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBillboardEmissive</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボードのemissive色をセットする関数です。<BR>
      <BR>
      指定した色を、<BR>
      そのまま設定、乗算して設定、加算して設定、<BR>
      減算して設定の、4種類出来ます。<BR>
      <BR>
      <U>その時点で表示されている色に対して<BR>
      乗算、加算、減算します。</U><BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bbid<BR>
      　　ビルボードを識別するＩＤ<BR>
      <BR>
      2. [IN] E3DCOLOR4UC　：　col<BR>
      　　色を指定します。<BR>
      　　col.aは無視されます。<BR>
      <BR>
      　　setflagに乗算を指定した場合は、<BR>
      　　各成分に、col.r/255, col.g/255, col.b/255を乗算します。<BR>
      <BR>
      3. [IN] int　：　setflag<BR>
      　　setflagが０のときはcolをセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　ビルボードの色に（col.r/255, col.g/255, col.b/255）を乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　ビルボードの色にcolを足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　ビルボードの色からcolを減算します。<BR>
      <BR>
      7. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色をセットします。<BR>
      　　-1をセットした場合には<BR>
      　　ビルボード全体の色の設定をします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBillboardSpecularPower</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボードののspecular powerをセットする関数です。<BR>
      <BR>
      指定した色を、<BR>
      そのまま設定、乗算して設定、加算して設定、<BR>
      減算して設定の4種類出来ます。<BR>
      <BR>
      <U>その時点で表示されている色に対して<BR>
      乗算、加算、減算します。</U><BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bbid<BR>
      　　ビルボードを識別するＩＤ<BR>
      <BR>
      2. [IN] float　：　pow<BR>
      　　pow の値をsetflagに基づいて、<BR>
      　　現在の色に対して処理を行います。<BR>
      <BR>
      3. [IN] int　：　setflag<BR>
      　　setflagが０のときは、<BR>
      　　指定した値をセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　現在の値に指定した値を乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　現在の値に指定した値を足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　現在の値から指定した値を減算します。<BR>
      <BR>
      4. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色をセットします。<BR>
      　　-1をセットした場合にはビルボード全体の色の設定をします。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBillboardEmissive</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボードの任意の頂点のemissive色を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bbid<BR>
      　　ビルボードを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　vertno<BR>
      　　色を取得したい頂点の番号を指定します。<BR>
      <BR>
      3. [OUT] E3DCOLOR4UC*　：　colptr<BR>
      　　　指定した頂点のemissive色が代入されます。<BR>
      　　　colptr-&gt;aは無視されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBillboardSpecularPower</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボードの任意の頂点のspecular powerを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bbid<BR>
      　　ビルボードを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　vertno<BR>
      　　色を取得したい頂点の番号を指定します。<BR>
      <BR>
      3. [OUT] float*　：　powptr<BR>
      　　　指定した頂点のspecular powerが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetInfElemNum</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響</TD>
      <TD class="hpb-cnt-tb-cell2">指定した頂点が何個のボーンの影響を受けているかを取得します。<BR>
      <BR>
      影響度情報は影響を受けるボーンごとに存在します。<BR>
      （影響を受けるボーンの数だけ存在します）<BR>
      <BR>
      この影響度情報のことを、<BR>
      Easy3DではInfElemと呼びます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　取得したいパーツの番号を指定します。<BR>
      <BR>
      　　E3DGetPartNoByNameで取得した番号を渡してください。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　頂点の番号<BR>
      <BR>
      4. [OUT] int*　：　numptr<BR>
      　　影響度情報の個数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetInfElem</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響</TD>
      <TD class="hpb-cnt-tb-cell2">指定した頂点のボーン影響度情報を取得します。<BR>
      <BR>
      E3DINFELEM構造体はusercoef.hで定義されています。<BR>
      <BR>
      infelem.infnoに、<BR>
      E3DGetInfElemNumで取得した数値をinfnumとすると、<BR>
      0から(infnum - 1)の値をセットしてからこの関数に渡してください。<BR>
      <BR>
      <BR>
      infelem.<U>childjointnoに0以下（０を含む）の数値が取得された場合には、そのデータはダミーデータですので無視するようにしてください。<BR>
      </U><BR>
      <BR>
      infelem.calcmodeの意味<BR>
      calcmodeは、影響度の計算方法を表します。<BR>
      usercoef.h中で定義されているCALCMODE_で始まる定数を使用します。<BR>
      NOSKIN0はスキニング無し。<BR>
      ONESKIN0は距離と角度によりスキニング。<BR>
      ONESKIN1は距離のみによりスキニング。<BR>
      DIRECT0は直接数値指定。<BR>
      SYMは対称コピーによる指定。<BR>
      を表します。<BR>
      <BR>
      Easy3D内部での影響度の計算方法<BR>
      影響度を算出する際には、<BR>
      intelem.orginf, infelem.dispinf, infelem.userrate, normalizeflagを使います。<BR>
      infelem.orginfは、infelem.calcmodeで指定した方法で、算出した影響度。<BR>
      infelem.userrateは、比重。<BR>
normalizeflagは、正規化（一つの頂点の影響度の合計が１になるようにする）をするかどうかのフラグ。<BR>
      <B>infelem.dispinfが、最終的な影響度。</B><BR>
      まず、InfElemごとに、以下の計算をします。<BR>
orginf * userrate / 100<BR>
normalizeflagが０のときは、この値がそのまま、dispinfになります。<BR>
      normalizeflagが１のときは、<BR>
      ある頂点の全部のInfElemの影響度（dispinf）の合計が１になるように、正規化します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　取得したいパーツの番号を指定します。<BR>
      <BR>
      　　E3DGetPartNoByNameで取得した番号を渡してください。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　頂点の番号<BR>
      <BR>
      4. [IN, OUT] E3DINFELEM*　：　infelemptr<BR>
      <BR>
      　　infelemptr-&gt;infnoに<BR>
      　　影響度情報の番号つまり<BR>
      　　０から（影響度の個数-1）までの数<BR>
      　　をセットしてから渡します。<BR>
      <BR>
      　　infelemptr-&gt;childjointnoは<BR>
      　　どのボーンの影響を受けるかが代入されます。<BR>
      　　この値が0以下の値の時はダミーデータです。<BR>
      　　ボーンの線分の内子供の方のジョイントの番号が代入されます。<BR>
      <BR>
      　　infelemptr-&gt;calcmodeには<BR>
      　　影響度の計算方法が代入されます。<BR>
      <BR>
      　　infelemptr-&gt;userrateには<BR>
      　　比重が代入されます。<BR>
      　　％値が代入されます。<BR>
      　　例えば、１００％の場合は、100.0が代入されます。<BR>
      <BR>
      　　infelemptr-&gt;orginf, infelemptr-&gt;dispinfのそれぞれの意味は、前記をご覧ください。<BR>
      　</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetInfElem</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響</TD>
      <TD class="hpb-cnt-tb-cell2">頂点にボーン影響度を設定します。<BR>
      <BR>
      <BR>
      paintmodeの意味<BR>
      paintmodeは影響度の設定方法を表します。<BR>
      usercoef.h内で、PAINT_で始まる定数で<BR>
      定義されています。<BR>
      NORは、<BR>
      すでに設定してある影響度情報に、影響度データを追加します。<BR>
      同じボーンの情報が既にある場合は、上書きします。<BR>
      EXCは、すでに設定してある影響度情報を破棄してから影響度データを設定します。<BR>
      ADDは、すでに設定してある影響度の比重に指定した比重を足し算します。<BR>
      SUBは、すでに設定してある影響度の比重から指定した比重を引き算します。<BR>
      <S>ERAは、指定したボーンの影響度データを削除します。</S><BR>
<BR>
      calcmodeについては<BR>
      E3DGetInfElemの説明をご覧ください。<BR>
      <BR>
      <BR>
      calcmodeとpaintmodeの依存関係<BR>
      CALCMODE_NOSKIN0のときは、PAINT_EXCを設定してください。<BR>
      CALCMODE_DIRECT0のときは、PAINT_NORまたはPAINT_EXCを設定してください。<BR>
      <BR>
      <BR>
      影響度の計算方法については、<BR>
      E3DGetInfElemの説明をご覧ください。<BR>
      <BR>
      <BR>
      directvalは、CALCMODE_DIRECT0のときのみ意味を持ちます。この値をorginfとして設定します。<BR>
      正の小数を指定してください。<BR>
      <BR>
      <BR>
      <U>スムージング角度の関係などで、同じ位置に複数の頂点が存在する場合があります。<BR>
      これらの頂点を同時に同じように設定しないとボーン変形が乱れることがあるので注意してください。<BR>
      </U><BR>
      <BR>
      childjointnoは、ボーンの線分の内の子供のジョイントの番号です。<BR>
      childjointnoには、必ず親が存在するジョイントの番号を指定してください。<BR>
      <U>一番親のジョイントは、childjointには指定できません。</U><BR>
      <BR>      CALCMODE_SYMの影響度設定はこの命令ではできません。<BR>
      <B>E3DSetSymInfElem</B>をお使いください。<BR>
      <BR>
      この命令を呼んだだけでは表示には反映されません。<BR>
      <B>影響度の編集がすべて終わったら、E3DCreateSkinMatを呼んで</B>表示に反映させてください。<BR>
      <BR>
      <BR>
      PAINT_ERAは使えません。<BR>
      影響度を消したい場合は<BR>
      E3DDeleteInfElemをご使用ください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツの番号を指定します。<BR>
      <BR>
      　　E3DGetPartNoByNameで取得した番号を渡してください。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　頂点の番号<BR>
      <BR>
      4. [IN] int　：　childjointno<BR>
      　　影響を受けるボーンの指定。<BR>
      　　ボーンの線分の内、子供の方のジョイントの番号を<BR>
      　　指定します。<BR>
      <BR>
      5. [IN] int　：　calcmode<BR>
      　　影響度の計算方法を指定します。<BR>
      <BR>
      6. [IN] int　：　paintmode<BR>
      　　影響度の設定方法を指定します。<BR>
      <BR>
      7. [IN] int　：　normalizeflag<BR>
      　　正規化をするときは１、<BR>
      　　しないときは０を指定します。<BR>
      　　詳しくは、E3DGetInfElemの説明をお読みください。<BR>
      <BR>
      8. [IN] float　：　userrate<BR>
      　　比重％の値を指定します。<BR>
      　　１００％の時は、100.0fを指定します。<BR>
      　　詳しくは、E3DGetInfElemの説明をお読みください。<BR>
      <BR>
      9. [IN] float　：　directval<BR>
      　　直接数値指定の数値を指定します。<BR>
      　　詳しくは、前記をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDeleteInfElem</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響度情報を削除します。<BR>
      <BR>
      normalizeflagに１を指定すると、<BR>
      削除した後に<BR>
      指定頂点の残りの影響度情報を<BR>
      正規化します。<BR>
      <BR>      この命令を呼んだだけでは表示には反映されません。<BR>
      <B>影響度の編集がすべて終わったら、E3DCreateSkinMatを呼んで</B>表示に反映させてください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツの番号を指定します。<BR>
      <BR>
      　　E3DGetPartNoByNameで取得した番号を渡してください。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　頂点の番号<BR>
      <BR>
      4. [IN] int　：　childjointno<BR>
      　　影響を受けるボーンの指定。<BR>
      　　ボーンの線分の内、子供の方のジョイントの番号を<BR>
      　　指定します。<BR>
      <BR>
      5. [IN] int　：　normalizeflag<BR>
      　　正規化をするときは１、<BR>
      　　しないときは０を指定します。<BR>
      　　詳しくは、E3DGetInfElemの説明をお読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetInfElemDefault</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響度情報をデフォルト状態に戻します。<BR>
      <BR>
      <B>partno</B>に-1を指定すると、<BR>
      <U>全パーツの</U>全頂点の影響度を<BR>
      デフォルト状態に戻します。<BR>
      <BR>
      この命令を呼んだだけでは表示には反映されません。<BR>
      <B>影響度の編集がすべて終わったら、E3DCreateSkinMatを呼んで</B>表示に反映させてください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツの番号を指定します。<BR>
      <BR>
      　　E3DGetPartNoByNameで取得した番号を渡してください。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　頂点の番号<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DNormalizeInfElem</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響度情報を正規化します。<BR>
      <BR>
      指定した頂点の影響度の合計が１になるように、各影響度を合計値で割り算します。<BR>
      <BR>
      <B>vertno</B>に-1を指定すると、<BR>
      <U>指定パーツの</U>全頂点に対して<BR>
      正規化を行います。<BR>
      <BR>
      この命令を呼んだだけでは表示には反映されません。<BR>
      <B>影響度の編集がすべて終わったら、E3DCreateSkinMatを呼んで</B>表示に反映させてください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツの番号を指定します。<BR>
      <BR>
      　　E3DGetPartNoByNameで取得した番号を渡してください。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　頂点の番号<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConfGroundPart</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">地面の指定パーツとキャラクターとの当たり判定を行います。<BR>
      <BR>
      地面のパーツ番号を指定する他は、<BR>
      E3DChkConfGroundと同じです。<BR>
      E3DChkConfGroundの説明をお読みください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　charahsid<BR>
      　　移動する形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　groundhsid<BR>
      　　E3DLoadGroundBMP、<BR>
      　　または、E3DLoadMQOFileAsGroundで<BR>
      　　作成した形状データを<BR>
      　　識別するid<BR>
      <BR>
      3. [IN] int　：　groundpart<BR>
      　　当たり判定をしたい地面のパーツの番号を指定します。<BR>
      　　E3DGetPartNoByNameで取得した番号を<BR>
      　　指定してください。<BR>
      <BR>
      4. [IN] int　：　mode<BR>
      　　０を指定すると、飛ぶモード<BR>
      　　１を指定すると、地面を這うモード<BR>
      <BR>
      5. [IN] float　：　diffmaxy<BR>
      　　一度の移動で登ることが出来る高さの最大値を<BR>
      　　指定してください。<BR>
      <BR>
      6. [IN] float　：　mapminy<BR>
      　　groundhsidで識別されるデータの一番低いＹ座標の値<BR>
      <BR>
      7. [OUT] int*　：　resultptr<BR>
      　　あたり判定の結果が代入されます。<BR>
      　　<BR>
      　　mode == 0 のとき<BR>
      　　　　ぶつからなかった場合はresutl = 0<BR>
      　　　　ぶつかった場合はresult = 1<BR>
      　　mode == 1のとき<BR>
      　　　　キャラクターの下に地面が無かった場合、<BR>
      　　　　または、全く移動しなかった場合、<BR>
      　　　　result = 0<BR>
      <BR>
      　　　　diffmaxyより高い高さを登ろうとしたとき、<BR>
      　　　　result = 1<BR>
      <BR>
      　　　　地面を下に降りたとき、<BR>
      　　　　または、diffmaxyより低い高さを登ったとき、<BR>
      　　　　result = 2<BR>
      <BR>
      　　となります。<BR>
      <BR>
      8. [OUT] D3DXVECTOR3*　：　adjustptr<BR>
      　　result != 0 のときに、<BR>
      　　　　mode == 0のときは、ぶつかった座標<BR>
      　　　　mode == 1のときは、地面の座標が代入されます。<BR>
      <BR>
      9. [OUT] D3DXVECTOR3*　：　nptr<BR>
      　　result != 0 のときに、<BR>
      　　　　mode == 0のときは、ぶつかったポリゴン<BR>
      　　　　mode == 1のときは、地面のポリゴンの<BR>
      　　　　法線ベクトルが代入されます。<BR>
      　　　　<BR>
      　　　　跳ね返る方向を決めるときなどに<BR>
      　　　　使用できるのではないかと思い<BR>
      　　　　加えてみました。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConfGroundVecPart</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">地面パーツを指定して、線分と地面の当たり判定を行います。<BR>
      <BR>
      パーツを指定すること以外は<BR>
      E3DChkConfGround2と同じです。<BR>
      <BR>
      詳しくは、E3DChkConfGround2の説明をお読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　befpos<BR>
      　　線分の始点を指定します。<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　newpos<BR>
      　　線分の終点を指定します。<BR>
      <BR>
      3. [IN] int　：　groundhsid<BR>
      　　E3DLoadGroundBMP、<BR>
      　　または、E3DLoadMQOFileAsGroundで<BR>
      　　作成した形状データを<BR>
      　　識別するid<BR>
      <BR>
      4. [IN] int　：　groundpart<BR>
      　　地面のパーツ番号を指定します。<BR>
      　　E3DGetPartNoByNameで取得した番号を<BR>
      　　指定してください。<BR>
      <BR>
      5. [IN] int　：　mode<BR>
      　　０を指定すると、飛ぶモード<BR>
      　　１を指定すると、地面を這うモード<BR>
      <BR>
      6. [IN] float　：　diffmaxy<BR>
      　　一度の移動で登ることが出来る高さの最大値を<BR>
      　　指定してください。<BR>
      <BR>
      7. [IN] float　：　mapminy<BR>
      　　groundhsidで識別されるデータの一番低いＹ座標の値<BR>
      <BR>
      8. [OUT] int*　：　resultptr<BR>
      　　あたり判定の結果が代入されます。<BR>
      　　<BR>
      　　mode == 0 のとき<BR>
      　　　　ぶつからなかった場合は、resutl = 0<BR>
      　　　　ぶつかった場合は、result = 1<BR>
      　　mode == 1のとき<BR>
      　　　　キャラクターの下に地面が無かった場合、<BR>
      　　　　または、全く移動しなかった場合、<BR>
      　　　　result = 0<BR>
      <BR>
      　　　　diffmaxyより高い高さを登ろうとしたとき、<BR>
      　　　　result = 1<BR>
      <BR>
      　　　　地面を下に降りたとき、<BR>
      　　　　または、diffmaxyより低い高さを登ったとき、<BR>
      　　　　result = 2<BR>
      <BR>
      9. [OUT] D3DXVECTOR3*　：　adjustptr<BR>
      　　result != 0 のときに、<BR>
      　　　　mode == 0のときは、ぶつかった座標<BR>
      　　　　mode == 1のときは、地面の座標が代入されます。<BR>
      <BR>
      10. [OUT] D3DXVECTOR3*　：　nptr<BR>
      　　result != 0 のときに、<BR>
      　　　　mode == 0のときは、ぶつかったポリゴン<BR>
      　　　　mode == 1のときは、地面のポリゴンの<BR>
      　　　　法線ベクトルが代入されます。<BR>
      　　　　<BR>
      　　　　跳ね返る方向を決めるときなどに<BR>
      　　　　使用できるのではないかと思い<BR>
      　　　　加えてみました。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetNextMotionFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">モーションの最後のフレーム番号に到達した後、どのモーションのどのフレーム番号にジャンプするかを指定できます。<BR>
      <BR>
      この関数で次のモーションの指定を行っておけば、E3DSetNewPoseで自動的にモーションが切り替わります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　srcmotid<BR>
      3. [IN] int　：　nextmotid<BR>
      4. [IN] int　：　nextframeno<BR>
      5. [IN] int　：　befframeno<BR>
      　　srcmotidのモーションがbefframenoに達した後、nextmotidのモーションの、nextframenoのフレーム番号に、ジャンプするように設定されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetLinearFogParams</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">頂点フォグ（線形）を設定します。<BR>
      <BR>
      頂点フォグなのでポリゴンのない部分にはフォグはかかりません。<BR>
      画面全体にフォグをかけたい場合は、<BR>
      E3DCreateBGで背景を作成してください。（背景はポリゴンです。）<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　enable<BR>
      　　１を指定すると、フォグが有効に、<BR>
      　　０を指定すると、フォグが無効になります。<BR>
      <BR>
      2. [IN] E3DCOLOR4UC　：　col<BR>
      <BR>
      　　フォグの色を指定します。<BR>
      　　col.aは無視されます。<BR>
      <BR>
      3. [IN] int　：　start<BR>
      4. [IN] int　：　end<BR>
      　　フォグが開始される距離をstartに、<BR>
      　　フォグが終了する（一番濃くなる）距離をendに<BR>
      　　指定します。<BR>
      　　距離は、カメラからの距離です。<BR>
      <BR>
      5. [IN] int　：　hsid<BR>
      　　この引数に、モデルデータのhsidを<BR>
      　　指定することにより、<BR>
      　　モデル単位でのフォグの指定が可能になります。<BR>
      　　特殊効果などで、フォグをかけたくない場合などの<BR>
      　　表示にお使いください。<BR>
      　　この引数に-1を指定した場合は、<BR>
      　　すべてのモデルデータに対して設定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConflictOBBArray</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">２つの形状データの指定したパーツ同士が衝突しているかどうを判定します。<BR>
      <BR>
      パーツの番号に配列を指定できること以外は、<BR>
      ほとんどE3DChkConflict2と同じです。<BR>
      （inviewflagが微妙に違います）<BR>
      <BR>
      <BR>
      パーツ番号には<BR>
      E3DGetPartNoByNameで取得した<BR>
      パーツの番号を渡してください。<BR>
      <BR>
      partnoに-1を指定すると<BR>
      モデル全体とあたり判定をします。<BR>
      <BR>
      <BR>
      （判定の元になるデータは<BR>
      E3DChkInView命令によって、更新されます。）<BR>
      <BR>
      <BR>
      すべてのパーツが視野外だった場合は<BR>
      inviewflagに３が、<BR>
      ひとつでも視野内のパーツがあった場合は<BR>
      inviewflagに０が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid1<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int*　：　partno1<BR>
      　　hsid1のモデル中のパーツの番号の配列<BR>
      　　int partno1[partnum1];<BR>
      　　などで配列を作成し、それぞれの配列要素に<BR>
      　　判定をしたいパーツの番号を入れてください。<BR>
      <BR>
      3. [IN] int　：　partnum1<BR>
      　　partno1に値をセットした要素数を指定してください。<BR>
      <BR>
      <BR>
      4. [IN] int　：　hsid2<BR>
      　　形状データを識別するid<BR>
      <BR>
      5. [IN] int*　：　partno2<BR>
      　　hsid2のモデル中のパーツの番号の配列<BR>
      　　int partno2[partnum2];<BR>
      　　などで配列を作成しそれぞれの配列要素に<BR>
      　　判定をしたいパーツの番号を入れてください。<BR>
      <BR>
      6. [IN] int　：　partnum2<BR>
      　　partno2に値をセットした要素数を指定してください。<BR>
      <BR>
      <BR>
      7. [OUT] int*　：　confflagptr<BR>
      　　hsid1, hsid2で識別される形状同士が、<BR>
      　　衝突している場合は１が、<BR>
      　　衝突していない場合は０がセットされる。<BR>
      <BR>
      8. [OUT] int*　：　inviewflag<BR>
      　　すべてのパーツが視野外だった場合は<BR>
      　　inviewflagに３が、<BR>
      　　１つでも視野内のパーツがあった場合は<BR>
      　　inviewflagに０が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConflictBSPartArray</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">境界球によるあたり判定を任意のパーツごとに行います。<BR>
      <BR>
      パーツの番号に配列を指定できること以外は<BR>
      E3DChkConfBySphere2と同じです。<BR>
      <BR>
      <BR>
      判定の際に<U>E3DChkInViewでセットした<BR>
      データを使用します</U>。<BR>
      <BR>
      <BR>
      パーツ番号には<BR>
      E3DGetPartNoByNameで取得した<BR>
      パーツの番号を渡してください。<BR>
      <BR>
      パーツ番号に-1を指定すると<BR>
      モデル全体とあたり判定をします。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid1<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int*　：　partno1<BR>
      　　hsid1のモデル中のパーツの番号の配列<BR>
      　　int partno1[partnum1];<BR>
      　　などで配列を作成しそれぞれの配列要素に<BR>
      　　判定をしたいパーツの番号を入れてください。<BR>
      <BR>
      3. [IN] int　：　partnum1<BR>
      　　partno1に値をセットした要素数を指定してください。<BR>
      <BR>
      4. [IN] int　：　hsid2<BR>
      　　形状データを識別するid<BR>
      <BR>
      5. [IN] int*　：　partno2<BR>
      　　hsid2のモデル中のパーツの番号の配列<BR>
      　　int partno2[partnum2];<BR>
      　　などで配列を作成しそれぞれの配列要素に<BR>
      　　判定をしたいパーツの番号を入れてください。<BR>
      <BR>
      6. [IN] int　：　partnum2<BR>
      　　partno2に値をセットした要素数を指定してください。<BR>
      <BR>
      <BR>
      7. [OUT] int*　：　confflagptr<BR>
      　　hsid1, hsid2で識別される形状同士が<BR>
      　　衝突している場合は１が、<BR>
      　　衝突していない場合は０がセットされる。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMovableAreaThread</TD>
      <TD class="hpb-cnt-tb-cell2">壁</TD>
      <TD class="hpb-cnt-tb-cell2">スレッドを作成してE3DSetMovableAreaを実行します。<BR>
      <BR>
      作成したスレッドを識別するためのＩＤが<BR>
      threadidに代入されます。<BR>
      <BR>
      スレッドの作成に失敗した場合には、<BR>
      threadidにマイナスの値が代入されます。<BR>
      <BR>
      threadidは<BR>
      E3DChkThreadWorkingに使用することが<BR>
      出来ます。<BR>
      <BR>
      スレッド作成関数は全部で4098回まで<BR>
      呼ぶことが出来ます。<BR>
      （E3DChkThreadWorkingを除く）<BR>
      E3DFreeThreadの説明もご覧ください。<BR>
      <BR>
      <BR>
      スレッドが終了すると、<BR>
      E3DChkThreadWorkingで取得される<BR>
      returnval1に、<BR>
      モデルデータを識別するhsidが代入されます。<BR>
      <BR>
      E3DSetMovableAreaの説明も、お読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename1<BR>
      　　壁の座標情報の元となるＢＭＰファイル名<BR>
      <BR>
      2. [IN] float　：　maxx<BR>
      　　壁のＸ座標の最大値<BR>
      <BR>
      3. [IN] float　：　maxz<BR>
      　　壁のＺ座標の最大値<BR>
      <BR>
      4. [IN] int　：　divx<BR>
      　　X方向の分割数<BR>
      <BR>
      5. [IN] int　：　divz<BR>
      　　Z方向の分割数<BR>
      <BR>
      6. [IN] float　：　wallheight<BR>
      　　作成する壁の高さ<BR>
      <BR>
      7. [OUT] int*　：　threadidptr<BR>
      　　作成したスレッドを識別するＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadMOAFile</TD>
      <TD class="hpb-cnt-tb-cell2">モーションアクセラレータ</TD>
      <TD class="hpb-cnt-tb-cell2">モーションアクセラレータファイル（*.moa）を読み込みます。<BR>
      <BR>
      moaと同じフォルダに<BR>
      moaに記述されている全てのquaファイルが存在しないと<BR>
      エラーになります。<BR>
      <BR>
      詳しくは、マニュアルのrdb2_ma.htmと<BR>
      e3dhsp3_MotionAccelerator.hsp<BR>
      をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　どのモデルデータに対するmoaかを指定する。<BR>
      <BR>
      2. [IN] char*　：　fname<BR>
      　　*.moaのパス文字列。<BR>
      <BR>
      3. [IN] int　：　FillUpFrameLength<BR>
      　　補間モーションのフレーム長<BR>
      　　ver5.3.2.6以降では、-1を指定するとmoaファイルに記述されているフレーム長を読み込みます。<BR>
      <BR>
      4. [IN] float　：　mvmult<BR>
      　　モーションの移動成分に掛ける倍率<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.3.2.6で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetNewPoseByMOA</TD>
      <TD class="hpb-cnt-tb-cell2">モーションアクセラレータ</TD>
      <TD class="hpb-cnt-tb-cell2">モーションアクセラレータに基づいてモーションの更新をします。E3DSetNewPoseの代わりに呼んでください。<BR>
      <BR>
      詳しくは、マニュアルの、rdb2_ma.htmと<BR>
      e3dhsp3_MotionAccelerator.hsp<BR>
      をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID<BR>
      <BR>
      2. [IN] int　：　eventno<BR>
      　　イベント番号<BR>
      　　詳しくは、マニュアルのrdb2_ma.htmをご覧ください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMotionFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">カレント（現在の）のモーション番号とフレーム番号を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [OUT] int*　：　motidptr<BR>
      　　モーションを識別する番号<BR>
      <BR>
      3. [OUT] int*　：　frameptr<BR>
      　　フレーム番号<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetKeyboardCnt</TD>
      <TD class="hpb-cnt-tb-cell2">キーボード</TD>
      <TD class="hpb-cnt-tb-cell2">256 個の仮想キーの状態(カウンター)を指定されたバッファkeybufへコピーします。<BR>
      <BR>
      <BR>
      E3DGetKeyboardState関数は、呼び出し時にキーが押されているかどうかしか取得できませんが、<BR>
      E3DGetKeyboardCnt関数は、どのくらいの時間押し続けているかを表すカウンターを取得できます。<BR>
      <BR>
      Easy3D内部で、<BR>
      前回のきーの情報を保存しておき、<BR>
      呼び出し時にキーが押されていれば<BR>
      カウンターを１増やします。<BR>
      押されていなければカウンターを０にします。<BR>
      <BR>
      <BR>
      <U>keybuf はこの関数を使用する前に、<BR>
      int keybuf[256];<BR>
      で、確保してください。<BR>
      </U><BR>
      複数のキーの状態を一度の呼び出しで<BR>
      取得できます。<BR>
      <BR>
      例えば、Ａキーのカウンタを調べる場合は、<BR>
      E3DGetKeyboardCnt<BR>
      呼び出し後に<BR>
      keybuf['A'] の値を調べます。<BR>
      （　’　を忘れずに。　）<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　keybuf<BR>
      　　keybufにキーの状態(カウンタ)が代入されます。<BR>
      　　keybufは、int keybuf[256];で<BR>
      　　作成されている必要があります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DResetKeyboardCnt</TD>
      <TD class="hpb-cnt-tb-cell2">キーボード</TD>
      <TD class="hpb-cnt-tb-cell2">E3DGetKeyboardCntが内部で使用する前回のキーの情報をリセットします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">なし</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DEncodeBeta</TD>
      <TD class="hpb-cnt-tb-cell2">簡易暗号化</TD>
      <TD class="hpb-cnt-tb-cell2">ファイルの内容を暗号化します。<BR>
      <BR>
      暗号化といっても超簡易な方法ですので、<BR>
      プログラムに詳しい人なら復号できてしまう程度のものです。<BR>
      <BR>
      ファイルを暗号化して内容を上書きします。<BR>
      暗号化したファイルに対して<BR>
      この関数を呼べば、暗号化前のファイルに戻ります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　簡易暗号化するファイル名<BR>
      <BR>
      2. [IN] int*　：　rnd10<BR>
      　　簡易暗号化する際に使用する、<BR>
      　　ランダムなキー配列を指定します。<BR>
      　　キーは１０個指定します。<BR>
      　　キーの値は０から２５５の値を使用してください。<BR>
      　　int rnd10[10];<BR>
      　　で配列を作成してから値をセットしてください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDecodeBeta</TD>
      <TD class="hpb-cnt-tb-cell2">簡易暗号化</TD>
      <TD class="hpb-cnt-tb-cell2">E3DEncodeBetaで暗号化したファイルをバッファ上で復号します。<BR>
      <BR>
      バッファはmallocで確保してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　復号するファイル名<BR>
      <BR>
      2. [IN] int*　：　rnd10<BR>
      　　E3DEncodeBetaで使用したのと同じ内容の<BR>
      　　キー配列。<BR>
      <BR>
      3. [OUT] char*　：　dstbuffer<BR>
      　　復号した内容がセットされます。<BR>
      　　ファイルの長さをflengthとした場合<BR>
      　　dstbuffer = (char*)malloc( sizeof( char ) * flength );<BR>
      　　で作成したバッファーを指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMoaInfo</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">Moaファイルを読み込んだ場合のモーションの名前とIDを取得します。<BR>
      <BR>
      MOAINFO構造体はusercoef.hで定義されています。<BR>
      <BR>
      motmaxnumは、大き目の値を設定してください。<BR>
      この値が実際のモーションの数よりも小さいとエラーになります。<BR>
      <BR>
      moainfoptrは<BR>
      moainfoptr = (MOAINFO*)malloc( sizeof( MOAINFO ) * motmaxnum );<BR>
      で作成した配列を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　motmaxnum<BR>
      　　データ取得用配列の大きさ（モーションの数）を指定します。<BR>
      <BR>
      3. [OUT] MOAINFO*　：　moainfoptr<BR>
      　　情報を取得するための配列を渡してください。<BR>
      <BR>
      4. [OUT] int　：　motgetnumptr<BR>
      　　何個のモーションの情報を出力したかが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetNextMotionFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">E3DSetNextMotionFrameNoで設定した情報を取得します。<BR>
      <BR>
      Moaファイルを読み込んで<BR>
      E3DSetNewPoseByMOAを使用する場合、<BR>
      モーションとモーションの間に補間モーションが入ります。<BR>
      この補間モーションのモーションIDはver5001では常に０です。<BR>
      <BR>
      この補間モーションにはE3Dが内部で、<BR>
      次のモーションをE3DSetNextMotionFrameNoでセットしています。<BR>
      <BR>
      つまり、この補間モーションに対して<BR>
      E3DGetNextMotionFrameNoを呼び出せば、<BR>
      次に再生するモーションの情報が取得できるというわけです。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　現在のモーションのID<BR>
      <BR>
      <BR>
      3. [OUT] int*　：　nextmotionidptr<BR>
      　　次に再生されるモーションのID<BR>
      <BR>
      4. [OUT] int*　：　nextframeptr<BR>
      　　フレーム番号</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetScreenPos3F</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">形状データの画面上での2Dの座標を取得する関数です。<BR>
      奥行き情報Zも取得できます。<BR>
      <BR>
      パーツ単位、モデル単位、ビルボード単位で<BR>
      使用できます。<BR>
      <BR>
      頂点単位での２Ｄ座標も取得できます。<BR>
      <BR>
      ３Ｄキャラクターの位置に2Dのスプライトを表示するなどの用途に使えます。<BR>
      <BR>
      Z情報はスプライト描画時のZ指定の値に使用できます。<BR>
      <BR>
      <BR>
      <U><B>E3DChkInViewより後で呼び出してください。</B></U><BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      　　-1を指定すると、ビルボードの２Ｄ位置を取得できます。<BR>
      <BR>
      3. [IN] int　：　partno<BR>
      　　設定したいパーツの番号を指定します。<BR>
      <BR>
      　　E3DGetPartNoByNameで取得した番号を渡してください。<BR>
      <BR>
      　　hsidに-1を指定した場合は、<BR>
      　　E3DCreateBillboardで取得した、<BR>
      　　ビルボードidを渡してください。<BR>
      <BR>
      　　partnoに-1を渡すと、<BR>
      　　モデル全体の中心座標の２Ｄ座標を<BR>
      　　取得できます。<BR>
      <BR>
      4. [IN] int　：　vertno<BR>
      　　取得したい頂点の番号を指定します。<BR>
      　　-1を指定した場合は<BR>
      　　パーツの中心の２Ｄ座標を取得します。<BR>
      <BR>
      <BR>
      5. [OUT] D3DXVECTOR3*　：　scposptr<BR>
      　　指定したパーツの2Dスクリーン座標が<BR>
      (scposptr-&gt;x, scposptr-&gt;y)に代入されます。<BR>
      <BR>
      　　scpospptr-&gt;zは奥行き情報です。<BR>
      　　この値に０から１の範囲外の値が得られた場合は、<BR>
      　　画面に描画されない頂点です。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DEnableToonEdge</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">輪郭線のオンオフをします。<BR>
      <BR>
      トゥーン設定されたsigを読み込んでいる状態か、<BR>
      もしくは、E3DSetShaderTypeでCOL_TOON1を設定している状態か<BR>
      でしか機能しません。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　設定したいパーツの番号を指定します。<BR>
      　　E3DGetPartNoByNameで取得した番号を<BR>
      　　渡してください。<BR>
      <BR>
      　　partnoに-1を渡すと、<BR>
      　　モデル全体の輪郭線のオンオフをします。<BR>
      <BR>
      3. [IN] int　：　type<BR>
      　　輪郭線のタイプを指定します。<BR>
      　　０を指定してください。<BR>
      <BR>
      4. [IN] int　：　flag<BR>
      　　輪郭をオンにしたい場合は１を、<BR>
      　　オフにしたい場合は０を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetToonEdge0Color</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">輪郭線の色をセットします。<BR>
      <BR>
      トゥーン設定されたsigを読み込んでいる状態か、<BR>
      もしくは、E3DSetShaderTypeでCOL_TOON1を設定している状態か<BR>
      でしか機能しません。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　設定したいパーツの番号を指定します。<BR>
      　　E3DGetPartNoByNameで取得した番号を<BR>
      　　渡してください。<BR>
      <BR>
      　　partnoに-1を渡すと、<BR>
      　　モデル全体の輪郭線の色を設定します。<BR>
      <BR>
      3. [IN] char*　：　materialname<BR>
      　　マテリアルの名前を指定します。<BR>
      　　RokDeBone2の「トゥ」ボタンを押したときに<BR>
      　　リストボックスに表示されるマテリアル名を<BR>
      　　指定してください。<BR>
      <BR>
      　　partnoに-1を指定している場合は、<BR>
      　　&quot;dummy&quot;と指定してください。<BR>
      <BR>
      4. [IN] E3DCOLOR4UC　：　col<BR>
      　　色を指定します。<BR>
      　　col.aは無視されます。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetToonEdge0Width</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">輪郭線の幅をセットします。<BR>
      <BR>
      トゥーン設定されたsigを読み込んでいる状態か、<BR>
      もしくは、E3DSetShaderTypeでCOL_TOON1を設定している状態か<BR>
      でしか機能しません。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　設定したいパーツの番号を指定します。<BR>
      　　E3DGetPartNoByNameで取得した番号を<BR>
      　　渡してください。<BR>
      <BR>
      　　partnoに-1を渡すと、<BR>
      　　モデル全体の輪郭線の色を設定します。<BR>
      <BR>
      3. [IN] char*　：　materialname<BR>
      　　マテリアルの名前を指定します。<BR>
      　　RokDeBone2の「トゥ」ボタンを押したときに<BR>
      　　リストボックスに表示されるマテリアル名を<BR>
      　　指定してください。<BR>
      <BR>
      　　partnoに-1を指定している場合は、<BR>
      　　&quot;dummy&quot;と指定してください。<BR>
      <BR>
      4. [IN] float　：　width<BR>
      　　輪郭の幅を指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetToonEdge0Color</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">輪郭線の色を取得します。<BR>
      <BR>
      トゥーン設定されたsigを読み込んでいる状態か、<BR>
      もしくは、E3DSetShaderTypeでCOL_TOON1を設定している状態か<BR>
      でしか機能しません。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　設定したいパーツの番号を指定します。<BR>
      　　E3DGetPartNoByNameで取得した番号を<BR>
      　　渡してください。<BR>
      <BR>
      3. [IN] char*　：　materialname<BR>
      　　マテリアルの名前を指定します。<BR>
      　　RokDeBone2の「トゥ」ボタンを押したときに<BR>
      　　リストボックスに表示されるマテリアル名を<BR>
      　　指定してください。<BR>
      <BR>
      4. [OUT] E3DCOLOR4UC*　：　colptr<BR>
      　　輪郭の色が代入されます。<BR>
      　　colptr-&gt;aは無視されます。<BR>
      <BR>
      　　指定したマテリアルが見つからなかった場合は<BR>
      　　(0, 0, 0)が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetToonEdge0Width</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">輪郭線の幅を取得します。<BR>
      <BR>
      トゥーン設定されたsigを読み込んでいる状態か、<BR>
      もしくは、E3DSetShaderTypeでCOL_TOON1を設定している状態か<BR>
      でしか機能しません。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　設定したいパーツの番号を指定します。<BR>
      　　E3DGetPartNoByNameで取得した番号を<BR>
      　　渡してください。<BR>
      <BR>
      3. [IN] char*　：　materialname<BR>
      　　マテリアルの名前を指定します。<BR>
      　　RokDeBone2の「トゥ」ボタンを押したときに<BR>
      　　リストボックスに表示されるマテリアル名を<BR>
      　　指定してください。<BR>
      <BR>
      4. [OUT] float*　：　widthptr<BR>
      　　輪郭の幅が代入されます。<BR>
      <BR>
      　　指定したマテリアルが見つからなかった場合は、<BR>
      　　0.0が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateParticle</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクル</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクルを作成します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　maxnum<BR>
      　　表示できるパーティクルの最大数を指定します。<BR>
      　　２０００以下の数字を指定してください。<BR>
      <BR>
      2. [IN] char*　：　texname<BR>
      　　テクスチャー名をフルパスで指定します。<BR>
      <BR>
      3. [IN] float　：　width<BR>
      　　パーティクルの幅を指定します。<BR>
      <BR>
      4. [IN] float　：　height<BR>
      　　パーティクルの高さを指定します。<BR>
      <BR>
      5. [IN] int　：　blendmode<BR>
      　　半透明のブレンドモードを指定します。<BR>
      　　０を指定すると<BR>
      　　テクスチャのアルファによるブレンドをします。<BR>
      　　１を指定すると<BR>
      　　アッドモードでのブレンドをします。<BR>
      　　２を指定すると<BR>
      　　頂点のアルファを考慮した<BR>
      　　アッドモードブレンドをします。<BR>
      <BR>
      6. [IN] int　：　transparentflag<BR>
      　　１を指定すると黒色を透過します（BMP用）。<BR>
      　　０を指定すると画像ファイルのアルファをそのまま使います。<BR>
      <BR>
      7. [IN] int　：　cmpalways<BR>
      　　１を指定するとZバッファの比較を行わずに常に描画するようになります。<BR>
      　　通常はは０。<BR>
      <BR>
      8. [OUT] int*　：　particleidptr<BR>
      　　パーティクルを識別するIDが代入されます。<BR>
      <BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyParticle</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクル</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクルを破棄します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　particleid<BR>
      　　削除したいパーティクルを識別するIDを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetParticlePos</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクル</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクルの場所を設定します。<BR>
      設定した場所からパーティクルが噴き出します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　particleid<BR>
      　　パーティクルを識別するIDを指定します。<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　pos<BR>
      　　パーティクルの位置を指定します。<BR>
      　<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetParticleGravity</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクル</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクルの重力を設定します。<BR>
      設定した値はY方向の負の加速度として計算に使用されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　particleid<BR>
      　　パーティクルを識別するIDを指定します。<BR>
      <BR>
      2. [IN] float　：　gravity<BR>
      　　重力を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetParticleLife</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクル</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクルの寿命を設定します。<BR>
      パーティクルが噴き出してから消えるまでの時間を<BR>
      秒で指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　particleid<BR>
      　　パーティクルを識別するIDを指定します。<BR>
      <BR>
      2. [IN] float　：　life<BR>
      　　パーティクルの寿命を指定します。<BR>
      　　秒。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetParticleEmitNum</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクル</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクルの生成個数をします。<BR>
      E3DRenderParticleを呼ぶたびに指定した個数だけ生成されます。<BR>
      小数での指定が可能です。<BR>
      例えば０．２と指定した場合は、<BR>
      ５回E3DRenderParticleを呼び出すごとに１個パーティクルが<BR>
      生成されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　particleid<BR>
      　　パーティクルを識別するIDを指定します。<BR>
      <BR>
      2. [IN] float　：　emitnum<BR>
      　　パーティクルの１回あたりの生成個数を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetParticleVel0</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクル</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクルの速度を指定します。<BR>
      <BR>
      速度の最低値をminvelに指定し、<BR>
      速度の最大値をmaxvelに指定します。<BR>
      <BR>
      最低値と最大値の幅が広いほど、<BR>
      パーティクルは、まばらに放出されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　particleid<BR>
      　　パーティクルを識別するIDを指定します。<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　minvel<BR>
      　　パーティクルの速度の最小値を指定します。<BR>
      <BR>
      3. [IN] D3DXVECTOR3　：　maxvel<BR>
      　　パーティクルの速度の最大値を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetParticleRotation</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクル</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクルの回転を指定します。<BR>
      <BR>
      この関数を呼び出すたびに、<BR>
      パーティクルが指定角度だけ回転します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　particleid<BR>
      　　パーティクルを識別するIDを指定します。<BR>
      <BR>
      2. [IN] float　：　rotation<BR>
      　　パーティクルの回転を角度（度）で指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetParticleDiffuse</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクル</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクルの頂点色を指定します。<BR>
      <BR>
      テクスチャ色とモジュレートされて表示されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　particleid<BR>
      　　パーティクルを識別するIDを指定します。<BR>
      <BR>
      2. [IN] E3DCOLOR4UC　：　col<BR>
      　　パーティクルの頂点色を指定します。<BR>
      　　col.aは無視されます。<BR>
      <BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRenderParticle</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクル</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクルを描画します。<BR>
      <BR>
      呼び出すたびに、パーティクルの消滅、生成、位置移動をして<BR>
      描画します。<BR>
      <BR>
      1.0 / fps 秒だけ時間を進めて描画します。<BR>
      fpsにマイナスの値を指定した場合は、<BR>
      パーティクルが静止した状態で描画します。<BR>
      <BR>
      <BR>
      E3DCreateParticleで指定したmaxnum個より多いパーティクルは<BR>
      描画できません。<BR>
      パーティクルの噴出が途中で途切れる場合は、<BR>
      maxnumの値を増やすかまたは、<BR>
      E3DSetParticleEmitNumの値を小さくするかまたは、<BR>
      E3DSetParticleLifeに指定するlifeの値を小さくしてください。<BR>
      <BR>
      fps引数に１を指定すると各パーティクル関数の時間を秒ではなくてフレーム数で扱えます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　particleid<BR>
      　　パーティクルを識別するIDを指定します。<BR>
      <BR>
      3. [IN] int　：　fps<BR>
      　　１秒間に何回この関数を呼ぶかを<BR>
      　　指定してください。<BR>
      <BR>
      <BR>
      4. [IN] int　：　onlyupdate<BR>
      　　１を指定した場合は、<BR>
      　　描画を行わず状態のアップデートのみ行います。<BR>
      　　０を指定した場合や省略した場合は<BR>
      　　通常通りアップデートと描画を行います。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetParticleAlpha</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクル</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクルの透明度を設定します。<BR>
      <BR>
      パーティクルが放出されてからの時間帯ごとに、<BR>
      設定可能です。<BR>
      <BR>
      生成されてからの時間が、mintimeからmaxtimeの間にある<BR>
      パーティクルに対して処理を行います。<BR>
      <BR>
      負荷は気にしなくていい程度です。<BR>
      <BR>
      呼び出すたびに設定されます。<BR>
      ループ中で使用します。<BR>
      （一回だけ呼び出しても意味がありません）<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　particleid<BR>
      　　パーティクルを識別するIDを指定します。<BR>
      <BR>
      2. [IN] float　：　mintime<BR>
      3. [IN] float　：　maxtime<BR>
      　　処理したいパーティクルの時間帯を<BR>
      　　秒で指定します。<BR>
      <BR>
      4. [IN] float　：　alpha<BR>
      　　透明度を０から１の間のfloatで指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetParticleUVTile</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクル</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクルのUVを設定します。<BR>
      <BR>
      パーティクルが放出されてからの時間帯ごとに、<BR>
      設定可能です。<BR>
      <BR>
      生成されてからの時間がmintimeからmaxtimeの間にある<BR>
      パーティクルに対して処理を行います。<BR>
      <BR>
      この処理はビデオメモリにアクセスする必要があるので、<BR>
      ちょっと重い処理です。<BR>
      <BR>
      ひとつの画像にタイル画像を敷き詰めたテクスチャの、ＵＶ座標をタイル番号でセットできます。<BR>
      <BR>
      タイル状のテクスチャ画像とタイル番号の対応は、<A href="e3dhsp_texturetile.htm">タイル番号の説明</A>をご覧ください。<BR>
      <BR>
      <BR>
      呼び出すたびに設定されます。<BR>
      ループ中で使用します。<BR>
      （一回だけ呼び出しても意味がありません）<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　particleid<BR>
      　　パーティクルを識別するIDを指定します。<BR>
      <BR>
      2. [IN] float　：　mintime<BR>
      3. [IN] float　：　maxtime<BR>
      　　処理したいパーティクルの時間帯を<BR>
      　　秒で指定します。<BR>
      <BR>
      4. [IN] int　：　unum<BR>
      　　テクスチャの横方向の分割数を指定します。<BR>
      <BR>
      5. [IN] int　：　vnum<BR>
      　　テクスチャの縦方向の分割数を指定します。<BR>
      <BR>
      6. [IN] int　：　tileno<BR>
      　　設定したいタイル番号を指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DInitParticle</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクル</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクルの発生状態を初期状態に戻します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　particleid<BR>
      　　パーティクルを識別するIDを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DPickFacePartArray</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">２Ｄの画面の座標に対応する３Ｄモデルの座標を取得できます。<BR>
      <BR>
      判定したいパーツを指定できる点以外は、<BR>
      E3DPickFaceと同じです。<BR>
      詳しくはE3DPciFaceの説明をお読みください。<BR>
      <BR>
      パーツ番号３とパーツ番号４についてのみ判定を行いたい場合は、<BR>
      partnum = 2<BR>
      int partarray[2];<BR>
      partarray[ 0 ] = 3<BR>
      partarray[ 1 ] = 4<BR>
      の様に値をセットしてE3DPickFacePartArrayを呼び出してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
　　スワップチェインＩＤ。<BR>
　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
　　指定してください。<BR>
<BR>
      2. [IN] int　：　hsid<BR>
　　モデルを識別する番号を指定してください。<BR>
<BR>
      3. [IN] int*　：　partarray<BR>
　　判定したいパーツ番号を指定します。<BR>
      　　要素数partnumの配列のポインタを指定してください。<BR>
      <BR>
      4. [IN] int　：　partnum<BR>
　　partarray配列の要素数<BR>
<BR>
<BR>
      5. [IN] POINT　：　pos2d<BR>
      　　画面上の２Ｄ座標を指定してください。<BR>
<BR>
      6. [IN] float　：　maxdist<BR>
      　　どのくらいの距離まで３Ｄモデルの検索をするかを指定します。<BR>
      　　この値を小さくするほど処理は高速になります。<BR>
<BR>
      7. [OUT] int*　：　partno<BR>
      8. [OUT] int*　：　faceno<BR>
　　2D座標に対応する３Ｄ座標が見つかった場合に、<BR>
      　　その３Ｄモデルのパーツの番号と面の番号が<BR>
　　代入されます。<BR>
<BR>
      　　見つからなかった場合は-1が代入されます。<BR>
<BR>
      9. [OUT] D3DXVECTOR3*　：　pos3dptr<BR>
      　　２Ｄ座標に対応する３Ｄ座標が代入されます。<BR>
　　partnoに-1以外の値が代入されているときのみ、<BR>
　　これらの値は意味を持ちます。<BR>
      <BR>
      10. [OUT] D3DXVECTOR3*　：　nptr<BR>
      　　2D座標に対応する３Ｄ座標を含む面の法線ベクトルが<BR>
　　代入されます。<BR>
<BR>
　　ベクトルの大きさは１のものを代入します。<BR>
<BR>
　　partnoに-1以外の値が代入されているときのみ、<BR>
　　これらの値は意味を持ちます。<BR>
<BR>
      <BR>
      11. [OUT] float*　：　distptr<BR>
      　　視点とpos3dとの距離が代入されます。<BR>
　　partnoに-1以外の値が代入されているときのみ、<BR>
　　この値は意味を持ちます。<BR>
      <BR>
</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConfWallPartArray</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">E3DSetMovableArea, または、E3DLoadMQOFileAsMovableAreaで作成した壁データとキャラクターのあたり判定を行います。<BR>
      <BR>
      判定したい壁データのパーツ番号を指定できる点以外は<BR>
      E3DChkConfWallと同じです。<BR>
      詳しくは、E3DChkConfWallの説明をお読みください。<BR>
      <BR>
      壁モデルのパーツ番号３とパーツ番号４についてのみ、<BR>
      判定を行いたい場合は、<BR>
      partnum = 2<BR>
      int partarray[2];<BR>
      partarray[ 0 ] = 3<BR>
      partarray[ 1 ] = 4<BR>
      の用に値をセットしてE3DConfWall3を呼び出してください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　charahsid<BR>
　　移動する形状データを識別するid<BR>
<BR>
      2. [IN] int　：　groundhsid<BR>
　　E3DSetMovableArea、<BR>
　　または、E3DLoadMQOFileAsMovableAreaで<BR>
　　作成した形状データを<BR>
　　識別するid<BR>
<BR>
      3. [IN] int*　：　partarray<BR>
      　　判定したい壁のパーツ番号を指定します。<BR>
      　　要素数partnumの配列のポインタを渡してください。<BR>
      <BR>
      4. [IN] int　：　partnum<BR>
　　partarray配列の要素数<BR>
<BR>
      5. [IN] float　：　dist<BR>
　　跳ね返る距離。<BR>
      　　distに大きな値を入れると<BR>
      　　ぶつかった際に大きく跳ね返るようになります。<BR>
      <BR>
      6. [OUT] int*　：　resultptr<BR>
　　あたり判定の結果が代入されます。<BR>
      　　壁とぶつかった場合は１が、<BR>
      　　ぶつからなかった場合は０が代入されます。<BR>
<BR>
      7. [OUT] D3DXVECTOR3*　：　adjustptr<BR>
      　　result != 0 のときに、<BR>
      　　修正後の座標が代入されます。<BR>
      <BR>
      8. [OUT] D3DXVECTOR3*　：　nptr<BR>
      　　result != 0 のときに、<BR>
      　　ぶつかった面の法線ベクトルの値が<BR>
　　代入されます。<BR>
      <BR>
</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMotionIDByName</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">モーションの名前からモーションのIDを取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
　　形状データを識別するid<BR>
<BR>
      2. [IN] char*　：　motname<BR>
　　RokDeBone2で設定したモーションの名前。<BR>
<BR>
      3. [OUT] int*　：　motidptr<BR>
　　名前がmotnameであるモーションのIDが代入されます。<BR>
      　　見つからなかった場合は負の値が代入されます。<BR>
</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMotionNum</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">読み込んでいるモーションの総数を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
　　形状データを識別するid<BR>
<BR>
      2. [OUT] int*　：　motnumptr<BR>
      　　モーションの総数が代入されます。<BR>
</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkConfParticle</TD>
      <TD class="hpb-cnt-tb-cell2">当たり判定</TD>
      <TD class="hpb-cnt-tb-cell2">パーティクルとモデルデータのあたり判定をします。<BR>
      <BR>
      境界球を使用した判定を行います。<BR>
      <BR>
      モデルデータ側の境界球の半径が大きすぎるときは、<BR>
      rate引数に１より小さい値を指定して調整してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　ptclid<BR>
      　　パーティクルを識別するid<BR>
      <BR>
      2. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      3. [IN] float　：　rate<BR>
      　　モデルデータの境界球の半径に掛け算して<BR>
      　　判定します。<BR>
      　　１より小さい値を指定すれば、<BR>
      　　判定の感度が落ちます。<BR>
      <BR>
      4. [OUT] int*　：　confflagptr<BR>
      　　パーティクルとモデルデータが<BR>
      　　ぶつかっているときは１が<BR>
      　　ぶつかっていないときは０が代入されます。<BR>
      <BR>
<BR>
<BR>
</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadSigFileAsGround</TD>
      <TD class="hpb-cnt-tb-cell2">地面</TD>
      <TD class="hpb-cnt-tb-cell2">sigファイルを地面として読み込んでhsidを得る。<BR>
      <BR>
      sigファイルの読み込み速度はmqoファイルの読み込みよりも<BR>
      だいぶ速くなります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　fname<BR>
      　　*.sig のパス文字列。<BR>
      <BR>
      2. [IN] float　：　mult<BR>
      　　読み込み倍率を指定してください。<BR>
      　　等倍は１．０。<BR>
      <BR>
      3. [IN] int　：　adjustuvflag<BR>
      　　ＵＶ値を正規化するかどうかのフラグ。<BR>
      　　正規化する場合は１を指定。<BR>
      　　しない場合は０を指定。<BR>
      　　２を指定すると0.0から1.0の間にクランプします。<BR>
<BR>
<BR>
      <BR>
      4. [OUT] int*　：　hsidptr<BR>
      　　読み込んだ形状データを識別するhsidが代入されます。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>ver5.0.2.6で拡張<BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadSigFileAsGroundFromBuf</TD>
      <TD class="hpb-cnt-tb-cell2">地面</TD>
      <TD class="hpb-cnt-tb-cell2">メモリから地面データのロードを行います。<BR>
      メモリ内にはsigファイルと同じフォーマットが<BR>
      入っているとみなして処理します。<BR>
      <BR>
      テクスチャファイルは、通常読込と同様に<BR>
      ファイルから行います。<BR>
      <BR>
      resdirにはテクスチャの存在するフォルダのパスを指定してください。<BR>
      <B>最後に&quot;\\&quot;を付けるのを忘れないでください。</B><BR>
      <BR>
      例えば、<BR>
      &quot;C:\\hsp\\Meida\\&quot;<BR>
      などのように指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　resdir<BR>
      　　テクスチャーのあるフォルダ のパス文字列。<BR>
      　　最後に&quot;\\&quot;が必要。<BR>
      <BR>
      2. [IN] char*　：　buf<BR>
      　　バッファのポインタ<BR>
      <BR>
      3. [IN] int　：　bufleng<BR>
      　　バッファの中のデータの長さ<BR>
      <BR>
      4. [IN] int　：　adjustuvflag<BR>
      　　ＵＶ値を正規化するかどうかのフラグ。<BR>
      　　正規化する場合は１を指定。<BR>
      　　しない場合は０を指定。<BR>
      　　２を指定すると0.0から1.0の間にクランプします。<BR>
      <BR>
      5. [IN] float　：　mult<BR>
      　　読み込み倍率を指定してください。<BR>
      　　等倍は１．０。<BR>
      <BR>
      6. [OUT] int*　：　hsidptr<BR>
      　　読み込んだ形状データを識別するhsidが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>ver5.0.2.6で拡張<BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCenterPos</TD>
      <TD class="hpb-cnt-tb-cell2">モデル位置</TD>
      <TD class="hpb-cnt-tb-cell2">パーツの中心のグローバル座標を取得します。<BR>
      パーツの中心の座標はE3DChkInViewで計算されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　取得したいパーツの番号を指定します。<BR>
      　　E3DGetPartNoByNameで取得した番号を<BR>
      　　渡してください。<BR>
      <BR>
      　　-1を指定すると、モデル全体の中心座標が<BR>
      　　取得できます。<BR>
      <BR>
      3. [OUT] D3DXVECTOR3*　：　posptr<BR>
      　　中心の座標が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetFaceNum</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">指定した表示オブジェクトの面の総数を取得します。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　取得したいパーツの番号を指定します。<BR>
      　　E3DGetPartNoByNameで取得した番号を<BR>
      　　渡してください。<BR>
      <BR>
      3. [OUT] int*　：　facenumptr<BR>
      　　面の総数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetFaceNormal</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">指定した表示オブジェクトの面の法線を取得します。<BR>
      <BR>
      E3DGetFaceNumで取得した面の総数をfacenumとしたとき、<BR>
      faceno引数には０からfacenum - 1までの値を<BR>
      指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　取得したいパーツの番号を指定します。<BR>
      　　E3DGetPartNoByNameで取得した番号を<BR>
      　　渡してください。<BR>
      <BR>
      3. [IN] int　：　faceno<BR>
      　　面の番号を指定します。<BR>
      <BR>
      4. [OUT] D3DXVECTOR3*　：　nptr<BR>
      　　法線のベクトルが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateEmptyMotion</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">姿勢情報の入っていない空のモーションを作成します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] char*　：　motname<BR>
      　　モーションの名前の文字列。<BR>
      <BR>
      3. [IN] int　：　frameleng<BR>
      　　作成するモーションの長さ。フレーム長。<BR>
      <BR>
      4. [OUT] int*　：　motidptr<BR>
      　　作成したモーションを識別する番号が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetTextureMinMagFilter</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャーを拡大縮小表示する際のフィルターを指定します。<BR>
      <BR>
      ３Dモデル、背景、スプライト、ビルボードに指定できます。<BR>
      <BR>
      minfilter引数には縮小する際のフィルターを指定し、<BR>
      magfilter引数には拡大する際のフィルターを指定します。<BR>
      <BR>
      以下の２つの定数を使います。<BR>
      <BR>
      D3DTEXF_POINT<BR>
      最近点フィルタ。<BR>
      目的のピクセル値に最も近い座標のテクセルを使います。<BR>
      テクスチャがぼやけるのが嫌な場合などに使います。<BR>
      <BR>
      D3DTEXF_LINEAR<BR>
      双線形補間フィルタ。<BR>
      目的のピクセルを取り囲む 2 x 2 領域のテクセルの重み付けした平均を使います。<BR>
      なめらかな表示をしたいときに使います。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] 変数または、数値　：　scid<BR>
      　　スワップチェインID。<BR>
      　　この引数は、背景の指定の場合のみ意味を持ちます。<BR>
      <BR>
      <BR>
      2. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      　　E3DCreateBGで作成した背景に対して処理を行いたい場合は０を指定します。<BR>
      <BR>
      　　ビルボードに対して処理を行いたい場合は-1を指定します。<BR>
      <BR>
      　　スプライトに対して処理を行いたい場合は-2を指定します。<BR>
      <BR>
      3. [IN] int　：　partno<BR>
      　　形状データを識別するidを指定します。<BR>
      <BR>
      　　背景の場合は０を指定します。<BR>
      <BR>
      　　ビルボードの場合はビルボードIDを指定します。<BR>
      <BR>
      　　スプライトの場合はスプライトIDを指定します。<BR>
      <BR>
      <BR>
      4. [IN] int　：　minfilter<BR>
      　　縮小フィルター<BR>
      <BR>
      5. [IN] int　：　magfilter<BR>
      　　拡大フィルター<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMotionName</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">読み込み済みのモーションの名前を取得します。<BR>
      <BR>
      motname引数には<BR>
      char motname[256];<BR>
      で確保したメモリを指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別するid<BR>
      <BR>
      3. [OUT] char*　：　motname<BR>
      　　モーションの名前が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMotionName</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">モーションに名前を設定します。<BR>
      <BR>
      ２５５文字以下（２５５バイト以下）の名前を設定してください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別するid<BR>
      <BR>
      3. [IN] char*　：　motname<BR>
      　　モーションの名前を指定します。<BR>
      　　名前の長さは２５５文字（２５５バイト）までです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialNoByName</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル名からマテリアル番号を取得します。<BR>
      <BR>
      マテリアル名はRokDeBone2のメインメニューの<BR>
      「面マテリアル」メニューを押したときに現れるダイアログで確認できます。<BR>
      <BR>
      ver4.0.0.1以降のRokDeBone2でmqoからデータを読み込んでいる場合には、マテリアル名はメタセコイアの材質名と同じです。<BR>
      <BR>
      存在しないマテリアル名を渡した場合は、<BR>
      マテリアル番号には-3が返されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] char*　：　motname<BR>
      　　マテリアルの名前を指定します。<BR>
      　　名前の長さは２５５文字（２５５バイト）までです。<BR>
      <BR>
      3. [OUT] int*　：　matnoptr<BR>
      　　マテリアルの番号が代入されます。<BR>
      　　存在しない名前を渡した場合は-3が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialAlpha</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの透明度を取得します。<BR>
      <BR>
      透明度は0.0から1.0までのfloatです。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [OUT] float*　：　alphaptr<BR>
      　　透明度が代入されます。<BR>
      　　</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialDiffuse</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの拡散光（diffuse）を取得します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [OUT] E3DCOLOR4UC*　：　colptr<BR>
      　　diffuseのRGBが代入されます。<BR>
      　　colptr-&gt;aは無視されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialSpecular</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの反射光（specular）を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [OUT] E3DCOLOR4UC*　：　colptr<BR>
      　　specularのRGBが代入されます。<BR>
      　　colptr-&gt;aは無視されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialAmbient</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの周囲光（ambient）を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [OUT] E3DCOLOR4UC*　：　colptr<BR>
      　　ambientのRGBが代入されます。<BR>
      　　colptr-&gt;aは無視されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialEmissive</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの自己照明（emissiver）を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [OUT] E3DCOLOR4UC*　：　colptr<BR>
      　　emissiveのRGBが代入されます。<BR>
      　　colptr-&gt;aは無視されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialPower</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの反射の強さ(power)を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [OUT] float*　：　powerptr<BR>
      　　powerが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialBlendingMode</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの半透明モードを取得します。<BR>
      <BR>
      modeの値の意味は<BR>
      ０のとき<BR>
      頂点アルファ値による半透明モードです。<BR>
      <BR>
      １のとき　<BR>
      アッドモードです。<BR>
      <BR>
      ２のとき<BR>
      頂点アルファを考慮したアッドモードです。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [OUT] int*　：　modeptr<BR>
      　　半透明モードが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMaterialAlpha</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの透明度を設定します。<BR>
      <BR>
      透明度は0.0fから1.0fで指定します。<BR>
      <BR>
      マテリアルの変更により<BR>
      表示オブジェクトの対応する部分の表示が面単位で変化します。<BR>
      <BR>
      透明度１．０以外のものはE3DRenderのwithalpha引数に１を指定したときに表示されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [IN] float　：　alpha<BR>
      　　透明度。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMaterialDiffuse</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの拡散光(diffuse)を設定します。<BR>
      <BR>
      マテリアルの変更により<BR>
      表示オブジェクトの対応する部分の表示が面単位で変化します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [IN] int　：　setflag<BR>
      　　setflagが０のときは、<BR>
      　　色をcolにセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　パーツの色に（col.r/255, col.g/255, col.b/255）を乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　パーツの色にcolを足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　パーツの色からcolを減算します。<BR>
      <BR>
      <BR>
      4. [IN] E3DCOLOR4UC　：　col<BR>
      　　指定したい色をcolで指定します。<BR>
      　　col.aは無視されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMaterialSpecular</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの反射光(specular)を設定します。<BR>
      <BR>
      マテリアルの変更により<BR>
      表示オブジェクトの対応する部分の表示が面単位で変化します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [IN] int　：　setflag<BR>
      　　setflagが０のときは、<BR>
      　　色をcolにセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　パーツの色に（col.r/255, col.g/255, col.b/255）を乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　パーツの色にcolを足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　パーツの色からcolを減算します。<BR>
      <BR>
      <BR>
      4. [IN] E3DCOLOR4UC　：　col<BR>
      　　指定したい色をcolで指定します。<BR>
      　　col.aは無視されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMaterialAmbient</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの周囲光(ambient)を設定します。<BR>
      <BR>
      マテリアルの変更により<BR>
      表示オブジェクトの対応する部分の表示が面単位で変化します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [IN] int　：　setflag<BR>
      　　setflagが０のときは、<BR>
      　　色をcolにセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　パーツの色に（col.r/255, col.g/255, col.b/255）を乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　パーツの色にcolを足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　パーツの色からcolを減算します。<BR>
      <BR>
      <BR>
      4. [IN] E3DCOLOR4UC　：　col<BR>
      　　指定したい色をcolで指定します。<BR>
      　　col.aは無視されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMaterialEmissive</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの自己照明(emissive)を設定します。<BR>
      <BR>
      マテリアルの変更により<BR>
      表示オブジェクトの対応する部分の表示が面単位で変化します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [IN] int　：　setflag<BR>
      　　setflagが０のときは、<BR>
      　　色をcolにセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　パーツの色に（col.r/255, col.g/255, col.b/255）を乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　パーツの色にcolを足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　パーツの色からcolを減算します。<BR>
      <BR>
      <BR>
      4. [IN] E3DCOLOR4UC　：　col<BR>
      　　指定したい色をcolで指定します。<BR>
      　　col.aは無視されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMaterialPower</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの反射の強さ(power)を設定します。<BR>
      <BR>
      マテリアルの変更により<BR>
      表示オブジェクトの対応する部分の表示が面単位で変化します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [IN] int　：　setflag<BR>
      　　setflagが０のときは、<BR>
      　　powerをそのままセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　現在のマテリアルにpowerを乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　現在のマテリアルにpowerを足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　現在のマテリアルからpowerを減算します。<BR>
      <BR>
      <BR>
      4. [IN] float　：　power<BR>
      　　反射の強さを指定します。<BR>
      　<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMaterialBlendingMode</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの半透明モードを設定します。<BR>
      <BR>
      マテリアルの変更により<BR>
      表示オブジェクトの対応する部分の表示が面単位で変化します。<BR>
      <BR>
      blendmode 0, 1, 2はアルファテストの設定も変更します。<BR>
      アルファテストの設定を変更したくない場合は<BR>
      blendmode 100, 101, 102をお使いください。<BR>
      <BR>
      ver5.0.2.2でモードが４つ増えました。<BR>
      <BR>
      ver5.1.0.1でモードが２つ増えました。<BR>
      <BR>
      アルファテストを設定したい場合は<BR>
      E3DSetMaterialAlphaTestをご使用ください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [IN] int　：　blendmode<BR>
      　　０を指定すると<BR>
      　　頂点アルファ値による半透明モードになります。<BR>
      　　アルファテストはオフになります。<BR>
      <BR>
      　　１を指定すると　<BR>
      　　アッドモードになります。<BR>
      　　アルファテストはオンになり８より小さいアルファのときに描画されなくなります（Zバッファにも）。<BR>
      <BR>
      　　２を指定すると、<BR>
      　　頂点アルファを考慮したアッドモードになります。<BR>
      　　アルファテストはオフになります。<BR>
      <BR>
      <BR>
      　　１００を指定すると<BR>
      　　頂点アルファ値による半透明モードになります。<BR>
      　　アルファテストは変更しません。<BR>
      <BR>
      　　１０１を指定すると　<BR>
      　　アッドモードになります。<BR>
      　　アルファテストは変更しません。<BR>
      <BR>
      　　１０２を指定すると、<BR>
      　　頂点アルファを考慮したアッドモードになります。<BR>
      　　アルファテストは変更しません。<BR>
      <BR>
      　　１０３を指定すると乗算モード<BR>
      　　１０４を指定すると減算モード<BR>
      　　１０５を指定するとスクリーンモード<BR>
      　　１０６を指定するとネガ反転モードになります。<BR>
      <BR>
      <BR>
      　　１０７を指定するとオーバーレイ風合成モード。<BR>
      　　１０８を指定すると覆い焼き風モードになります。<BR>
      <BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.0.2.2で拡張<BR>
      ver5.1.0.1で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetTextureFromMaterial</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルに設定されているテクスチャを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [OUT] int*　：　texidptr<BR>
      　　テクスチャのIDが代入されます。<BR>
      　　エラーのときは-1が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetTextureToMaterial</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルにテクスチャを設定します。<BR>
      <BR>
      マテリアルの変更により<BR>
      表示オブジェクトの対応する部分の表示が面単位で変化します。<BR>
      <BR>
      <BR>
      テクスチャをセットしても、<BR>
      ＵＶ座標は自動的に生成されません。<BR>
動的にテクスチャを設定する場合は、<BR>
      ＵＶ座標もE3DSetUVで設定するか、<BR>
      もしくは、<BR>
      あらかじめ、モデルに仮のテクスチャを貼っておいてＵＶ設定しておく必要があります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [IN] int　：　texid<BR>
      　　テクスチャのIDを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialNo</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">面のマテリアル番号を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　faceno<BR>
      　　面を識別する番号を指定してください。<BR>
      <BR>
      4. [OUT] int*　：　matnoptr<BR>
      　　マテリアルの番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMotionKindML</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンごとに再生するモーションの番号を設定します。<BR>
      <BR>
      list, notlistはボーンの番号をセットした配列<BR>
listに指定した番号とその子供全部に対して再帰的に処理を行う。<BR>
notlistには除外したいボーンの内、一番親の番号を記述する。<BR>
notlistに記述した番号は、listに記述した番号よりも優先される。<BR>
list, notlistには複数の番号を指定できるが、一番最後の要素には０をセットしなければならない。<BR>
listの先頭要素に限り-1を指定できる。<BR>
-1指定はすべてのボーンに対する処理を表す。<BR>
<BR>
左肩のボーン番号を２、左ひじの番号を３、左手の番号を４、<BR>
右肩のボーン番号を１２、右ひじの番号を１３、右手の番号を１４、<BR>
手に持っている武器のボーン番号を２２として<BR>
武器を除く手の部分にモーションを設定したい場合は、<BR>
      <BR>
      int list[3];<BR>
      list[0] = 2<BR>
      list[1] = 12<BR>
      list[2] = 0<BR>
      <BR>
      int notlist[2];<BR>
      notlist[0] = 22<BR>
      notlist[1] = 0<BR>
<BR>
のようにlist, notlistの配列に値をセットして命令を呼び出す。<BR>
２を指定すれば２の子供全部に処理が行われるので３，４を指定する必要はない。<BR>
同様に１２を指定すれば１２の子供全部に処理が行われるので１３，１４を指定する必要はない。<BR>
リストの最後には必ず0を指定する。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別するid<BR>
      <BR>
      3. [IN] int*　：　list<BR>
      4. [IN] int*　：　notlist<BR>
      　　設定したいボーン番号と<BR>
      　　設定したくないボーン番号をセットした配列のポインタ。<BR>
      　　詳しくは前記をご覧ください。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMotionFrameNoML</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンごとに再生するモーションの番号とフレーム番号を設定します。<BR>
      <BR>
      <BR>
      list, notlistはボーンの番号をセットした配列<BR>
listに指定した番号とその子供全部に対して再帰的に処理を行う。<BR>
notlistには除外したいボーンの内、一番親の番号を記述する。<BR>
notlistに記述した番号は、listに記述した番号よりも優先される。<BR>
list, notlistには複数の番号を指定できるが、一番最後の要素には０をセットしなければならない。<BR>
listの先頭要素に限り-1を指定できる。<BR>
-1指定はすべてのボーンに対する処理を表す。<BR>
<BR>
左肩のボーン番号を２、左ひじの番号を３、左手の番号を４、<BR>
右肩のボーン番号を１２、右ひじの番号を１３、右手の番号を１４、<BR>
手に持っている武器のボーン番号を２２として<BR>
武器を除く手の部分にモーションを設定したい場合は、<BR>
<BR>
      int list[3];<BR>
      list[0] = 2<BR>
      list[1] = 12<BR>
      list[2] = 0<BR>
      <BR>
      int notlist[2];<BR>
      notlist[0] = 22<BR>
      notlist[1] = 0<BR>
<BR>
のようにlist, notlistの配列に値をセットして命令を呼び出す。<BR>
２を指定すれば２の子供全部に処理が行われるので３，４を指定する必要はない。<BR>
同様に１２を指定すれば１２の子供全部に処理が行われるので１３，１４を指定する必要はない。<BR>
リストの最後には必ず0を指定する。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別するid<BR>
      <BR>
      3. [IN] int　：　frameno<BR>
      　　フレーム番号。<BR>
      <BR>
      <BR>
      4. [IN] int*　：　list<BR>
      5. [IN] int*　：　notlist<BR>
      　　設定したいボーン番号と<BR>
      　　設定したくないボーン番号をセットした配列へのポインタ。<BR>
      　　詳しくは前記をご覧ください。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetNextMotionFrameNoML</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">現在再生しているモーションの後につづけて再生するモーションをボーンごとに設定します。<BR>
      <BR>
      <BR>
      list, notlistはボーンの番号をセットした配列<BR>
listに指定した番号とその子供全部に対して再帰的に処理を行う。<BR>
notlistには除外したいボーンの内、一番親の番号を記述する。<BR>
notlistに記述した番号は、listに記述した番号よりも優先される。<BR>
list, notlistには複数の番号を指定できるが、一番最後の要素には０をセットしなければならない。<BR>
listの先頭要素に限り-1を指定できる。<BR>
-1指定はすべてのボーンに対する処理を表す。<BR>
<BR>
左肩のボーン番号を２、左ひじの番号を３、左手の番号を４、<BR>
右肩のボーン番号を１２、右ひじの番号を１３、右手の番号を１４、<BR>
手に持っている武器のボーン番号を２２として<BR>
武器を除く手の部分にモーションを設定したい場合は、<BR>
<BR>
      int list[3];<BR>
      list[0] = 2<BR>
      list[1] = 12<BR>
      list[2] = 0<BR>
      <BR>
      int notlist[2];<BR>
      notlist[0] = 22<BR>
      notlist[1] = 0<BR>
<BR>
のようにlist, notlistの配列に値をセットして命令を呼び出す。<BR>
２を指定すれば２の子供全部に処理が行われるので３，４を指定する必要はない。<BR>
同様に１２を指定すれば１２の子供全部に処理が行われるので１３，１４を指定する必要はない。<BR>
リストの最後には必ず0を指定する。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　srcmotid<BR>
      3. [IN] int　：　nextmotid<BR>
      4. [IN] int　：　nextframeno<BR>
      5. [IN] int　：　befframeno<BR>
      　　srcmotidのモーションがbefframeフレーム番号に達した後、nextmotidのモーションのnextframenoのフレーム番号にジャンプするように設定されます。<BR>
      befframeに-1をセットした場合は、srcmotidが最終フレームに達した後にジャンプします。<BR>
      <BR>
      <BR>
      6. [IN] int*　：　list<BR>
      7. [IN] int*　：　notlist<BR>
      　　設定したいボーン番号と<BR>
      　　設定したくないボーン番号をセットした配列へのポインタ。<BR>
      　　詳しくは前記をご覧ください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMOAEventNoML</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">モーションアクセラレータのイベント番号をボーンごとに設定します。<BR>
      <BR>
      この命令を必要な分だけ呼んだ後に１回E3DSetNewPoseMLを呼ぶ必要があります。<BR>
      <BR>list, notlistはボーンの番号をセットした配列<BR>
listに指定した番号とその子供全部に対して再帰的に処理を行う。<BR>
notlistには除外したいボーンの内、一番親の番号を記述する。<BR>
notlistに記述した番号は、listに記述した番号よりも優先される。<BR>
list, notlistには複数の番号を指定できるが、一番最後の要素には０をセットしなければならない。<BR>
listの先頭要素に限り-1を指定できる。<BR>
-1指定はすべてのボーンに対する処理を表す。<BR>
<BR>
左肩のボーン番号を２、左ひじの番号を３、左手の番号を４、<BR>
右肩のボーン番号を１２、右ひじの番号を１３、右手の番号を１４、<BR>
手に持っている武器のボーン番号を２２として<BR>
武器を除く手の部分にモーションを設定したい場合は、<BR>
<BR>
      int list[3];<BR>
      list[0] = 2<BR>
      list[1] = 12<BR>
      list[2] = 0<BR>
      <BR>
      int notlist[2];<BR>
      notlist[0] = 22<BR>
      notlist[1] = 0<BR>
<BR>
のようにlist, notlistの配列に値をセットして命令を呼び出す。<BR>
２を指定すれば２の子供全部に処理が行われるので３，４を指定する必要はない。<BR>
同様に１２を指定すれば１２の子供全部に処理が行われるので１３，１４を指定する必要はない。<BR>
リストの最後には必ず0を指定する。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　eventno<BR>
      　　モーションの変化のトリガーとなるイベント番号。<BR>
      <BR>
      3. [IN] int*　：　list<BR>
      4. [IN] int*　：　notlist<BR>
      　　設定したいボーン番号と<BR>
      　　設定したくないボーン番号をセットした配列へのポインタ。<BR>
      　　詳しくは前記をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMotionFrameNoML</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">指定したボーンのモーション番号とフレーム番号を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別するＩＤ<BR>
      <BR>
      3. [OUT] int*　：　motidptr<BR>
      　　モーション番号が代入されます。<BR>
      <BR>
      4. [OUT] int*　：　framenoptr<BR>
      　　フレーム番号が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetNextMotionFrameNoML</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">E3DSetNextMotionFrameNoMLで設定した情報をボーンごとに取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別するＩＤ<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別するＩＤ<BR>
      <BR>
      4. [OUT] int*　：　nextmotidptr<BR>
      　　ジャンプ先のモーション番号が代入されます。<BR>
      <BR>
      5. [OUT] int*　：　nextframenoptr<BR>
      　　ジャンプ先のフレーム番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetNewPoseML</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">マルチレイヤーモーションの仕様に従って、新しい姿勢情報をそれぞれのボーンにセットします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCurrentBonePos</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">現在のボーンの位置を取得します。<BR>
      E3DSetNewPose, E3DSetNewPoseMLの結果を使用します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別するＩＤ<BR>
      <BR>
      3. [IN] int　：　poskind<BR>
      　　poskind = 0 ---&gt; ローカル座標（ボーン変形なし）<BR>
      　　poskind = 1 ---&gt; グローバル座標（ボーン変形あり）<BR>
      　　poskind = 2 ---&gt; ローカル座標（ボーン変形あり）<BR>
<BR>
      4. [OUT] D3DXVECTOR3*　：　posptr<BR>
      　　ボーンの位置が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCurrentBoneQ</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">現在のボーンの姿勢情報を取得します。<BR>
      E3DSetNewPose, E3DSetNewPoseMLの結果を使用します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      　　E3DGetBoneNoByNameまたは、<BR>
      　　E3DGetPartNoByNameで取得した番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　kind<BR>
      　　親の影響を受けたクォータニオンを<BR>
      　　取得する場合は１を指定してください。<BR>
      <BR>
      　　親の影響を受けていないクォータニオンを<BR>
      　　取得する場合は０を指定してください。<BR>
      <BR>
      　　親の影響を受け、<BR>
      　　更に、モデル全体の向きの影響を受けたクォータニオンを取得<BR>
      　　するには２を指定してください。<BR>
      <BR>
      <BR>
      4. [IN, OUT] int　：　qid<BR>
      　　クォータニオンを識別する番号。<BR>
      　　E3DCreateQで取得した番号を指定してください。<BR>
      <BR>
      　　qidで識別されるクォータニオンの内容に、<BR>
      　　指定したボーンのクォータニオンの内容を代入します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkBumpMapEnable</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">ハードウェアがバンプマップを表示可能かどうかを調べます。<BR>
      <BR>
      E3DInitよりも後で呼び出してください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　flagptr<BR>
      　　バンプマップ表示可能の場合は０以外が、<BR>
      　　表示不可能のときは０が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DEnableBumpMap</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">バンプマップ表示を使用するかどうかを設定します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　flag<BR>
      　　０を指定するとバンプマップを表示しません。<BR>
      　　１を指定するとハードウェアに能力がある場合に限り、バンプマップを表示可能にします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DConvHeight2NormalMap</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">白黒の高さマップの画像データを、E3Dで使用可能な法線マップに変換します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　hmapname<BR>
      　　白黒画像のファイルのパス。<BR>
      <BR>
      2. [IN] char*　：　nmapname<BR>
      　　法線マップのファイルのパス。<BR>
      　　出力ファイル名。BMPのみ有効。<BR>
      <BR>
      3. [IN] float　：　hparam<BR>
      　　バンプマップの高さのパラメータ。<BR>
      　　値が大きいほど段差がきつくなります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBumpMapToMaterial</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateTextureで作成したテクスチャをバンプマップに設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [IN] int　：　texid<BR>
      　　テクスチャのIDを指定してください。<BR>
      <BR>
      　　-1を指定するとバンプマップが無効になります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOATrunkInfo</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">MOAの分岐元モーションの情報を取得します。<BR>
      <BR>
      trunkinfoptr引数にはusercoef.hで定義されている<BR>
      MOATRUNKINFO構造体へのポインタを渡してください。<BR>
      <BR>
      trunkinfo.idlingはアイドリングモーションかどうかを０と１で表します。<BR>
      trunkinfo.ev0idleはイベント番号０でアイドリングに戻すかどうかを表します。<BR>
      trunkinfo.comidは共通分岐イベント番号です。<BR>
      trunkinfo.notcomnumは共通分岐禁止イベント番号の個数を表します。<BR>
      trunkinfo.notcomidは共通分岐禁止イベント番号です。notcomnum個だけのintがセットされている配列のポインタです。<BR>
      trunkinfo.branchnumは分岐先モーションがいくつあるかを表します。<BR>
      <BR>
      この命令に渡すmotidはE3DGetMOAInfoで取得したIDを使用してください。<BR>
      <BR>
      motid 0 (補間モーション)を指定すると<BR>
      trunkinfoにはすべて０が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別するＩＤ<BR>
      <BR>
      3. [OUT] MOATRUNKINFO*　：　trunkinfoptr<BR>
      　　分岐元モーションの情報が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOABranchInfo</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">MOAの分岐先モーションの情報を取得します。<BR>
      <BR>
      branchnumにはE3DGetMOATrunkInfoで取得した<BR>
      trunkinfo.branchnum を指定してください。<BR>
      <BR>
      branchinfoptr引数にはusercoef.hで定義されているMOABRANCHINFO構造体の配列へのポインタを渡してください。<BR>
      branchinfoptr = (MOABRANCHINFO*)malloc( sizeof( MOABRANCHINFO ) * branchnum
      );<BR>
      で作成したポインタを渡してください。<BR>
      <BR>
      branchinfo.motidは分岐先モーションのモーションID。<BR>
      branchinfo.eventnoはイベント番号。<BR>
      branchinfo.frameno1は分岐元フレーム番号。<BR>
      branchinfo.frameno2は分岐先フレーム番号。<BR>
      branchinfo.notfuは補間なしで変化させるかどうか。<BR>
      <BR>
      この命令に渡すmotidはE3DGetMOAInfoで取得したIDを使用してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別するＩＤ<BR>
      <BR>
      3. [OUT] MOABRANCHINFO*　：　branchinfoptr<BR>
      　　分岐先モーションの情報が代入されます。<BR>
      　　前述の方法でmallocした配列を指定してください。<BR>
      <BR>
      4. [IN] int　：　branchnum<BR>
      　　branchinfoptrをmallocしたときのbranchnumを指定してください。<BR>
      <BR>
      5. [OUT] int*　：　getnum<BR>
      　　分岐先モーション情報をいくつ取得したかが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMOABranchFrame1</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">MOAの分岐の分岐元フレーム番号情報を設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　tmotid<BR>
      　　分岐元モーションを識別するＩＤ<BR>
      <BR>
      3. [IN] int　：　bmotid<BR>
      　　分岐先モーションを識別するＩＤ<BR>
      <BR>
      4. [IN] int　：　frame1<BR>
      　　分岐の分岐元フレーム番号<BR>
      　　-1指定は、いつでも分岐することを表します。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2"></TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMOABranchFrame2</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">MOAの分岐の分岐先フレーム番号情報を設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　tmotid<BR>
      　　分岐元モーションを識別するＩＤ<BR>
      <BR>
      3. [IN] int　：　bmotid<BR>
      　　分岐先モーションを識別するＩＤ<BR>
      <BR>
      4. [IN] int　：　frame2<BR>
      　　分岐の分岐先フレーム番号<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2"></TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetDispSwitch</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">ディスプレイスイッチのアニメーションの設定をします。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別するパーツの番号<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別するＩＤ<BR>
      <BR>
      4. [IN] int　：　switchid<BR>
      　　スイッチの番号。０から９９<BR>
      <BR>
      5. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号<BR>
      <BR>
      6. [IN] int　：　switchflag<BR>
      　　スイッチの状態。<BR>
      　　０がオフ。１がオン。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DQtoEuler</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンの姿勢をオイラー角に変換します。<BR>
      回転の順番はZ軸、X軸、Y軸です。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するＩＤ<BR>
      <BR>
      2. [OUT] D3DXVECTOR3*　：　newdegptr<BR>
      　　オイラー角が代入されます。<BR>
      <BR>
      3. [IN] D3DXVECTOR3　：　olddeg<BR>
      　　前回E3DQtoEulerした結果を指定します。<BR>
      　　計算時にolddegに一番近い角度をnewdegに代入します。<BR>
      　　初回時には０を指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DEnablePhongEdge</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">色P時に輪郭線を表示するかを指定します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　flag<BR>
      　　輪郭線を表示するとき１、しないとき０<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetPhongEdge0Params</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">色P時の輪郭線の色と幅と半透明モードを設定します。<BR>
      <BR>
      半透明の輪郭線はE3DRenderのwithalpha引数に１を指定したときに表示されます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] E3DCOLOR4UC　：　col<BR>
      　　輪郭線の色をRGBで指定します。<BR>
      　　col.aは無視されます。<BR>
      <BR>
      5. [IN] float　：　width<BR>
      　　輪郭線の幅をfloatで指定します。<BR>
      <BR>
      6. [IN] int　：　blendmode<BR>
      　　輪郭線の半透明モードを指定します。<BR>
      　　０を指定すると頂点アルファによる半透明<BR>
      　　１を指定するとアッドモード<BR>
      　　２を指定すると頂点アルファを考慮したアッドモード<BR>
      　　３を指定すると不透明<BR>
      　　になります。<BR>
      <BR>
      7. [IN] float　：　alpha<BR>
      　　輪郭線の頂点アルファを指定します。<BR>
      　　blendmodeで０または２を指定したときに<BR>
      　　意味を持ちます。<BR>
      　　0.0から1.0の間のfloatを指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetDispSwitch</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">ディスプレイスイッチを取得します。<BR>
      E3DSetNewPose, E3DSetNewPoseMLの結果を利用します。<BR>
      <BR>
      dispswitch変数は<BR>
      int dispswitch[DISPSWITCHNUM];<BR>
      で確保してからこの命令に渡してください。<BR>
      <BR>
      DISPSWITCHNUMはusercoef.hで定義されています。<BR>
      （スイッチの総数です）<BR>
      <BR>
      スイッチがオフのとき０がオンのときは０以外が代入されます。<BR>
      <BR>
      例えばスイッチ３がオンのときは<BR>
      dispswitch[ 3 ] に０以外が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [OUT] int*　：　dispswitch<BR>
      　　スイッチの状態が代入されます。<BR>
      　　詳しくは前記をご覧ください。<BR>
      <BR>
      3. [IN] int　：　leng<BR>
      　　dispswitch配列を作成したときの<BR>
      　　要素数を指定します。<BR>
      　　通常DISPSWITCHNUMを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DFreeThread</TD>
      <TD class="hpb-cnt-tb-cell2">スレッド管理</TD>
      <TD class="hpb-cnt-tb-cell2">スレッドのリソースを解放します。<BR>
      この命令を実行が終わったスレッドに対して呼ぶことで<BR>
      4098回の呼び出し回数制限を緩和することが出来ます。<BR>
      ただしこの命令を使用しても一度にアクティブにできる<BR>
      スレッド命令は4098個のままです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　threadid<BR>
      　　スレッドを識別するＩＤ<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadSigFileAsGroundThread</TD>
      <TD class="hpb-cnt-tb-cell2">地面</TD>
      <TD class="hpb-cnt-tb-cell2">スレッドを作成してE3DLoadSigFileAsGroundを実行します。<BR>
      <BR>
      作成したスレッドを識別するためのＩＤが<BR>
      threadidに代入されます。<BR>
      <BR>
      スレッドの作成に失敗した場合には、<BR>
      threadidにマイナスの値が代入されます。<BR>
      <BR>
      threadidは<BR>
      E3DChkThreadWorkingに使用することが<BR>
      出来ます。<BR>
      <BR>
      スレッド作成関数は全部で4098回まで<BR>
      呼ぶことが出来ます。<BR>
      （E3DChkThreadWorkingを除く）<BR>
      E3DFreeThreadの説明もご覧ください。<BR>
      <BR>
      <BR>
      スレッドが終了すると、<BR>
      E3DChkThreadWorkingで取得される<BR>
      returnval1に、<BR>
      モデルデータを識別するhsidが代入されます。<BR>
      <BR>
      <BR>
      E3DLoadSigFileAsGroundの説明もお読みください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　fname<BR>
      　　*.sig のパス文字列。<BR>
      <BR>
      2. [IN] int　：　adjustuvflag<BR>
      　　ＵＶ値を正規化するかどうかのフラグ。<BR>
      　　正規化する場合は１を指定。<BR>
      　　しない場合は０を指定。<BR>
      　　２を指定すると0.0から1.0の間にクランプします。<BR>
<BR>
      <BR>
      3. [IN] float　：　mult<BR>
      　　読み込み倍率を指定してください。<BR>
      　　等倍は１．０。<BR>
      <BR>
      4. [OUT] int*　：　threadidptr<BR>
      　　作成したスレッドを識別するIDが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>ver5.0.2.6で拡張<BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadSigFileAsGroundFromBufThread</TD>
      <TD class="hpb-cnt-tb-cell2">地面</TD>
      <TD class="hpb-cnt-tb-cell2">スレッドを作成してE3DLoadSigFileAsGroundFromBufを実行します。<BR>
      <BR>
      作成したスレッドを識別するためのＩＤが<BR>
      threadidに代入されます。<BR>
      <BR>
      スレッドの作成に失敗した場合には、<BR>
      threadidにマイナスの値が代入されます。<BR>
      <BR>
      threadidは<BR>
      E3DChkThreadWorkingに使用することが<BR>
      出来ます。<BR>
      <BR>
      スレッド作成関数は全部で4098回まで<BR>
      呼ぶことが出来ます。<BR>
      （E3DChkThreadWorkingを除く）<BR>
      E3DFreeThreadの説明もご覧ください。<BR>
      <BR>
      <BR>
      スレッドが終了すると、<BR>
      E3DChkThreadWorkingで取得される<BR>
      returnval1に、<BR>
      モデルデータを識別するhsidが代入されます。<BR>
      <BR>
      <BR>
      E3DLoadSigFileAsGroundFromBufの説明もお読みください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　resdir<BR>
      　　テクスチャーのあるフォルダ のパス文字列。<BR>
      　　最後に&quot;\\&quot;が必要。<BR>
      <BR>
      2. [IN] char*　：　buf<BR>
      　　バッファのポインタ<BR>
      <BR>
      3. [IN] int　：　bufleng<BR>
      　　バッファの中のデータの長さ<BR>
      <BR>
      4. [IN] int　：　adjustuvflag<BR>
      　　ＵＶ値を正規化するかどうかのフラグ。<BR>
      　　正規化する場合は１を指定。<BR>
      　　しない場合は０を指定。<BR>
      　　２を指定すると0.0から1.0の間にクランプします。<BR>
      <BR>
      5. [IN] float　：　mult<BR>
      　　読み込み倍率を指定してください。<BR>
      　　等倍は１．０。<BR>
      　　<BR>
      <BR>
      6. [OUT] int*　：　threadidptr<BR>
      　　作成したスレッドを識別するIDが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>ver5.0.2.6で拡張<BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetLightIdOfBumpMap</TD>
      <TD class="hpb-cnt-tb-cell2">ライト</TD>
      <TD class="hpb-cnt-tb-cell2">バンプマップを照らす光源を１つだけ選択します。<BR>
      <BR>
      平行光源でも点光源でもOKです。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lid<BR>
      　　ライトを識別するＩＤ<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetSpriteUV</TD>
      <TD class="hpb-cnt-tb-cell2">スプライト</TD>
      <TD class="hpb-cnt-tb-cell2">スプライトのUVを設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　spid<BR>
      　　スプライトを識別するＩＤ<BR>
      <BR>
      2. [IN] float　：　startu<BR>
      　　U方向の表示開始点を０から１で指定します。<BR>
      <BR>
      3. [IN] float　：　endu<BR>
      　　U方向の表示終了点を０から１で指定します。<BR>
      <BR>
      4. [IN] float　：　startv<BR>
      　　V方向の表示開始点を０から１で指定します。<BR>
      <BR>
      5. [IN] float　：　endv<BR>
      　　V方向の表示終了点を０から１で指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateRenderTargetTexture</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">レンダリング可能なテクスチャを作成します。<BR>
      <BR>
      この命令が成功するとスワップチェインIDとテクスチャIDが取得できます。<BR>
      <BR>
      テクスチャのサイズは２の乗数にしてください。<BR>
      <BR>
      消費するビデオメモリ量は<BR>
      texsize.cx * texsize.cy *  ( 4 + 2 ) バイトです。<BR>
      <BR>
      <BR>
      メモリ不足などでこの命令が失敗した場合には<BR>
      エラーにならずにokflagに０が代入されます。<BR>
      失敗した場合はテクスチャサイズを小さくするなどして<BR>
      再試行してみてください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] SIZE　：　texsize<BR>
      　　texsize.cx, texsize.cyにテクスチャのサイズを指定してください。詳しくは前記をご覧ください。<BR>
      <BR>
      2. [IN] int　：　fmt<BR>
      　　作成したいテクスチャのフォーマットを指定します。<BR>
      D3DFMT_で始まる<BR>
      　　定数を使用してください。<BR>
      <BR>
      3. [OUT] int*　：　scidptr<BR>
      　　スワップチェインIDが代入されます。<BR>
      <BR>
      4. [OUT] int*　：　texidptr<BR>
      　　テクスチャIDが代入されます。<BR>
      <BR>
      5. [OUT] int*　：　okflagptr<BR>
      　　成功した場合は１が<BR>
      　　失敗した場合は０が代入されます。<BR>
      <BR>
      6. [IN] int　：　needz<BR>
      　　needzに０を指定した場合はZバッファを作成しません。<BR>
      　　作成したレンダーターゲットテクスチャをE3DBlendRTTextureでしか使わない場合などはneedzを０に出来ます。<BR>
      　　デフォルト値は１。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.5.0.8で拡張<BR>
      <BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyRenderTargetTexture</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">レンダーターゲットテクスチャを破棄します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　E3DCreateRenderTargetTextureで<BR>
      　　取得したスワップチェインIDを指定します。<BR>
      <BR>
      2. [IN] int　：　texid<BR>
      　　E3DCreateRenderTargetTextureで<BR>
      　　取得したテクスチャIDを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetDSFillUpMode</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">補間時に補間前のモーションのスイッチ状態を表示するか、もしくは補間後のモーションのスイッチ状態を表示するかを選びます。<BR>
      <BR>
      MOA専用です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　mode<BR>
      　　０を指定すると補間前のモーションの<BR>
      　　スイッチ状態を表示します。<BR>
      　　１を指定すると補間後のモーションの<BR>
      　　スイッチ状態を表示します。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetTexFillUpMode</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">補間時に補間前のモーションのテクスチャアニメの状態を表示するか、もしくは補間後のモーションのテクスチャアニメの状態を表示するかを選びます。<BR>
      <BR>
      MOA専用です。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　mode<BR>
      　　０を指定すると補間前のモーションの<BR>
      　　テクスチャを表示します。<BR>
      　　１を指定すると補間後のモーションの<BR>
      　　テクスチャを表示します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetShadowBias</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">影をレンダリングする際のZバッファのバイアスを設定します。<BR>
      一般に大きい値を設定すればマッハバンド（縞模様）が消えます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　bias<BR>
      　　Zバッファの誤差を緩和するためのバイアスを指定します。<BR>
      　　デフォルト値は0.005です。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRenderWithShadow</TD>
      <TD class="hpb-cnt-tb-cell2">描画</TD>
      <TD class="hpb-cnt-tb-cell2">影付きのシーンを一括レンダリングします。<BR>
      内部でE3DChkInView、E3DBeginScene、E3DEndSceneも<BR>
      呼ばれます。<BR>
      <BR>全ての不透明を描画後、半透明が描画されます。<BR>
      <BR>
      hsidarray（配列）にレンダリングしたいhsidを格納してから呼び出します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　影付きのシーンをレンダリングするための<BR>
      　　スワップチェインIDを指定してください。<BR>
      <BR>
      2. [IN] int　：　rtscid<BR>
      3. [IN] int　：　rttexid<BR>
      　　シャドウマップ用のE3DCreateRenderTargetTexture<BR>
      　　で取得したscidとtexidを指定してください。<BR>
      <BR>
      4. [IN] int*　：　hsidarray<BR>
      　　描画したいhsidを配列に格納してください。<BR>
      　　ビルボードを描画したいときはhsidに-1を<BR>
      　　格納してください。<BR>
      <BR>
      <BR>
      5. [IN] int　：　num<BR>
      　　hsidarrayに何個のhsidを格納したかを指定してください。<BR>
      <BR>
      6. [IN] int　：　skipflag<BR>
      　　skipflagに１を指定すると<BR>
      　　画面のバッファのクリアと背景の描画を<BR>
      　　スキップします。<BR>
      <BR>
      　　通常は０．<BR>
      　　BeginSceneとEndSceneはスキップしません。<BR>
      <BR>
      　　E3DBeginScene scid1<BR>
      　　　　前に描画したいものをレンダー<BR>
      　　E3DEndScene<BR>
      　　E3DRenderWithShadow (skipflag = 1)<BR>
      　　E3DBeginScene scid1, 1<BR>
      　　　　後に描画したいものをレンダー<BR>
      　　E3DEndScene<BR>
      　　のように描画してください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkShadowEnable</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">ハードウェアで影の描画が出来るかどうかを調べます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　flagptr<BR>
      　　影の描画が出来る時は０以外が<BR>
      　　出来ないときは０が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DEnableShadow</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">影の描画をオンまたはオフにします。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　flag<BR>
      　　１をセットすると影の描画が可能な時は描画するようにします。<BR>
      　　０をセットすると影の描画は行わないようにします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCheckRTFormat</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateRenderTargetTextureで作成できるフォーマットを調べます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　fmt<BR>
      　　調べたいフォーマットを指定します。<BR>
      D3DFMT_で始まる<BR>
      　　定数を使用してください。<BR>
      <BR>
      2. [OUT] int*　：　okflagptr<BR>
      　　指定したフォーマットが使用可能な時は０以外が<BR>
      　　使用不可な時は０が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetShadowDarkness</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">影の暗さを設定します。<BR>
      <BR>
      darknessに指定した係数にAmbientを掛けたものが<BR>
      影の色となります。<BR>
      <BR>
      デフォルト値は１．０です。<BR>
      ０に近づくほど暗くなります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　darkness<BR>
      　　０以上のfloat。<BR>
      　　アンビエントに掛け算して影の色とする。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRenderBatch</TD>
      <TD class="hpb-cnt-tb-cell2">描画</TD>
      <TD class="hpb-cnt-tb-cell2">E3DRenderのバッチ版。hsidをまとめて描画することにより高速化。<BR>
      <BR>
      内部でE3DChkInView、E3DBeginScene、E3DEndSceneも<BR>
      呼ばれます。<BR>
      <BR>
      全ての不透明を描画後、半透明が描画されます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインIDを指定してください。<BR>
      <BR>
      2. [IN] int*　：　hsidarray<BR>
      　　描画したいhsidを格納した配列。<BR>
      <BR>
      3. [IN] int　：　num<BR>
      　　hsidarrayに何個のhsidをセットしたか。<BR>
      <BR>
      4. [IN] int　：　needchkinview<BR>
      　　内部でChkInViewを呼ぶかどうかのフラグ。<BR>
      <BR>
      5. [IN] int　：　skipflag<BR>
      　　０以外をセットすると<BR>
      　　画面バッファのクリアと背景の描画をスキップします。<BR>
      　　<BR>
      　　BeginSceneとEndSceneはスキップしません。<BR>
      　　デフォルト値は０。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetVertPosBatch</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">E3DSetVertPosのバッチ版。まとめて高速化。<BR>
      <BR>
      あたり判定データの更新はされません。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するID。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するID。<BR>
      <BR>
      3. [IN] int*　：　vertnoarray<BR>
      　　位置を設定したい頂点の番号を配列にセットしてください。<BR>
      <BR>
      4. [IN] int　：　vnum<BR>
      　　何個の頂点の位置を設定するかをセットしてます。<BR>
      　　vertnoarrayとvertarrayの要素数をセットしてください。<BR>
      <BR>
      5. [IN] D3DXVECTOR3*　：　vertarray<BR>
      　　頂点の座標を配列にセットしてください。<BR>
      <BR>
      <BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetShadowMapLightDir</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">影用の平行光源の向きを設定します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　dir<BR>
      　　平行光源の向きをベクトルで指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRenderBatchMode</TD>
      <TD class="hpb-cnt-tb-cell2">描画</TD>
      <TD class="hpb-cnt-tb-cell2">E3DRenderBatchの拡張版。<BR>
      hsidごとに不透明のみを描画するか<BR>
      半透明のみを描画するか<BR>
      不透明と半透明の両方を描画するかを指定できます。<BR>
      <BR>
      適切に設定することで描画速度が速くなります。<BR>
      <BR>
      <BR>
      hsidarrayにはパーティクルのIDを指定することもできます。<BR>
      パーティクルはmode 2のみ有効です。<BR>
      パーティクルをhsidarrayに含める場合はこの命令を呼ぶ前に<BR>
      onlyupdate引数を１にしてE3DRenderParticleを呼んでおく必要があります。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインIDを指定してください。<BR>
      <BR>
      2. [IN] int*　：　hsidarray<BR>
      　　描画したいhsidを格納した配列。<BR>
      <BR>
      3. [IN] int　：　num<BR>
      　　hsidarrayに何個のhsidをセットしたか。<BR>
      <BR>
      4. [IN] int　：　needchkinview<BR>
      　　内部でChkInViewを呼ぶかどうかのフラグ。<BR>
      <BR>
      5. [IN] int　：　skipflag<BR>
      　　０以外をセットすると<BR>
      　　画面バッファのクリアと背景の描画をスキップします。<BR>
      　　<BR>
      　　BeginSceneとEndSceneはスキップしません。<BR>
      　　デフォルト値は０。<BR>
      <BR>
      6. [IN] int*　：　modearray<BR>
      　　描画モードを格納した配列。<BR>
      　　hsidarrayと同じ長さの配列。<BR>
      　　配列の要素に１を指定すると不透明のみ<BR>
      　　２を指定すると半透明のみ<BR>
      　　３を指定すると両方を描画します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGlobalToLocal</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">グローバル座標系からキャラクターのローカル座標系への変換。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　srcpos<BR>
      　　変換前の座標を指定します。<BR>
      <BR>
      3. [OUT] D3DXVECTOR3*　：　dstposptr<BR>
      　　変換後の座標が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLocalToGlobal</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">キャラクターのローカル座標系からグローバル座標系への変換。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　srcpos<BR>
      　　変換前の座標を指定します。<BR>
      <BR>
      3. [OUT] D3DXVECTOR3*　：　dstposptr<BR>
      　　変換後の座標が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetShadowMapMode</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">シャドウマップのモードを設定します。<BR>
      <BR>
      モード０を指定するとLiSPSMの方法で<BR>
      E3DSetShadowMapLightDirを呼び出すだけで自動的に<BR>
      適切なシャドウマップを作成します。<BR>
      <BR>
      モード１を指定するとE3DSetShadowMapCameraと<BR>
      E3DSetShadowMapProjOrthoを使用する<BR>
      マニュアル設定のモードになります。<BR>
      <BR>
      この命令を呼び出さなかった場合は<BR>
      モード０が適用されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　mode<BR>
      　　モード（０または１）を指定します。<BR>
      　　詳しくは前記をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetShadowMapCamera</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">シャドウマップを作成する際のカメラの位置を設定します。<BR>
      影を落とす際のライトの位置と同じ意味です。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　pos<BR>
      　　カメラの位置を指定します。<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　target<BR>
      　　カメラの注視点を指定します。<BR>
      <BR>
      3. [IN] D3DXVECTOR3　：　upvec<BR>
      　　カメラの上方向ベクトルを<BR>
      　　指定します。<BR>
      　　通常は( 0.0, 1.0, 0.0 )を指定します。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetShadowMapProjOrtho</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">シャドウマップを作成する際のプロジェクションを設定します。<BR>
      どのくらいの範囲のシーンをシャドウマップにするかが決定されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　rttexid<BR>
      　　E3DCreateRenderTargetTextureで作成したシャドウマップ用のテクスチャIDを渡します。<BR>
      <BR>
      2. [IN] float　：　near<BR>
      　　視野内のカメラから一番近い距離を指定します。<BR>
      　　あまり小さいとZバッファの精度が悪くなります。<BR>
      <BR>
      3. [IN] float　：　far<BR>
      　　視野内のカメラから一番遠い距離を指定します。<BR>
      　　あまり大きいとZバッファの精度が悪くなります。<BR>
      <BR>
      4. [IN] float　：　viewsize<BR>
      　　正射影のビューのボリュームサイズを指定します。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadTextureFromBuf</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">作成済みのテクスチャにバッファから画像ファイルを読み込みます。<BR>
      <BR>
      テクスチャの内容を頻繁に更新したいときに<BR>
      この命令を使えばテクスチャの作成と破棄を繰り返さなくても<BR>
      すみます。<BR>
      <BR>
      ループの外で１回E3DCreateTextureなどでテクスチャを作っておき<BR>
      ループ中でこのE3DLoadTextureFromBufを呼び出すことを想定しています。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　texid<BR>
      　　作成済みのテクスチャを識別するID<BR>
      <BR>
      2. [IN] char*　：　buf<BR>
      　　バッファのポインタ<BR>
      　　ファイルのイメージがバッファに入っていると<BR>
      　　想定します。<BR>
      <BR>
      3. [IN] int　：　bufleng<BR>
      　　バッファの中のデータの長さ(バイト)<BR>
      <BR>
      4. [IN] int　：　transparent<BR>
      　　透過情報を指定します。<BR>
      <BR>
      　　texidを取得するときのテクスチャ作成命令に<BR>
      　　指定したのと同じtransparentを指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetShadowMapInterFlag</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">シャドウマップにパーツを含めるかどうかのフラグを設定します。<BR>
      <BR>
      シャドウマップモード０用です。<BR>
      <BR>
      フラグには<BR>
      usercoef.hで定義されているSHADOWIN_*を指定します。<BR>
      <BR>
      SHADOWIN_PROJのときは<BR>
      パーツの一部分でも視野内に入っている場合には<BR>
      パーツ全体がシャドウマップに含まれるようにします。<BR>
      キャラクターデータのデフォルト値です。<BR>
      <BR>
      SHADOWIN_ALWAYSのときは<BR>
      視野内に入っているかどうかにかかわらず<BR>
      必ずシャドウマップにパーツ全体が含まれるようにします。<BR>
      シャドウマップに入るパーツが広い範囲に散らばれば散らばるほど<BR>
      影の品質は悪くなります。<BR>
      ですのでシャドウマップに入れるかどうかを動的に判定し、<BR>
      必要がなくなったら<BR>
      SHADOWIN_PROJやSHADOWIN_NOTに戻すことを推奨します。<BR>
      <BR>
      SHADOWIN_NOTのときは<BR>
      シャドウマップに入れるかどうかをE3D側で制御しません。<BR>
      地面などの大きいオブジェクト用のモードです。<BR>
      地面データのデフォルト値です。<BR>
      <BR>
      ver5.2.2.6よりSHADOWIN_EXCLUDEが追加されました。<BR>
      SHADOWIN_EXCLUDEを指定した場合は<BR>
      シャドウマップから指定パーツを除外します。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するID。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するID。<BR>
      　　-1を指定すると全てのパーツに対し処理を行います。<BR>
      <BR>
      3. [IN] int　：　flag<BR>
      　　SHADOWIN_ではじまる定数を指定します。<BR>
      　　詳しくは前記をご覧ください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1<BR>
      ver5.2.2.6で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMaterialAlphaTest</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルごとにアルファテストのオンオフを設定できます。<BR>
      <BR>
      E3DSetMaterialBlendingModeで０、１、２の値をセットしている場合はアルファテストも自動的に設定されるようになっています。<BR>
      自動設定させたくない場合はblendmode １００、１０１、１０２を使用するか、もしくはE3DSetMaterialBlendingModeの後で<BR>
      E3DSetMaterialAlphaTestを呼び出してください。<BR>
      <BR>
      アルファテストをオンにした場合は<BR>
      アルファの値が閾値よりも小さい場合に描画されなくなります。<BR>
      （Zバッファにも描画されなくなります。）<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [IN] int　：　alphatest0<BR>
      　　不透明を描画時にアルファテストする場合は１を<BR>
      　　しない場合は０を指定します。<BR>
      <BR>
      4. [IN] int　：　alphaval0<BR>
      　　不透明時のアルファテストのアルファの閾値。<BR>
      　　（０から２５５）<BR>
      <BR>
      5. [IN] int　：　alphatest1<BR>
      　　半透明を描画時にアルファテストする場合は１を<BR>
      　　しない場合は０を指定します。<BR>
      <BR>
      6. [IN] int　：　alphaval1<BR>
      　　半透明時のアルファテストのアルファの閾値。<BR>
      　　（０から２５５）<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DTransformBillboard</TD>
      <TD class="hpb-cnt-tb-cell2">描画準備</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボードの視野内判定と位置計算とソートを行います。<BR>
      <BR>
      デフォルト状態のE3DRenderBillboardでは<BR>
      これらの描画準備の計算と描画の処理がいっぺんに行われていました。<BR>
      そのためあたり判定は描画の後にしなくてはならず、<BR>
      実際の描画と判定が１フレームずれるという問題がありました。<BR>
      <BR>
      この問題を解決するためにこの命令を追加しました。<BR>
      この命令を呼び出したあとビルボードの位置などに変更がない場合は、E3DRenderBillboardのtransskip引数に１を設定します。<BR>
      そうすることで２度同じ描画準備の計算を行うことを防ぎます。<BR>
      <BR>
      <BR>
      E3DTransformBillboard<BR>
      あたり判定<BR>
      E3DRenderBillboard (transskip = 1)<BR>
      <BR>
      のように使ってください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">引数なし</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetVersion</TD>
      <TD class="hpb-cnt-tb-cell2">バージョン</TD>
      <TD class="hpb-cnt-tb-cell2">easy3d.dllのバージョンを取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　verptr<BR>
      　　バージョンが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkVertexShader</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">実行マシンの頂点シェーダーのバージョンを取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　verptr<BR>
      　　バージョンが代入されます。<BR>
      　　ver1.1のときは１１が代入され<BR>
      　　ver2.0以上の時は２０が代入されます。<BR>
      　　頂点シェーダーがない場合は０が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetToon0Params</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">COL_TOON0を指定したときの<BR>
      トゥーンの影の付き方を指定します。<BR>
      <BR>
      この関数の仕様は将来変更になる可能性が高いです。<BR>
      <BR>darkrate, brightrateは、暗い色、明るい色の色値を制御するパラメータ。<BR>
      diffuseに掛け算されて使用されます。<BR>
      darkdeg, brightdegは、暗い色、明るい色の大きさを制御するパラメータ。<BR>
      これらのパラメータは、角度（度）で、指定します。<BR>
      ライトと面の法線との角度です。<BR>
      ライトと面の法線との角度をdegnlとすると、<BR>
      0 &lt; degnl &lt; brightdeg の部分が明るい色になります。<BR>
      brightdeg &lt; degnl &lt; darkdeg　の部分が通常の色になります。<BR>
      darkdeg &lt; degnl &lt; 90 の部分が暗い色になります。<BR>
      90 &lt; degnl &lt; 180　の部分は、常に、暗い色になります（シェーダーのパラメータが持てる値の範囲に制限があるため）<BR>
      ですので、darkdegには、brightdegより、大きい値を指定してください。<BR>
      darkdeg, brightdegには、0.0から90.0の値を指定してください。<BR>
      darkdeg, brightdegのデフォルト値は、それぞれ、66.4、25.8です。<BR>
<BR>
      （ここで言うライトの向きとは、頂点から、ライトの光源への向きです。）<BR>
<BR>
      partnoで、指定したパーツにだけ、設定することが出来ます。<BR>
      -1を指定すると、すべてのパーツに設定されます。<BR>
      <BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するid<BR>
      <BR>
      3. [IN] TOON0PARAMS　：　toon0<BR>
      　　トゥーンのパラメータ。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialNum</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">モデルデータの色P用のマテリアルの数を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [OUT] int*　：　numptr<BR>
      　　色P用のマテリアルの数が代入されます。<BR>
      <BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.4</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialInfo</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">色P用のマテリアル情報を一括取得します。<BR>
      <BR>
      MATERIALINFO構造体はusercoef.hで定義されています。<BR>
      <BR>
      以下にMATERIALINFOのメンバの説明を書きます。<BR>
      materialnoはマテリアル番号。<BR>
      nameはマテリアル名。<BR>
      alphaは透明度。<BR>
      diffuseは拡散光。<BR>
      specularは反射光。<BR>
      ambientは周囲光。<BR>
      emissiveは自己照明。<BR>
      powerは反射の強さ。<BR>
      <BR>
      arraylengにはE3DGetMaterialNumで取得したマテリアルの数をセットしてください。<BR>
      <BR>
      infoptrは<BR>
      infoptr = (MATERIALINFO*)malloc( sizeof( MATERIALINFO) * arrayleng );<BR>
      で作成したポインタを渡してください。<BR>
      <BR>
      diffuse.a, specular.a, ambient.a, emissive.aには<BR>
      常に２５５が代入されます。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [OUT] MATERIALINFO*　：　infoptr<BR>
      　　情報を格納する構造体へのポインタ。<BR>
      　　作成方法は前記をご覧ください。<BR>
      <BR>
      3. [IN] int　：　arrayleng<BR>
      　　infoptrを作成したときの要素数を指定してください。<BR>
      <BR>
      4. [OUT] int*　：　getnumptr<BR>
      　　infoptrにいくつの要素が代入されたかがセットされます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.4</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetToon1MaterialNum</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">色ト（COL_TOON1）用のマテリアルの数を取得します。<BR>
      <BR>
      トゥーンマテリアルとは通常のマテリアルとは異なります。<BR>
      RokDeBone2の「トゥ」ボタンを押したときに出てくるダイアログに表示されているマテリアルのことです。<BR>
      一回もトゥーン表示したことが無い状態でこの命令を呼ぶと、マテリアル数には０が返ってきます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　表示用パーツを識別するid<BR>
      <BR>
      3. [OUT] int*　：　numptr<BR>
      　　COL_TOON1用のマテリアルの数が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.4</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetToon1MaterialInfo</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">色ト（COL_TOON1）用のマテリアル情報を取得します。<BR>
      <BR>
      TOON1MATERIALINFO構造体はusercoef.hで定義されています。<BR>
      <BR>
      以下にTOON1MATERIALINFOのメンバの説明を書きます。<BR>
      <BR>
      nameはマテリアルの名前。<BR>
      ambientは暗い所の色。<BR>
      specularはハイライト部分の色<BR>
      diffuseはambient,specular以外の部分の色。<BR>
      edgevalidは輪郭線を表示するかどうかの０か１。<BR>
      edgecol0は輪郭線の色。<BR>
      edgewidthは輪郭線の幅。<BR>
      <BR>
      arraylengにはE3DGetToon1MaterialNumで取得したマテリアルの数をセットしてください。<BR>
      <BR>
      infoptrは<BR>
      infoptr = (TOON1MATERIALINFO*)malloc( sizeof( TOON1MATERIALINFO) * arrayleng
      );<BR>
      で作成したポインタを渡してください。<BR>
      <BR>
      diffuse.a, specular.a, ambient.a, edgecol0.aには<BR>
      常に２５５が代入されます。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　表示パーツを識別するid<BR>
      <BR>
      3. [OUT] TOON1MATERIALINFO*　：　infoptr<BR>
      　　情報を格納する構造体へのポインタ。<BR>
      　　作成方法は前記をご覧ください。<BR>
      <BR>
      4. [IN] int　：　arrayleng<BR>
      　　infoptrを作成したときの要素数を指定してください。<BR>
      <BR>
      5. [OUT] int*　：　getnumptr<BR>
      　　infoptrにいくつの要素が代入されたかがセットされます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.4</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetJointInitialPos</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ジョイント（ボーン）の初期位置をローカル座標系で設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　jointno<BR>
      　　ジョイントを識別するパーツのid<BR>
      <BR>
      3. [IN] D3DXVECTOR3　：　pos<BR>
      　　ジョイントの位置をローカル座標系で指定します。<BR>
      <BR>
      4. [IN] int　：　calcflag<BR>
      　　頂点の影響度の再計算をするときは１を、しないときは０を指定します。<BR>
      <BR>
      5. [IN] int　：　excludeflag<BR>
      　　calcflagに１を指定したときのみ意味を持ちます。<BR>
      　　１を指定するとE3DSetValidFlagで無効にしているパーツの影響度は再計算しません。<BR>
      　　０を指定すると無効にしているパーツも全て再計算の対象になります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetVertexDiffuse</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">sigモデルの拡散色を頂点単位でセットする関数です。<BR>
      <BR>
      指定した色を、<BR>
      そのまま設定、乗算して設定、加算して設定、<BR>
      減算して設定の、4種類出来ます。<BR>
      <BR>
      <U>その時点で、表示されている色に対して、<BR>
      乗算、加算、減算します。</U><BR>
      <BR>
      diffuseだけかえても、Specular, Ambientを変えないと意図した色にはならないと思いますので注意してください。<BR>
      （E3DSetVertexSpecular, E3DSetVertexAmbient, E3DSetVertexEmissive, E3DSetVertexSpecularPowerもご覧ください。）<BR>
      <BR>
      メタセコイアの材質単位で色を変えたい場合は<BR>
      「マテリアル」グループの関数をご覧ください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するＩＤ。<BR>
      　　-1を指定すると全てのパーツの色を設定できます。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色をセットします。<BR>
      　　-1をセットした場合には<BR>
      　　partnoで指定したパーツ全体の色の設定をします。<BR>
      <BR>
      <BR>
      4. [IN] E3DCOLOR4UC　：　col<BR>
      　　指定したい色を（col.r, col.g, col.b）で指定します。<BR>
      <BR>
      　　setflagに乗算を指定した場合は、<BR>
      　　各成分に、r/255, g/255, b/255を乗算します。<BR>
      <BR>
      　　col.aは無視されます。<BR>
      <BR>
      5. [IN] int　：　setflag<BR>
      　　setflagが０のときは、<BR>
      　　パーツの色をcolにセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　パーツの色に（col.r/255, col.g/255, col.b/255）を乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　パーツの色にcolを足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　パーツの色からcolを減算します。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetVertexAmbient</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">sigモデルの周囲光を頂点単位でセットする関数です。<BR>
      <BR>
      指定した色を、<BR>
      そのまま設定、乗算して設定、加算して設定、<BR>
      減算して設定の、4種類出来ます。<BR>
      <BR>
      <U>その時点で、表示されている色に対して、<BR>
      乗算、加算、減算します。</U><BR>
      <BR>
      <BR>
      メタセコイアの材質単位で色を変えたい場合は<BR>
      「マテリアル」グループの関数をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するＩＤ。<BR>
      　　-1を指定すると全てのパーツの色を設定できます。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色をセットします。<BR>
      　　-1をセットした場合には<BR>
      　　partnoで指定したパーツ全体の色の設定をします。<BR>
      <BR>
      <BR>
      4. [IN] E3DCOLOR4UC　：　col<BR>
      　　指定したい色を（col.r, col.g, col.b）で指定します。<BR>
      <BR>
      　　setflagに乗算を指定した場合は、<BR>
      　　各成分に、r/255, g/255, b/255を乗算します。<BR>
      <BR>
      　　col.aは無視されます。<BR>
      <BR>
      5. [IN] int　：　setflag<BR>
      　　setflagが０のときは、<BR>
      　　パーツの色をcolにセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　パーツの色に（col.r/255, col.g/255, col.b/255）を乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　パーツの色にcolを足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　パーツの色からcolを減算します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetVertexSpecular</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">sigモデルの反射光を頂点単位でセットする関数です。<BR>
      <BR>
      指定した色を、<BR>
      そのまま設定、乗算して設定、加算して設定、<BR>
      減算して設定の、4種類出来ます。<BR>
      <BR>
      <U>その時点で、表示されている色に対して、<BR>
      乗算、加算、減算します。</U><BR>
      <BR>
      <BR>
      メタセコイアの材質単位で色を変えたい場合は<BR>
      「マテリアル」グループの関数をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するＩＤ。<BR>
      　　-1を指定すると全てのパーツの色を設定できます。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色をセットします。<BR>
      　　-1をセットした場合には<BR>
      　　partnoで指定したパーツ全体の色の設定をします。<BR>
      <BR>
      <BR>
      4. [IN] E3DCOLOR4UC　：　col<BR>
      　　指定したい色を（col.r, col.g, col.b）で指定します。<BR>
      <BR>
      　　setflagに乗算を指定した場合は、<BR>
      　　各成分に、r/255, g/255, b/255を乗算します。<BR>
      <BR>
      　　col.aは無視されます。<BR>
      <BR>
      5. [IN] int　：　setflag<BR>
      　　setflagが０のときは、<BR>
      　　パーツの色をcolにセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　パーツの色に（col.r/255, col.g/255, col.b/255）を乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　パーツの色にcolを足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　パーツの色からcolを減算します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetVertexEmissive</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">sigモデルの自己照明を頂点単位でセットする関数です。<BR>
      <BR>
      指定した色を、<BR>
      そのまま設定、乗算して設定、加算して設定、<BR>
      減算して設定の、4種類出来ます。<BR>
      <BR>
      <U>その時点で、表示されている色に対して、<BR>
      乗算、加算、減算します。</U><BR>
      <BR>
      <BR>
      メタセコイアの材質単位で色を変えたい場合は<BR>
      「マテリアル」グループの関数をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するＩＤ。<BR>
      　　-1を指定すると全てのパーツの色を設定できます。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色をセットします。<BR>
      　　-1をセットした場合には<BR>
      　　partnoで指定したパーツ全体の色の設定をします。<BR>
      <BR>
      <BR>
      4. [IN] E3DCOLOR4UC　：　col<BR>
      　　指定したい色を（col.r, col.g, col.b）で指定します。<BR>
      <BR>
      　　setflagに乗算を指定した場合は、<BR>
      　　各成分に、r/255, g/255, b/255を乗算します。<BR>
      <BR>
      　　col.aは無視されます。<BR>
      <BR>
      5. [IN] int　：　setflag<BR>
      　　setflagが０のときは、<BR>
      　　パーツの色をcolにセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　パーツの色に（col.r/255, col.g/255, col.b/255）を乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　パーツの色にcolを足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　パーツの色からcolを減算します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetVertexSpecularPower</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">sigモデルの反射の強さを頂点単位でセットする関数です。<BR>
      <BR>
      指定した色を、<BR>
      そのまま設定、乗算して設定、加算して設定、<BR>
      減算して設定の、4種類出来ます。<BR>
      <BR>
      <U>その時点で、表示されている色に対して、<BR>
      乗算、加算、減算します。</U><BR>
      <BR>
      <BR>
      メタセコイアの材質単位で色を変えたい場合は<BR>
      「マテリアル」グループの関数をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するＩＤ。<BR>
      　　-1を指定すると全てのパーツの色を設定できます。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色をセットします。<BR>
      　　-1をセットした場合にはパーツ全体の色の設定をします。<BR>
      <BR>
      <BR>
      4. [IN] float　：　power<BR>
      　　power の値をsetflagに基づいて、<BR>
      　　現在の色に対して処理を行います。<BR>
      <BR>
      5. [IN] int　：　setflag<BR>
      　　setflagが０のときは、<BR>
      　　指定した値をセットします。<BR>
      <BR>
      　　setflagが１のときは、<BR>
      　　現在の値に指定した値を乗算します。<BR>
      <BR>
      　　setflagが２のときは、<BR>
      　　現在の値に指定した値を足し算します。<BR>
      <BR>
      　　setflagが３のときは、<BR>
      　　現在の値から指定した値を減算します。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetVertexDiffuse</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">sigモデルの拡散色を頂点単位で取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するＩＤ。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色を取得します。<BR>
      <BR>
      4. [OUT] E3DCOLOR4UC*　：　colptr<BR>
      　　　指定した頂点の色が代入されます。<BR>
      　　　colptr-&gt;aは無視されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetVertexAmbient</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">sigモデルの周囲光を頂点単位で取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するＩＤ。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色を取得します。<BR>
      <BR>
      4. [OUT] E3DCOLOR4UC*　：　colptr<BR>
      　　　指定した頂点の色が代入されます。<BR>
      　　　colptr-&gt;aは無視されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetVertexSpecular</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">sigモデルの反射光を頂点単位で取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するＩＤ。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色を取得します。<BR>
      <BR>
      4. [OUT] E3DCOLOR4UC*　：　colptr<BR>
      　　　指定した頂点の色が代入されます。<BR>
      　　　colptr-&gt;aは無視されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetVertexEmissive</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">sigモデルの自己照明を頂点単位で取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するＩＤ。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色を取得します。<BR>
      <BR>
      4. [OUT] E3DCOLOR4UC*　：　colptr<BR>
      　　　指定した頂点の色が代入されます。<BR>
      　　　colptr-&gt;aは無視されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetVertexSpecularPower</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">sigモデルの反射の強さを頂点単位で取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するＩＤ。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　指定した頂点番号の色を取得します。<BR>
      <BR>
      4. [OUT] float*　：　powerptr<BR>
      　　　指定した頂点の反射の強さが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateSkinMat</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響</TD>
      <TD class="hpb-cnt-tb-cell2">影響度の編集結果を表示用データに反映させます。<BR>
      <BR>
      E3DSetInfElem, E3DDeleteInfElem, E3DNormalizeInfElem, E3DSetSymInfElemなどで影響度を全て編集し終わったら<BR>
      この命令を呼んでください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するID。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するID。<BR>
      　　-1を指定すると全てのパーツに対して処理を行います。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetSymInfElem</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響</TD>
      <TD class="hpb-cnt-tb-cell2">CALCMODE_SYM（対称セット）で頂点のボーン影響度を設定します。<BR>
      <BR>
      対称軸symaxis引数にはusercoef.hで定義されているSYMAXIS_で始まる定数を使用してください。<BR>
      SYMAXIS_XはX軸対称<BR>
      SYMAXIS_YはY軸対称<BR>
      SYMAXIS_ZはZ軸対称<BR>
      <BR>
      この命令を呼んだだけでは表示には反映されません。<BR>
      <B>影響度の編集がすべて終わったら、E3DCreateSkinMatを呼んで</B>表示に反映させてください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するID。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別するID。<BR>
      　　-1を指定すると全てのパーツに対して処理を行います。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　頂点の番号。<BR>
      　　-1を指定するとパーツ中のすべての頂点に対して処理を行います。<BR>
      <BR>
      4. [IN] int　：　symaxis<BR>
      　　対称軸をSYMAXIS_で始まる定数で指定します。<BR>
      <BR>
      5. [IN] float　：　symdist<BR>
      　　対称距離。<BR>
      　　ぴったり対称な位置からどれくらい離れていても対称とみなすかを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DUpdateSymInfElem</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響</TD>
      <TD class="hpb-cnt-tb-cell2">CALCMODE_SYM（対称設定）の設定してある頂点の影響度を最新の状態に更新します。<BR>
      <BR>
      内部でCreateSkinMatも呼ばれます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するID。<BR>
      <BR>
      2. [IN] int　：　excludeflag<BR>
      　　0を指定すると全てのパーツに対して処理を行います。１を指定するとE3DSetValidFlagで無効にしているパーツは除外して処理を行います。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.0.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCalcMLMotion</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">マルチレイヤーモーションの姿勢情報を計算します。ローカルの姿勢から親子関係を反映した姿勢を計算します。<BR>
      <BR>
      E3DSetNewPoseMLより後でE3DSetBoneQした場合などに<BR>
      呼んでください。<BR>
      <BR>
      （E3DSetNewPoseML内部からも呼ばれています）<BR>
      <BR>
      使用例としては<BR>E3DSetMotionKindML<BR>
E3DSetNewPoseML<BR>
      E3DGetMotionFrameNo<BR>
E3DSetBoneQ<BR>
E3DCalcMLMotion<BR>
      のような順序で呼び出します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.1.2</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetLightId2OfBumpMap</TD>
      <TD class="hpb-cnt-tb-cell2">ライト</TD>
      <TD class="hpb-cnt-tb-cell2">バンプマップを設定したモデルデータを照らす２個目のライトを指定します。<BR>
      影を表示している場合は有効になりません。<BR>
      （影表示時はライト１個だけ有効）</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lid<BR>
      　　ライトを識別するid<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetLightId3OfBumpMap</TD>
      <TD class="hpb-cnt-tb-cell2">ライト</TD>
      <TD class="hpb-cnt-tb-cell2">バンプマップを設定したモデルデータを照らす３個目のライトを指定します。<BR>
      影を表示している場合は有効になりません。<BR>（影表示時はライト１個だけ有効）</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lid<BR>
      　　ライトを識別するid<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCharaDir</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">キャラクターから見て任意の方向のベクトルを取得します。<BR>
      degxzにはXZ平面上の角度をdegyには仰ぎ角度を指定します。<BR>
      <BR>
      例えばキャラクターの向いている向きを取得したい場合は<BR>
      ( degxz, degy ) = ( 0.0, 0.0 )を指定します。<BR>
      キャラクター後ろは(180.0, 0.0), 右は(-90.0, 0.0)<BR>
      左は(90.0, 0.0)上は（0.0, 90）下は(0.0, -90)<BR>
      というように指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      2. [IN] float　：　degxz<BR>
      　　xz平面上での角度。<BR>
      3. [IN] float　：　degy<BR>
      　　仰ぎ角度。<BR>
      4. [OUT] D3DXVECTOR3*　：　dstdir<BR>
      　　向きのベクトルが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.1.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetStrSizeByFontID</TD>
      <TD class="hpb-cnt-tb-cell2">テキスト</TD>
      <TD class="hpb-cnt-tb-cell2">文字列の描画に必要な幅と高さを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　fontid<BR>
      　　E3DCreateFontで作成した、フォントの番号を指定します。<BR>
      <BR>
      2. [IN] const char*　：　textstr<BR>
      　　大きさを調べたい文字列を指定します。<BR>
      <BR>
      3. [OUT] SIZE*　：　sizeptr<BR>
      　　描画に必要な幅と高さが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetUVBatch</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">複数の頂点のUV設定を一括で行います。<BR>
      ビデオバッファのロックとアンロックの回数が最小限なので<BR>
      複数回E3DSetUVをよびだすよりも高速です。<BR>
      <BR>
      <BR>
      処理したい頂点の総数をsetnum個とするとき<BR>
      *vertnoptrから*(vertnoptr + setnum - 1) までの整数配列に<BR>
      頂点の番号を格納してください。<BR>
      <BR>
      UVも同様に<BR>
      uvptr = (UV*)malloc( sizeof( UV ) * setnum );<BR>
      などで作成し<BR>
      (uvptr + 頂点のインデックス)-&gt;u にU座標を<BR>
      (uvptr + 頂点のインデックス)-&gt;v にV座標を<BR>
      格納してください。<BR>
      <BR>
      頂点のインデックスとは頂点番号ではありません。<BR>
      ０からsetnumまでの値です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid。<BR>
      　　-1を渡すとビルボードの処理をします。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号。<BR>
      　　hsidに-1を渡した場合はビルボードIDを指定します。<BR>
      <BR>
      3. [IN] int*　：　vertnoptr<BR>
      　　頂点の番号を格納した配列。<BR>
      <BR>
      4. [IN] int　：　setnum<BR>
      　　vertnoptrの要素数。<BR>
      　　uvptrの要素数と同じです。<BR>
      <BR>
      5. [IN] UV*　：　uvptr<BR>
      　　設定したいＵＶ値の値を指定してください。<BR>
      　　UVの配列。<BR>
      <BR>
      6. [IN] int　：　setflag<BR>
      　　setflag に０を指定すると、<BR>
      　　指定ＵＶ値を、そのままセットします。<BR>
      <BR>
      　　setflagに１を指定すると、<BR>
      　　指定ＵＶ値を、既存のＵＶ値に、足し算します。<BR>
      <BR>
      7. [IN] int　：　clampflag<BR>
      　　１をセットするとUVの値を０．０から１．０の間にクランプします。<BR>
      　　０を指定するとクランプは行いません。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetPresentInterval</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">E3DPresentがモニタの垂直同期に合わせて動作するかどうかを設定します。<BR>
      E3DInitよりも前に呼び出すことを想定しています。<BR>
      E3DInitを呼び出したら途中で変更することは出来ません。<BR>
      この命令を呼び出さなかった場合は垂直同期しません。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　flag<BR>
      　　０を指定すると垂直同期しません。<BR>
      　　１を指定すると垂直同期します。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.0.2.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBillboardSize</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボード</TD>
      <TD class="hpb-cnt-tb-cell2">ビルボードの大きさを設定します。<BR>
      大きさはE3DCreateBillboardでも設定されるので<BR>
      この命令は大きさを変更したいときのみに使用します。<BR>
      <BR>
      この命令はビデオメモリにアクセスするので多用すると重くなる可能性があります。<BR>
      拡大縮小はE3DSetScaleをご使用ください。E3DSetScaleは高速です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　bbid<BR>
      　　ビルボードを識別するID。<BR>
      <BR>
      2. [IN] float　：　width<BR>
      　　ビルボードの幅。<BR>
      <BR>
      3. [IN] float　：　height<BR>
      　　ビルボードの高さ。<BR>
      <BR>
      4. [IN] int　：　<FONT color="#800080">dirmode</FONT><BR>
      　　dirmodeに０を指定すると、<BR>
      　　ビルボードは、Ｙ軸に関してのみ、回転します。<BR>
      　　地面に立っている木などに使用してください。<BR>
      <BR>
      　　dirmodeの１を指定すると、<BR>
      　　ビルボードは、全方向に回転します。<BR>
      　　カメラの高さにかかわらず、カメラの方向を向かせたいもの<BR>
      　　例えば、火や煙などに、使用してください。<BR>
      <BR>
      5. [IN] int　：　<FONT color="#800080">orgflag</FONT><BR>
      　　ビルボードの原点の位置を指定します。<BR>
      <BR>
      　　orgflagに０を指定すると、<BR>
      　　原点は、ビルボードの四角形の下の辺の中心になります。<BR>
      　　地面に生やす木などの場合に、便利です。<BR>
      <BR>
      　　orgflagに１を指定すると、<BR>
      　　原点は、ビルボードの中心になります。<BR>
      　　爆発などの、特殊効果に使う場合に、便利です。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.1.0.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetHeightFogParams</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">高さフォグ（線形）を設定します。<BR>
      <BR>頂点フォグなので、ポリゴンのない部分には、フォグはかかりません。<BR>
      画面全体にフォグをかけたい場合は、<BR>
      E3DCreateBGで、背景を作成してください。（背景はポリゴンです。）<BR>
      <BR>
      hsid, ビルボードを作成してから呼び出してください。<BR>
      E3DCreateBGよりも前で呼び出してください。<BR>
      <BR>
      E3DSetLinearFogParamsとの混在は出来ません。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　enable<BR>
      　　１を指定すると、フォグが有効に、<BR>
      　　０を指定すると、フォグが無効になります。<BR>
      <BR>
      2. [IN] E3DCOLOR4UC　：　col<BR>
      <BR>
      　　フォグの色を指定します。<BR>
      　　col.aは無視されます。<BR>
      <BR>
      3. [IN] int　：　start<BR>
      4. [IN] int　：　end<BR>
      　　フォグが一番濃くなる一番低い高さをstartに指定してください。<BR>
      　　フォグが無くなる一番高い高さをendに指定してください。<BR>
      <BR>
      5. [IN] int　：　hsid<BR>
      　　この引数に、モデルデータのhsidを<BR>
      　　指定することにより、<BR>
      　　モデル単位でのフォグの指定が可能になります。<BR>
      　　特殊効果などで、フォグをかけたくない場合などの<BR>
      　　表示にお使いください。<BR>
      　　この引数に-1を指定した場合は、<BR>
      　　すべてのモデルデータに対して設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.1.0.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetTextureToBG</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateBGで作成した背景のテクスチャを変更します。<BR>
      E3DCreateBGが呼び出されている状態で使用してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインIDを指定します。<BR>
      <BR>
      2. [IN] int　：　stageno<BR>
      　　背景の１枚目のテクスチャにセットしたい場合は０を、２枚目のテクスチャにセットしたい場合は１を指定します。<BR>
      <BR>
      3. [IN] int　：　texid<BR>
      　　貼り付けたいテクスチャのＩＤを指定します。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.1.0.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetTextureFromBG</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateBGで作成した背景のテクスチャIDを取得します。<BR>
      E3DCreateBGが呼び出されている状態で使用してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインIDを指定します。<BR>
      <BR>
      2. [IN] int　：　stageno<BR>
      　　背景の１枚目のテクスチャを取得したい場合は０を、２枚目のテクスチャを取得したい場合は１を指定します。<BR>
      <BR>
      3. [OUT] int*　：　texidptr<BR>
      　　テクスチャのＩＤが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.1.0.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChangeMoaIdling</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">MOA（モーションアクセラレータ）のアイドリングモーションを変更します。<BR>
      <BR>
      副作用として現在再生中のモーションが新しい（指定した）アイドリングモーションになります。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するID。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　新しいアイドリングモーションのID。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMotionBlur</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">モーションブラーのオンオフと種類を設定します。<BR>
      種類にはワールドブラーとカメラブラーがあります。<BR>
      <BR>
      ワールドブラーはキャラクターのワールド座標（位置）が変化したときにブラーが生じます。<BR>
      <BR>
      カメラブラーはキャラクターのカメラ座標（キャラ位置含む）が変化したときにブラーが生じます。このモードでは位置が同じでもカメラが動いた時にはブラーが生じます。<BR>
      <BR>
      この命令はオフにするとき以外重い処理です。<BR>
      毎回呼ぶ必要はありません。<BR>
      状態を変化させるときのみ呼んでください。<BR>
      <BR>
      <BR>
      ver5.2.0.4でblurtime引数が追加されました。<BR>
      これは何フレーム前のデータをブラー作成に使用するかを指定するものです。<BR>
      blurtimeには１から２０までの数字を指定してください。<BR>
      <BR>
      具体的な使用例は<BR>
      MotionBlurソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するID。<BR>
      <BR>
      2. [IN] int　：　mode<BR>
      　　BLUR_NONEを指定するとブラーが無効になります。<BR>
      　　BLUR_WORLDを指定するとワールドブラーがオンになります。<BR>
      　　BLUR_CAMERAを指定するとカメラブラーがオンになります。<BR>
      　　BLUR_で始まる定数はusercoef.hで定義されています。<BR>
      <BR>
      3. [IN] int　：　blurtime<BR>
      　　何フレーム前のデータをブラー作成に使用するかを指定します。<BR>
      　　１から２０までの整数。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.0.3<BR>
      ver5.2.0.4で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBeforeBlur</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">ブラー作成用のデータを準備します。<BR>
      現在の姿勢などを保存しE3DSetMotionBlurで指定したblurtime回分蓄積します。<BR>
      <BR>
      この命令はE3DSetMotionBlurを少なくとも１回は呼び出した後でないと意味を持ちません。<BR>
      <BR>
      毎フレーム呼び出してください。<BR>
      <BR>
      具体的な使用例は<BR>
      MotionBlurソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するID。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.0.3<BR>
      ver5.2.0.4で修正<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRenderMotionBlur</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">モーションブラーを表示します。<BR>
      <BR>
      不透明の描画、半透明の描画の後に呼び出してください。<BR>
      現在のキャラクターの状態とE3DSetBeforeBlurを呼び出したときのキャラクターの状態から移動軌跡ボリュームを作成し半透明で表示します。<BR>
      <BR>
      具体的な使用例は<BR>
      MotionBlurソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインIDを指定してください。<BR>
      <BR>
      2. [IN] int*　：　hsidarray<BR>
      　　描画したいhsidを配列に格納してください。<BR>
      　　ビルボードを描画したいときはhsidに-1を<BR>
      　　格納してください。<BR>
      <BR>
      <BR>
      3. [IN] int　：　num<BR>
      　　hsidarrayに何個のhsidを格納したかを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.0.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DInitBeforeBlur</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">ブラー作成用データを初期化します。<BR>
      <BR>
      E3DSetMotionBlur呼び出しから数えて１回目の描画の前には<BR>
      必ず呼び出してください。<BR>
      呼ばなかった場合はゴミのようなブラーが表示されます。<BR>
      <BR>
      E3DRenderよりも後で呼び出してください。<BR>
      <BR>
      具体的な使用例は<BR>
      MotionBlurソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するID。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.0.4</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMotionBlurPart</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">モーションブラーのオンオフと種類の変更をパーツ単位で行います。<BR>
      <BR>
      E3DSetMotionBlurの代わりに呼び出します。<BR>
      <BR>
      パーツ単位で設定できること以外はE3DSetMotionBlurと同じです。<BR>
      E3DSetMotionBlurの説明もお読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するID。<BR>
      　　ビルボードにセットしたいときは-1を指定。<BR>
      <BR>
      2. [IN] int　：　mode<BR>
      　　BLUR_NONEを指定するとブラーが無効になります。<BR>
      　　BLUR_WORLDを指定するとワールドブラーがオンになります。<BR>
      　　BLUR_CAMERAを指定するとカメラブラーがオンになります。<BR>
      　　BLUR_で始まる定数はusercoef.hで定義されています。<BR>
      <BR>
      3. [IN] int　：　blurtime<BR>
      　　何フレーム前のデータをブラー作成に使用するかを指定します。<BR>
      　　１から２０までの整数。<BR>
      <BR>
      4. [IN] int*　：　partarray<BR>
      　　設定したいパートの番号を配列に格納してください。<BR>
      　　パートの番号はRokDeBone2の階層構造エディタでパーツ名を右クリックしシリアル番号を調べるか、またはE3DGetPartNoByNameを使用して取得してください。<BR>
      　　hsidに-1を指定した場合はビルボードIDを格納してください。<BR>
      　　<BR>
      <BR>
      5. [IN] int　：　num<BR>
      　　partarrayに何個のパート番号を格納したかを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DBlurTexture16Box</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャに１６ボックスブラーでぼかしをかけます。<BR>
      １パス処理です。<BR>
      <BR>ver5.3.0.5で引数追加。<BR>
</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　resultscid<BR>
      　　結果を描画するレンダーターゲットのスワップチェインID。<BR>
      <BR>
      2. [IN] int　：　srctexid<BR>
      　　ぼかしたいテクスチャのID。<BR>
      <BR>
      3. [IN] int　：　adjustuvflag<BR>
　　UV補正をする場合は１、しない場合は０。<BR>
　　しないとボケが大きいが右下にずれます。<BR>
<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.0.8<BR>
      ver5.3.0.5で拡張<BR>
      <BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DBlurTexture9Corn</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャに９コーンブラーでぼかしをかけます。<BR>
      １パス処理です。<BR>
      <BR>ver5.3.0.5で引数追加。<BR>
<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　resultscid<BR>
      　　結果を描画するレンダーターゲットのスワップチェインID。<BR>
      <BR>
      2. [IN] int　：　srctexid<BR>
      　　ぼかしたいテクスチャのID。<BR>
      <BR>
      3. [IN] int　：　adjustuvflag<BR>
　　UV補正をする場合は１、しない場合は０。<BR>
　　しないとボケが大きいが右下にずれます。<BR>
<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.0.8<BR>ver5.3.0.5で拡張<BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DBlurTextureGauss5x5</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャにガウスブラーでぼかしをかけます。<BR>
      １パス処理です。<BR>
      <BR>ver5.3.0.5で引数追加。<BR>
</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　resultscid<BR>
      　　結果を描画するレンダーターゲットのスワップチェインID。<BR>
      <BR>
      2. [IN] int　：　srctexid<BR>
      　　ぼかしたいテクスチャのID。<BR>
      <BR>
      3. [IN] float　：　dispersion<BR>
      　　ぼかしの強さ。大きいほどぼける。<BR>
      　　この命令ではぼかしに限界があります。<BR>
      　　もっとたくさんぼかしたい場合は<BR>
      　　E3DBlurTextureGaussを使ってください。<BR>
      <BR>
      4. [IN] int　：　adjustuvflag<BR>
　　UV補正をする場合は１、しない場合は０。<BR>
　　しないとボケが大きいが右下にずれます。<BR>
<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.0.8<BR>ver5.3.0.5で拡張<BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DBlurTextureGauss</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャにガウスブラーでぼかしをかけます。<BR>
      縦方向のぼかしと横方向のぼかしの２パス構成です。<BR>
      E3Dの中では一番効果のあるぼかしです。<BR>
      <BR>
      具体的な使用例は<BR>
      BlurTextureソリューションをご覧ください。<BR>
      <BR>ver5.3.0.5で引数追加。<BR>
<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　resultscid<BR>
      　　結果を描画するレンダーターゲットのスワップチェインID。<BR>
      <BR>
      2. [IN] int　：　workscid<BR>
      　　途中経過格納用のレンダーターゲットテクスチャのスワップチェインID。<BR>
      <BR>
      3. [IN] int　：　worktexid<BR>
      　　途中経過格納用のレンダーターゲットテクスチャのテクスチャID。<BR>
      <BR>
      4. [IN] int　：　srctexid<BR>
      　　ぼかしたいテクスチャのID。<BR>
      <BR>
      5. [IN] float　：　dispersion<BR>
      　　ぼかしの強さ。大きいほどぼける。<BR>
      <BR>
      6. [IN] int　：　adjustuvflag<BR>
　　UV補正をする場合は１、しない場合は０。<BR>
　　しないとボケが大きいが右下にずれます。<BR>
<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.0.8<BR>ver5.3.0.5で拡張<BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DBlendRTTexture</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">２つのテクスチャをアルファブレンドし１つのテクスチャにレンダーします。<BR>
      <BR>
      ２つ目のテクスチャIDに-1を指定すると２個目のテクスチャは無効になり１個のテクスチャだけで処理が行われます。これはテクスチャのサイズを変えたい場合などに便利です。<BR>
      <BR>
      具体的な使用例は<BR>
      BlurTextureソリューションをご覧ください。<BR>
      <BR>ver5.3.0.5で引数追加。<BR>
<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　resultscid<BR>
      　　結果を描画するレンダーターゲットのスワップチェインID。<BR>
      <BR>
      2. [IN] int　：　texid1<BR>
      　　１枚目のテクスチャのID。<BR>
      　　最初に描画される。<BR>
      <BR>
      3. [IN] E3DCOLOR4F　：　col1<BR>
      　　頂点色を指定します。<BR>
      　　E3DCOLOR4Fはusercoef.hで定義されています。<BR>
      　　各値は0.0から1.0です。<BR>
      　　この色はtexid1のテクスチャの色に乗算されます。<BR>
      <BR>
      4. [IN] int　：　texf1<BR>
      　　texid1の拡大縮小フィルタの種類。<BR>
      　　D3DTEXF_POINTはぼけません。<BR>
      　　D3DTEXF_LINEARはぼけます。<BR>
      　　どちらかを指定してください。<BR>
      <BR>
      5. [IN] int　：　texid2<BR>
      　　２枚目のテクスチャのID。<BR>
      　　texid1の後に描画される。<BR>
      <BR>
      6. [IN] E3DCOLOR4F　：　col2<BR>      　　頂点色を指定します。<BR>
      　　E3DCOLOR4Fはusercoef.hで定義されています。<BR>
      　　各値は0.0から1.0です。<BR>
      　　この色はtexid2のテクスチャの色に乗算されます。<BR>
      <BR>
      7. [IN] int　：　texf2<BR>
      　　texid2の拡大縮小フィルタの種類。<BR>
      　　D3DTEXF_POINTはぼけません。<BR>
      　　D3DTEXF_LINEARはぼけます。<BR>
      　　どちらかを指定してください。<BR>
      <BR>
      8. [IN] int　：　blendop<BR>
      　　アルファブレンド操作の種類。<BR>
      　　D3DBLENDOP_で始まる定数を指定してください。<BR>
      <BR>
      9. [IN] 変数または、数値　：　srcblend<BR>
      　　D3DRS_SRCBLENDの値。<BR>
      　　D3DBLEND_で始まる定数を指定してください。<BR>
      <BR>
      10. [IN] 変数または、数値　：　destblend<BR>
      　　D3DRS_DESTBLENDの値。<BR>
      　　D3DBLEND_で始まる定数を指定してください。<BR>
      <BR>
      11. [IN] int　：　adjustuvflag<BR>
　　UV補正をする場合は１、しない場合は０。<BR>
　　しないとボケが大きいが右下にずれます。<BR>
<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.0.8<BR>
      ver5.3.0.5で拡張<BR>
      <BR>
</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DBeginSceneZbuf</TD>
      <TD class="hpb-cnt-tb-cell2">描画</TD>
      <TD class="hpb-cnt-tb-cell2">Zバッファを指定するE3DBeginScene。<BR>
      Zバッファを指定できる点を除いてE3DBeginSceneと同じです。<BR>
      E3DBeginSceneの説明をお読みください。<BR>
      <BR>
      ver5.2.1.0でskipflagを拡張しました。</TD>
      <TD class="hpb-cnt-tb-cell2"> 1. [IN] int　：　scid<BR>
      　　スワップチェインＩＤ。<BR>
      　　E3DInitやE3DCreateSwapChainで取得したＩＤを<BR>
      　　指定してください。<BR>
      <BR>
      2. [IN] int　：　skipflag<BR>      　　skipflagに０を指定すると色の初期化とZバッファの初期化と背景の描画を行います。<BR>
      　　skipflagに１を足すと色の初期化とZバッファの初期化と背景の描画を行いません。<BR>
      　　skipflagに２を足すとシェーダー定数のビデオカードへの転送をキャンセルします。<BR>
      　　skipflagに４を足すと色の初期化は行いますがZバッファの初期化と背景の描画は行いません。　<BR>
      　<BR>
      <BR>
      3. [IN] int　：　zscid<BR>
      　　Zバッファを指定できます。<BR>
      　　描画に使用したいZバッファを持つレンダーターゲットテクスチャなどのスワップチェインIDを指定します。<BR>
      　　この引数を省略した場合はscidで指定したZバッファが使用されます。<BR>
      　　zscidを指定した場合は指定したZバッファはこの命令で初期化されません。<BR>
      　　zscidで指定するZバッファはscidで指定したサーフェスの大きさと大きさが同じ時のみ有効です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.0.8<BR>
      ver5.2.1.0で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetClearCol</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">サーフェスのクリア色をスワップチェインごとに設定します。<BR>
      レンダーターゲットテクスチャのクリア色も設定できます。<BR>
      E3DBeginSceneより前で呼んでください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインIDを指定します。<BR>
      <BR>
      2. [IN] E3DCOLOR4UC　：　col<BR>
      　　クリア色を指定します。<BR>
      　　E3DCOLOR4UCはusercoef.hで定義されています。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.0.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMotionBlurMinAlpha</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">モーションブラーのブラーの消え具合を設定します。<BR>
      モーションブラーは動いた後の位置の透明度が１で<BR>
      動く前の位置の透明度はminAlphaとなります。<BR>
      ブラーの透明度は１からminAlphaまで徐々に薄くなっていくことになります。<BR>
      <BR>
      このminAlphaの値を調整することでブラーの消え具合を変えることが出来ます。<BR>
      <BR>
      何も設定しない状態ではminAlphaは0.2になっています。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するID。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　設定したいパーツの番号。<BR>
      　　-1を指定すると全てのパーツに設定します。<BR>
      <BR>
      3. [IN] float　：　minAlpha<BR>
      　　0.0から1.0までのfloat。<BR>
      　　ブラーの最小透明度を指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.0.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRenderGlow</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">グロー源を描画します。<BR>
      グローの使い方についてはrdb2_glow.htmをご覧ください。<BR>
      具体的な使用例は<BR>
      Glowソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int*　：　hsidarray<BR>
      　　描画したいhsidを配列に格納してください。<BR>
      <BR>
      2. [IN] int　：　num<BR>
      　　hsidarrayに何個のhsidを格納したかを指定してください。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMaterialGlowParams</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">グローの有効無効と色倍率を指定します。<BR>
      <BR>
      この命令でグローのモードやオンオフを変更すると<BR>
      マテリアルの透過方法transparentが自動的に適切なものに変更されます。<BR>
      モード変更前の状態に戻したい場合は<BR>
      E3DGetMaterialTransparentとE3DSetMaterialTransparent<BR>
      を使用して変更前の状態を保存しておいて復元してください。<BR>
      <BR>
      グローの使い方についてはrdb2_glow.htmをご覧ください。<BR>
      具体的な使用例は<BR>
      Glowソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [IN] int　：　glowmode<BR>
      　　グローのモードを指定します。<BR>
      　　GLOW_NONEを指定するとグローが無効になります。<BR>
      　　GLOW_NORMALを指定すると不透明グローになります。<BR>
      　　GLOW_ALPHAを指定すると半透明グローになります。<BR>
      　　GLOWで始まる定数はusercoef.hで定義されています。<BR>
      <BR>
      4. [IN] int　：　setcolflag<BR>
      　　colmult引数で指定した値を設定したいときは１を指定し、無視したいときは０を指定します。<BR>
      <BR>
      5. [IN] E3DCOLOR4F　：　colmult<BR>
      　　colmult.r, colmult.g, colmult.bにそれぞれRGBの倍率をしてしてください。<BR>
      　　colmult.aは無視されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialGlowParams</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">グローの有効無効と色倍率を取得します。<BR>
      グローの使い方についてはrdb2_glow.htmをご覧ください。<BR>
      具体的な使用例は<BR>
      Glowソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [OUT] int*　：　glowmodeptr<BR>
      　　グローのモードが代入されます。<BR>
      　　GLOW_NONEはグロー無し。<BR>
      　　GLOW_NORMALは不透明グロー。<BR>
      　　GLOW_ALPHAは半透明グロー。<BR>
      　　GLOWで始まる定数はusercoef.hで定義されています。<BR>
      <BR>
      4. [OUT] E3DCOLOR4F*　：　colmultptr<BR>
      　　RGBの倍率が代入されます。<BR>
      　　colmultptr-&gt;aは意味がありません。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMaterialTransparent</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャの透過方法を設定します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [IN] int　：　transparent<BR>
      　　テクスチャの透過モードを指定します。<BR>
      　　０を指定すると透過なし。<BR>
      　　１を指定すると黒色透過。<BR>
      　　２を指定するとテクスチャのアルファにより透過。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialTransparent</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャの透過方法を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [OUT] int*　：　transparentptr<BR>
      　　テクスチャの透過モードが代入されます。<BR>
      　　０は透過なし。<BR>
      　　１は黒色透過。<BR>
      　　２はテクスチャアルファによる透過。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChkHDR</TD>
      <TD class="hpb-cnt-tb-cell2">環境</TD>
      <TD class="hpb-cnt-tb-cell2">HDRで描画できるかどうかを調べます。<BR>
      E3DInitよりも後で呼び出します。<BR>
      主に浮動小数フォーマットのテクスチャが使えるかどうかが問題になります。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int　：　okflag<BR>
      　　HDRが使用できる場合は１が出来ない場合は０が代入されます。<BR>
      <BR>
      2. [OUT] int*　：　hdrformat<BR>
      　　HDRシーンを描画するときのテクスチャのフォーマットが代入されます。<BR>
      <BR>
      3. [OUT] int*　：　toneformat<BR>
      　　トーンマップを作成するときのテクスチャのフォーマットが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCheckSpec</TD>
      <TD class="hpb-cnt-tb-cell2">環境</TD>
      <TD class="hpb-cnt-tb-cell2">Easy3Dが実行可能かどうかを調べます。<BR>
      ピクセルシェーダー２．０が存在するかどうかや<BR>
      ストリームを３つ以上使えるかどうかなどを調べます。<BR>
      E3DInitよりも前で呼び出します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] HINSTANCE　：　hinst<BR>
      　　アプリケーションのhinstanceを<BR>
      　　渡します。<BR>
      <BR>
      2. [IN] HWND　：　hwnd<BR>
      　　メインウインドウのハンドルを<BR>
      　　渡してください。<BR>
      <BR>
      3. [OUT] int*　：　okflag<BR>
      　　Easy3Dが使用できる場合は１が出来ない場合は０が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDisablePostEffect</TD>
      <TD class="hpb-cnt-tb-cell2">環境</TD>
      <TD class="hpb-cnt-tb-cell2">デフォルトの動作ではdllと同じ場所にE3D_HLSLフォルダが無いとエラーになりますが、ポストエフェクト機能を使わないとこの命令で宣言すれば、E3D_HLSLフォルダがなくてもエラーになりません。<BR>
      <BR>
      E3DInitよりも前で１回だけ呼び出してください。</TD>
      <TD class="hpb-cnt-tb-cell2">なし</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetHDRLightDiffuse</TD>
      <TD class="hpb-cnt-tb-cell2">ライト</TD>
      <TD class="hpb-cnt-tb-cell2">HDR用の強いライト色（拡散光）を設定することが出来ます。<BR>
      浮動小数点で指定します。<BR>
      １．０は整数指定時の２５５に相当します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lid<BR>
      　　ライトを識別するid<BR>
      <BR>
      2. [IN] E3DCOLOR4F　：　col<BR>
      　　ライトの拡散色を指定します。<BR>
      　　E3DCOLOR4Fはusercoef.hで定義されています。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetHDRLightSpecular</TD>
      <TD class="hpb-cnt-tb-cell2">ライト</TD>
      <TD class="hpb-cnt-tb-cell2">HDR用の強いライト色（反射光）を設定することが出来ます。<BR>
      浮動小数点で指定します。<BR>
      １．０は整数指定時の２５５に相当します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lid<BR>
      　　ライトを識別するid<BR>
      <BR>
      2. [IN] E3DCOLOR4F　：　col<BR>
      　　ライトの反射色を指定します。<BR>
      　　E3DCOLOR4Fはusercoef.hで定義されています。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDownScaleRTTexture4x4</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">縦横それぞれ４分の１の大きさのレンダーターゲットテクスチャにコピーします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　dstscid<BR>
      　　描画先のレンダーターゲットテクスチャのスワップチェインID。小さい方のテクスチャ。<BR>
      <BR>
      2. [IN] int　：　srctexid<BR>
      　　描画元のレンダーターゲットテクスチャのテクスチャID。大きい方のテクスチャ。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDownScaleRTTexture2x2</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">縦横それぞれ２分の１の大きさのレンダーターゲットテクスチャにコピーします。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　dstscid<BR>
      　　描画先のレンダーターゲットテクスチャのスワップチェインID。小さい方のテクスチャ。<BR>
      <BR>
      2. [IN] int　：　srctexid<BR>
      　　描画元のレンダーターゲットテクスチャのテクスチャID。大きい方のテクスチャ。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateToneMapTexture</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">トーンマップテクスチャを作成します。<BR>
      トーンマップテクスチャとはシーンの明るさを計測するために使用するレンダーターゲットテクスチャです。<BR>
      <BR>
      一度に有効にできるトーンマップの組は１０組までです。<BR>
      それ以上のトーンマップを使用したい場合はE3DDestroyToneMapTextureを呼んで不要なものを削除してから<BR>
      この命令を呼んでください。<BR>
      <BR>
      具体的な使用例は<BR>
      HDRLightingソリューションをご覧ください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　tonenum<BR>
      　　トーンマップテクスチャの数を指定します。<BR>
      　　３以上の数を指定してください。<BR>
      　　トーンマップは１X1の大きさのものから順番に４倍ずつしたサイズのテクスチャになります。<BR>
      　　例えばtonenumに４を指定した場合は<BR>
      　　1X1, 4X4, 16X16, 64X64のサイズのテクスチャが内部で作成されます。<BR>
      <BR>
      2. [IN] int　：　toneformat<BR>
      　　トーンマップテクスチャのフォーマット。<BR>
      　　E3DChkHDRで取得したtoneformatを指定してください。<BR>
      　　<BR>
      3. [OUT] int*　：　tonemapid<BR>
      　　作成したトーンマップを識別するIDが代入されます。<BR>
      <BR>
      4. [OUT] int*　：　okflag<BR>
      　　命令が成功した場合には１が失敗した場合には０が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyToneMapTexture</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャ</TD>
      <TD class="hpb-cnt-tb-cell2">トーンマップテクスチャを削除します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　tonemapid<BR>
      　　削除するトーンマップを識別するID。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRenderToneMap</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">トーンマップにシーンの明るさをレンダリングし明るさを計測します。<BR>
      <BR>
      具体的な使用例は<BR>
      HDRLightingソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　tonemapid<BR>
      　　トーンマップを識別するID。<BR>
      <BR>
      2. [IN] int　：　srctexid<BR>
      　　明るさを計測したいテクスチャのID。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DBrightPassRTTextureHDR</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">HDRで描画したテクスチャの明るい部分だけを抜き出しLDRに変換します。<BR>
      <BR>
      具体的な使用例は<BR>
      HDRLightingソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　dstscid<BR>
      　　描画先のスワップチェインID。<BR>
      　　<BR>
      2. [IN] int　：　srctexid<BR>
      　　HDRで描画されている元画像の入ったテクスチャのID。<BR>
      　　<BR>
      3. [IN] float　：　middlegray<BR>
      　　画面の明るさを決めるキーになる値。<BR>
      　　実数。<BR>
      　　<BR>
      4. [IN] float　：　threshold<BR>
      　　この値より暗い部分は色が０になる。<BR>
      　　実数。<BR>
      <BR>
      5. [IN] float　：　offset<BR>
      　　thresholdで色成分を引いた後にoffsetだけ色を足します。<BR>
      　　<BR>
      6. [IN] int　：　tonemapid<BR>
      　　シーンの明るさを記録してあるトーンマップのID。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRenderHDRFinal</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">HDRシーンとブルーム画像を合成しLDRに変換して描画します。<BR>
      <BR>
      <BR>
      具体的な使用例は<BR>
      HDRLightingソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　dstscid<BR>
      　　描画先のスワップチェインID。<BR>
      　　<BR>
      2. [IN] int　：　srctexid0<BR>
      　　HDRで描画されている元画像の入ったテクスチャのID。<BR>
      <BR>
      3. [IN] int　：　srctexid1<BR>
      　　ブルーム画像のテクスチャID。<BR>
      <BR>
      4. [IN] int　：　tonemapid<BR>
      　　トーンマップのID。<BR>
      <BR>
      5. [IN] float　：　middlegray<BR>
      　　シーンの明るさを決定するキーの値。<BR>
      　　E3DBrightPassRTTextureHDRに指定したのと同じ値を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DMonoRTTexture</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャの内容を白黒画像に変換します。<BR>
      <BR>
      具体的な使用例は<BR>
      Monoソリューションをご覧ください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　dstscid<BR>
      　　描画先のスワップチェインID。<BR>
      　　<BR>
      2. [IN] int　：　srctexid<BR>
      　　元画像の入ったテクスチャのID。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCbCrRTTexture</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャの内容をYCbCr色空間に変換しYを保ったままCbとCrを指定値に設定します。<BR>
      <BR>
      YCbCrの値のセットがどんな色になるのかはPhotoShopなどのペイントソフトで確認してください。<BR>
      <BR>
      具体的な使用例は<BR>
      CbCrソリューションをご覧ください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　dstscid<BR>
      　　描画先のスワップチェインID。<BR>
      　　<BR>
      2. [IN] int　：　srctexid<BR>
      　　元画像の入ったテクスチャのID。<BR>
      <BR>
      3. [IN] float　：　cb<BR>
      　　YCbCrのCbの値。<BR>
      <BR>
      4. [IN] float　：　cr<BR>
      　　YCbCrのCrの値。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DShaderConstOffset16</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">posteffect.fxのデータfloat2 avSampleOffsets[16]に値を設定します。<BR>
      このデータは他の命令でも使われます。<BR>
      （使われている場所はposteffect.fxで確認してください。）<BR>
      他の命令で上書きされることがあるのでその都度設定してください。<BR>
      <BR>
      offsetarrayには<BR>
      D3DXVECTOR2 offsetarray[16];<BR>
      で確保した配列を使用してください。<BR>
      自分で値をセットしてから命令に渡してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR2*　：　offsetarray<BR>
      　　セットしたい値が設定してある配列。<BR>
      　　詳しくは前記をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DShaderConstWeight16</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">posteffect.fxのデータfloat4 avSampleWeights[16]に値を設定します。<BR>
      このデータは他の命令でも使われます。<BR>
      （使われている場所はposteffect.fxで確認してください。）<BR>
      他の命令で上書きされることがあるのでその都度設定してください。<BR>
      <BR>
      weightarrayには<BR>
      D3DXVECTOR4 weightarray[16];<BR>
      で確保した配列を使用してください。<BR>
      自分で値をセットしてから命令に渡してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR4*　：　weightarray<BR>
      　　セットしたい値が設定してある配列。<BR>
      　　詳しくは前記をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DShaderConstUserFL4</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">posteffect.fxのデータfloat4 userFL4_0からuserFL4_9のどれかに値を設定します。<BR>
      <BR>
      自分で値をセットしてから命令に渡してください。<BR>
      <BR>
      具体的な使用例は<BR>
      CustomShaderソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　datano<BR>
      　　userFL4_0からuserFL4_9までのどれに値をセットするかを０から９の整数で指定します。<BR>
      <BR>
      2. [IN] D3DXVECTOR4　：　fl4<BR>
      　　セットしたい値が設定してあるD3DXVECTOR4。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DShaderConstUserTex</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">posteffect.fxのデータtexture usertex0からusertex4のどれかに値を設定します。<BR>
      <BR>
      具体的な使用例は<BR>
      CustomShaderソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　datano<BR>
      　　usertex0からusetex4までのどれに値をセットするかを０から４の整数で指定します。<BR>
      <BR>
      2. [IN] int　：　srctexid<BR>
      　　設定したいテクスチャを識別するID。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCallUserShader</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">posteffect.fxのtechnique PostEffectUser0からPostEffectUser4のうちの一つを実行します。<BR>
      実行するパスも１つだけ選べます。<BR>
      <BR>
      具体的な使用例は<BR>
      CustomShaderソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　shaderno<BR>
      　　PostEffectUser0からPostEffectUser4までのどれを実行するかを０から４の整数で指定します。<BR>
      <BR>
      2. [IN] int　：　passno<BR>
      　　テクニックの何番のパスを実行するかを指定します。<BR>
      　　例えばpass P0を実行したいときは０をpass P1を実行したいときは１を指定します。<BR>
      　　記述してあるパスの番号最大値よりも大きい値を指定するとエラーになります。<BR>
      <BR>
      3. [IN] int　：　dstscid<BR>
      　　描画先のスワップチェインID。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateBone</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンを新規に作成します。<BR>
      <BR>
      読み込み済みのモーションは全て破棄されます。<BR>
      <BR>
      影響度の再計算はしません。<BR>
      したい場合はE3DJointRemakeを呼び出してください。<BR>
      <BR>
      ボーンの位置はE3DSetJointInitialPosで設定してください。<BR>
      <BR>
      Easy3Dの仕様上ボーンを破棄するとゴミデータが残ります。<BR>
      ゴミデータはあまり多くなると描画速度に影響します。<BR>
      E3DCreateBoneにはゴミデータが存在すればそれを再利用するような仕組みがあります。<BR>
      ですのでまず不要なボーンをE3DDestroyBoneした後にE3DCreateBoneするとゴミが少なくて済みます。<BR>
      ゴミの掃除の仕方はRokDeBone2ver5.2.1.3の新機能のページの説明をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] const char*　：　nameptr<BR>
      　　ボーンの名前を格納した文字列。<BR>
      　　２５５バイトまでです。<BR>
      　　終端はNULL（０）にしてください。<BR>
      <BR>
      3. [IN] int　：　parentid<BR>
      　　親になるジョイントを識別するパーツのID。<BR>
      　　一番親のボーンを作成する場合以外は必ずジョイントのIDを指定してください。<BR>
      　　一番親のボーンを作成するときは-1を指定してください。-1を指定するとパーツをまとめる役割をするパーツのうちで一番最後に作られたパーツが親になります。<BR>
      ( 通常は「Joint Part」という名前のパーツになります。)<BR>
      <BR>
      4. [OUT] int*　：　serialidptr<BR>
      　　新たに作成されたボーンを識別するID(パーツのID)が代入されます。<BR>
      　　エラーが生じた場合は-1が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyBone</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンを破棄します。<BR>
      <BR>
      読み込み済みのモーションは全て破棄されます。<BR>
      <BR>影響度の再計算は強制的に行われます。<BR>
      <BR>
      E3DCreateBoneの説明もお読みください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　削除したいボーンを識別するID。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.1.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMorphBaseNum</TD>
      <TD class="hpb-cnt-tb-cell2">モーフ</TD>
      <TD class="hpb-cnt-tb-cell2">モーフのベースの数を取得します。<BR>
      それぞれのモーフにはベースは１個だけしか含まれないので<BR>
      この数はモーフの数と一致します。<BR>
      <BR>
      具体的な使用例は<BR>
      MorphInfoソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [OUT] int*　：　basenumptr<BR>
      　　ベースの数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMorphBaseInfo</TD>
      <TD class="hpb-cnt-tb-cell2">モーフ</TD>
      <TD class="hpb-cnt-tb-cell2">モーフのベースの情報を一括で取得します。<BR>
      <BR>
      具体的な使用例は<BR>
      MorphInfoソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [OUT] E3DMORPHBASE*　：　baseinfoptr<BR>
      　　ベースの情報が代入されます。<BR>
      　　E3DMORPHBASEはusercoef.hで定義されています。<BR>
      　　<BR>
      　　E3DGetMorphBaseNum( hsid, &amp;basenum );<BR>
      　　baseinfo = (E3DMORPHBASE*)malloc( sizeof( E3DMORPHBASE ) * basenum );<BR>
      　　のようにして作成したメモリを指定してください。<BR>
      <BR>
      3. [IN] int　：　arrayleng<BR>
      　　baseinfoの要素数を指定してください。<BR>
      　　E3DGetMorphBaseNumで取得したbasenum個じゃないとエラーになります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMorphTargetInfo</TD>
      <TD class="hpb-cnt-tb-cell2">モーフ</TD>
      <TD class="hpb-cnt-tb-cell2">モーフのターゲットの情報をモーフごと（ベースごと）に取得します。<BR>
      <BR>
      具体的な使用例は<BR>
      MorphInfoソリューションをご覧ください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　baseid<BR>
      　　モーフのベースを識別する番号を指定してください。<BR>
      　　E3DGetMorphBaseInfoで取得したbaseinfoptr-&gt;dispnoを指定してください。<BR>
      <BR>
      3. [OUT] E3DMORPHTARGET*　：　targetinfoptr<BR>
      　　ターゲットの情報が代入されます。<BR>
      　　E3DMORPHTARGETはusercoef.hで定義されています。<BR>
      　<BR>
      　　ベースに含まれるターゲット数分の要素数のメモリを渡してください。<BR>
      　　targetinfo = (E3DTARGETINFO*)malloc( sizeof( E3DTARGETINFO ) * (baseinfo
      + baseno)-&gt;targetnum );<BR>
      　　のようにして作成してください。<BR>
      <BR>
      4. [IN] int　：　arrayleng<BR>
      　　targetinfoの要素数を指定してください。<BR>
      　　ベースに含まれるターゲット数と異なる場合にはエラーになります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMorphKeyNum</TD>
      <TD class="hpb-cnt-tb-cell2">モーフ</TD>
      <TD class="hpb-cnt-tb-cell2">モーフモーションのキーの数を取得します。<BR>
      <BR>
      具体的な使用例は<BR>
      MorphInfoソリューションをご覧ください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　boneid<BR>
      　　モーフモーション情報の格納先のボーンを識別する番号を指定してください。<BR>
      　　E3DGetMorphBaseInfoで取得したbaseinfoptr-&gt;bonenoを指定してください。<BR>
      <BR>
      4. [IN] int　：　baseid<BR>
      　　モーフのベースを識別する番号を指定してください。<BR>
      　　E3DGetMorphBaseInfoで取得したbaseinfoptr-&gt;dispnoを指定してください。<BR>
      <BR>
      5. [IN] int　：　targetid<BR>
      　　モーフのターゲットを識別する番号を指定してください。<BR>
      　　E3DGetMorphTargetInfoで取得したtargetinfoptr-&gt;dispnoを指定してください。<BR>
      <BR>
      6. [OUT] int*　：　keynumptr<BR>
      　　キーの数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMorphKey</TD>
      <TD class="hpb-cnt-tb-cell2">モーフ</TD>
      <TD class="hpb-cnt-tb-cell2">モーフモーションの情報をキーの数分取得します。<BR>
      <BR>
      具体的な使用例は<BR>
      MorphInfoソリューションをご覧ください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　boneid<BR>
      　　モーフモーション情報の格納先のボーンを識別する番号を指定してください。<BR>
      　　E3DGetMorphBaseInfoで取得したbaseinfoptr-&gt;bonenoを指定してください。<BR>
      <BR>
      4. [IN] int　：　baseid<BR>
      　　モーフのベースを識別する番号を指定してください。<BR>
      　　E3DGetMorphBaseInfoで取得したbaseinfoptr-&gt;dispnoを指定してください。<BR>
      <BR>
      5. [IN] int　：　targetid<BR>
      　　モーフのターゲットを識別する番号を指定してください。<BR>
      　　E3DGetMorphTargetInfoで取得したtargetinfoptr-&gt;dispnoを指定してください。<BR>
      <BR>
      6. [OUT] E3DMORPHMOTION*　：　motioninfoptr<BR>
      　　モーション情報が代入されます。<BR>
      　　E3DMORPHMOTIONはusercoef.hで定義されています。<BR>
      <BR>
      　　E3DGetMorphKeyNum( hsid, motid, baseid, targetid, &amp;keynum );<BR>
      　　motioninfo = (E3DMORPHMOTION*)malloc( sizeof( E3DMORPHMOTION ) * keynum
      );<BR>
      　　のようにしてメモリを作成してください。<BR>
      <BR>
      7. [IN] int　：　arrayleng<BR>
      　　motioninfoptrの要素数を指定してください。<BR>
      　　E3DGetMorphKeyNumで取得したkeynum個じゃないとエラーになります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCurMorphInfo</TD>
      <TD class="hpb-cnt-tb-cell2">モーフ</TD>
      <TD class="hpb-cnt-tb-cell2">任意のフレーム番号の補間済みのモーフモーション情報を取得します。<BR>
      この命令では現在のモーションID、フレーム番号についての情報を取得します。<BR>
      任意のモーション、フレーム番号の情報を取得したい場合は<BR>
      E3DSetMotionFrameNoと組み合わせて使ってください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneid<BR>
      　　モーフモーション情報の格納先のボーンを識別する番号を指定してください。<BR>
      　　E3DGetMorphBaseInfoで取得したbaseinfoptr-&gt;bonenoを指定してください。<BR>
      <BR>
      3. [IN] int　：　baseid<BR>
      　　モーフのベースを識別する番号を指定してください。<BR>
      　　E3DGetMorphBaseInfoで取得したbaseinfoptr-&gt;dispnoを指定してください。<BR>
      <BR>
      4. [IN] int　：　targetid<BR>
      　　モーフのターゲットを識別する番号を指定してください。<BR>
      　　E3DGetMorphTargetInfoで取得したtargetinfoptr-&gt;dispnoを指定してください。<BR>
      <BR>
      5. [OUT] E3DMORPHMOTION*　：　motioninfoptr<BR>
      　　モーション情報が代入されます。<BR>
      　　E3DMORPHMOTIONはusercoef.hで定義されています。<BR>
      <BR>
      　　要素数は１。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateMorph</TD>
      <TD class="hpb-cnt-tb-cell2">モーフ</TD>
      <TD class="hpb-cnt-tb-cell2">モーフを作成します。<BR>
      ベースのIDとボーンのIDを指定します。<BR>
      ここで指定したボーンに作成したモーフのモーション情報が格納されます。<BR>
      <BR>
      この命令を呼ぶと読み込み済みのモーションは全て破棄されます。<BR>
      <BR>
      <BR>
      具体的な使用例は<BR>
      MorphInfo_Createソリューションをご覧ください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　baseid<BR>
      　　ベースを識別する番号を指定してください。<BR>
      　　E3DGetPartNoByNameなどでIDを取得して指定してください。<BR>
      <BR>
      3. [IN] int　：　boneid<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      　　E3DGetPartNoByNameなどでIDを取得して指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DAddMorphTarget</TD>
      <TD class="hpb-cnt-tb-cell2">モーフ</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateMorphで作成したモーフにターゲットを追加します。<BR>
      <BR>
      具体的な使用例は<BR>
      MorphInfo_Createソリューションをご覧ください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　baseid<BR>
      　　ベースを識別する番号を指定してください。<BR>
      　　E3DGetPartNoByNameなどでIDを取得して指定してください。<BR>
      <BR>
      3. [IN] int　：　targetid<BR>
      　　ターゲットを識別する番号を指定してください。<BR>
      　　E3DGetPartNoByNameなどでIDを取得して指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMorphKey</TD>
      <TD class="hpb-cnt-tb-cell2">モーフ</TD>
      <TD class="hpb-cnt-tb-cell2">モーフモーションのキーを作成します。<BR>
      キーがすでにある場合は既存のキーに上書きします。<BR>
      <BR>
      具体的な使用例は<BR>
      MorphInfo_Createソリューションをご覧ください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　boneid<BR>
      　　モーフモーション情報の格納先のボーンを識別する番号を指定してください。<BR>
      　　E3DGetMorphBaseInfoで取得したbaseinfoptr-&gt;bonenoを指定してください。<BR>
      <BR>
      4. [IN] int　：　baseid<BR>
      　　モーフのベースを識別する番号を指定してください。<BR>
      　　E3DGetMorphBaseInfoで取得したbaseinfoptr-&gt;dispnoを指定してください。<BR>
      <BR>
      5. [IN] int　：　targetid<BR>
      　　モーフのターゲットを識別する番号を指定してください。<BR>
      　　E3DGetMorphTargetInfoで取得したtargetinfoptr-&gt;dispnoを指定してください。<BR>
      <BR>
      6. [IN] E3DMORPHMOTION*　：　motioninfoptr<BR>
      　　モーフモーション情報を指定します。要素数１。<BR>
      　　E3DMORPHMOTIONはusercoef.hで定義されています。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyMorphKey</TD>
      <TD class="hpb-cnt-tb-cell2">モーフ</TD>
      <TD class="hpb-cnt-tb-cell2">モーフモーションのキーを削除します。<BR>
      モーフに含まれる全てのターゲットのキーが削除されます。<BR>
      <BR>
      具体的な使用例は<BR>
      MorphInfo_Createソリューションをご覧ください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">      1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　boneid<BR>
      　　モーフモーション情報の格納先のボーンを識別する番号を指定してください。<BR>
      　　E3DGetMorphBaseInfoで取得したbaseinfoptr-&gt;bonenoを指定してください。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　削除したいキーが存在するフレーム番号を指定してください。<BR>
      <BR>
      5. [IN] int　：　baseid<BR>
      　　モーフのベースを識別する番号を指定してください。<BR>
      　　E3DGetMorphBaseInfoで取得したbaseinfoptr-&gt;dispnoを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetToon1Material</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">トゥーンマテリアルの情報をパーツごとに一括取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      　　E3DGetDispObjInfoで取得した表示オブジェクトのIDを指定してください。<BR>
      <BR>
      3. [OUT] E3DTOON1MATERIAL*　：　toon1ptr<BR>
      　　トゥーンマテリアルの情報が代入されます。<BR>
      　　E3DTOON1MATERIALはusercoef.hで定義されています。<BR>
      　　E3DGetToon1MaterialNumで取得した数をmatnumとすると<BR>
      　　toon1ptr = (E3DTOON1MATERIAL*)malloc( sizeof( E3DTOON1MATERIAL ) * matnum
      );<BR>
      　　のように作成したメモリを渡してください。<BR>
      <BR>
      4. [IN] int　：　arrayleng<BR>
      　　toon1ptrを作成したときの要素数を指定します。<BR>
      　　E3DGetToon1MaterialNumで取得できるmatnumと異なるとエラーになります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetToon1Name</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">トゥーンマテリアルの名前を変更します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      　　E3DGetDispObjInfoで取得した表示オブジェクトのIDを指定してください。<BR>
      <BR>
      3. [IN] char*　：　oldname<BR>
      　　名前を変えたいトゥーンマテリアルの元の名前<BR>
      <BR>
      4. [IN] char*　：　newname<BR>
      　　トゥーンマテリアルの新しい名前。<BR>
      　　名前の長さは３１バイトまでです。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetToon1Diffuse</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">トゥーンマテリアルのDiffuse色を設定します。<BR>
      ライトが当たった明るい部分の色です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      　　E3DGetDispObjInfoで取得した表示オブジェクトのIDを指定してください。<BR>
      <BR>
      3. [IN] char*　：　matname<BR>
      　　トゥーンマテリアルの名前<BR>
      <BR>
      4. [IN] RDBColor3f　：　diffuse<BR>
      　　diffuse色。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetToon1Specular</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">トゥーンマテリアルのSpecular色を設定します。<BR>
      ハイライトの部分の色です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      　　E3DGetDispObjInfoで取得した表示オブジェクトのIDを指定してください。<BR>
      <BR>
      3. [IN] char*　：　matname<BR>
      　　トゥーンマテリアルの名前<BR>
      <BR>
      4. [IN] RDBColor3f　：　specular<BR>
      　　specular色。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetToon1Ambient</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">トゥーンマテリアルのAmbient色を設定します。<BR>
      ライトが当たらない暗い部分の色です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      　　E3DGetDispObjInfoで取得した表示オブジェクトのIDを指定してください。<BR>
      <BR>
      3. [IN] char*　：　matname<BR>
      　　トゥーンマテリアルの名前<BR>
      <BR>
      4. [IN] RDBColor3f　：　ambient<BR>
      　　ambient色。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetToon1NL</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">トゥーン表示のdiffuse, specular, ambientの割合を決めるための係数を設定します。<BR>
      <BR>
      色の割合は面の法線とライトの反転ベクトルとのなす角度（deg）で決定します。<BR>
      暗い色の角度の閾値をdarkdeg, ハイライトの角度の閾値をbrightdegとします。<BR>
      degがdarkdegより大きい角度の部分は暗い色(ambient)で塗ります。<BR>
      degがbrightdegより小さい角度の場合はハイライト（specular）で塗ります。<BR>
      それ以外の部分は明るい色(diffuse)で塗ります。<BR>
      darkdeg &gt;= brightdegでないといけません。<BR>
      ピンとこない方はRokDeBone2で「トゥ」ボタンを押してdarkdegとbrightdegを設定するスライダーを動かしてみて理解してください。<BR>
      <BR>
      RokDeBone2内部ではこれらの閾値は角度ではなくてcosの値で保持しています。<BR>
      そのためこの命令に渡す値もcos( darkdeg * DEG2PAI )とcos( brightdeg * DEG2PAI )を渡してください。<BR>
      DEG2PAIは「度」を「ラジアン」に変換するための定数です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      　　E3DGetDispObjInfoで取得した表示オブジェクトのIDを指定してください。<BR>
      <BR>
      3. [IN] char*　：　matname<BR>
      　　トゥーンマテリアルの名前<BR>
      <BR>
      4. [IN] float　：　darknl<BR>
      　　cos( darkdeg * DEG2PAI )を指定してください。<BR>
      　　詳しくは前記をご覧ください。<BR>
      <BR>
      5. [IN] float　：　brightnl<BR>
      　　cos( brightdeg * DEG2PAI )を指定してください。<BR>
      　　詳しくは前記をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetToon1Edge0</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">トゥーンマテリアルのエッジ（輪郭線）のパラメータを設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      　　E3DGetDispObjInfoで取得した表示オブジェクトのIDを指定してください。<BR>
      <BR>
      3. [IN] char*　：　matname<BR>
      　　トゥーンマテリアルの名前<BR>
      <BR>
      4. [IN] RDBColor3f　：　col<BR>
      　　輪郭線の色。<BR>
      <BR>
      5. [IN] int　：　validflag<BR>
      　　輪郭線を表示するときは１。しないときは０。<BR>
      <BR>
      6. [IN] int　：　invflag<BR>
      　　輪郭線用の面の向きを反転するときは１。しないときは０。通常は０。<BR>
      　　両面オブジェクトの調整用。<BR>
      <BR>
      7. [IN] float　：　width<BR>
      　　輪郭線の幅。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadCameraFile</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">RokDeBone2で作成したカメラファイル（*.cam）を読み込み<BR>
      アニメ番号を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　カメラファイルのファイル名をフルパスで指定してください。<BR>
      <BR>
      2. [OUT] int*　：　animnoptr<BR>
      　　読み込んだアニメを識別するアニメ番号が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyCameraAnim</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメを破棄します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSaveCameraFile</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメをテキストファイルに保存します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　カメラファイルのファイル名をフルパスで指定してください。<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetCameraAnimNo</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カレントのカメラアニメ番号をセットします。<BR>
      フレーム番号は０に戻ります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCameraAnimNo</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カレントのカメラアニメ番号を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　animnoptr<BR>
      　　カメラアニメを識別する番号が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetCameraFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">再生するカメラアニメのアニメ番号とカメラ番号とフレーム番号を設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　camerano<BR>
      　　カメラ番号を指定します（０から２）。<BR>
      　　カメラ番号に-1を指定するとカメラのスイッチキーに基づいてカメラを切り替え再生します。<BR>
      <BR>
      3. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　isfirst<BR>
      　　この命令を呼んだ後にE3DSetNewCameraを呼び出す場合は１を、呼び出さない場合は０を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCameraFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">現在再生中のカメラアニメのアニメ番号、カメラ番号、フレーム番号を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　animnoptr<BR>
      　　カメラアニメを識別する番号が代入されます。<BR>
      <BR>
      2. [OUT] int*　：　cameranoptr<BR>
      　　カメラ番号が代入されます。<BR>
      <BR>
      3. [OUT] int*　：　framenoptr<BR>
      　　フレーム番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetNewCamera</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラのフレームをアニメタイプに従って進め、新しいカメラ情報をセットします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　camerano<BR>
      　　カメラ番号を指定します（０から２）。<BR>
      　　カメラ番号に-1を指定するとカメラのスイッチキーに基づいてカメラを切り替え再生します。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetNextCameraAnimFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">animnoで識別されるアニメがbefframenoのフレーム番号に達したらnextanimnoで識別されるアニメのnextframenoに切り替えることを予約します。<BR>
      アニメの切り替えはE3DSetNewCameraで行われます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　nextanimno<BR>
      　　切り替え先のカメラアニメを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　nextframeno<BR>
      　　切り替え先のカメラアニメのフレーム番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　befframeno<BR>
      　　切り替え前のカメラアニメがbefframenoフレームまで達したらアニメの切り替えが起こります。<BR>
      　　-1を指定した場合は切り替え前のアニメが最終フレームに達したときにアニメが切り替わります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetNextCameraAnimFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">E3DSetNextCameraAnimFrameNoで設定した情報を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [OUT] int*　：　nextanimnoptr<BR>
      　　切り替え先のカメラアニメを識別する番号が代入されます。<BR>
      <BR>
      3. [OUT] int*　：　nextframenoptr<BR>
      　　切り替え先のカメラアニメのフレーム番号が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateNewCameraAnim</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメを作成しアニメを識別する番号を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　animname<BR>
      　　アニメの名前を指定します。<BR>
      　　２５５バイトまでです。<BR>
      <BR>
      2. [IN] int　：　animtype<BR>
      　　アニメの振る舞いを指定します。<BR>
      　　１を指定するとフレーム番号は進みません。<BR>
      　　２を指定すると最終フレーム番号に達したらその状態を維持します。<BR>
      　　３を指定するとループします。<BR>
      　　４を指定するとピンポン再生します。<BR>
      　　５を指定すると最終フレームに達した後RokDeBone2で指定したフレームにジャンプします。<BR>
      <BR>
      3. [IN] int　：　framenum<BR>
      　　カメラアニメをのフレーム数を指定します。<BR>
      <BR>
      4. [OUT] int*　：　animnoptr<BR>
      　　作成したアニメを識別する番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetCameraFrameNum</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメのフレーム長を設定します。<BR>
      現在のフレーム長よりも小さい値を指定した場合は<BR>
      範囲からはみ出たキーは削除されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　framenum<BR>
      　　フレーム長を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCameraFrameNum</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメのフレーム長を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [OUT] int*　：　framenumptr<BR>
      　　フレーム長が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetCameraAnimName</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメの名前を設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] char*　：　srcname<BR>
      　　カメラアニメの名前を指定します。<BR>
      　　２５５バイトまでです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCameraAnimName</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメの名前を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [OUT] char*　：　dstname<BR>
      　　名前を格納する文字列の変数を指定します。<BR>
      <BR>
      3. [IN] int　：　arrayleng<BR>
      　　dstnameの配列長を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetCameraAnimType</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメのタイプを設定します。<BR>
      タイプの詳細はE3DCreateNewCameraAnimのanimtype引数の説明をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　type<BR>
      　　タイプを指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCameraAnimType</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメのタイプを取得します。<BR>
      タイプの詳細はE3DCreateNewCameraAnimのanimtype引数の説明をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [OUT] int*　：　typeptr<BR>
      　　タイプが代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetCameraKey</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメのキーを設定します。<BR>
      指定したフレーム番号にキーが存在しない場合は自動的に作成してから設定します。<BR>
      <BR>
      E3DCAMERASTATEはusercoef.hで定義されています。<BR>
      <BR>
      以下E3DCAMERASTATE構造体のメンバの説明。<BR>
      looktypeは注視モードです。<BR>
      現在注視なしモードしかサポートしていませんので<BR>
      CAML_NORMALを指定してください。<BR>
      <BR>
      hsidとbonenoは将来の拡張用のインデックスです。<BR>
      -1を指定してください。<BR>
      <BR>
      <S>orthoも将来の拡張用のインデックスです。０を指定してください。</S><BR>
      <BR>
      interpはキー間の補間方法へのインデックスです。<BR>
      ０を指定すると線形、１を指定するとスプライン補間になります。<BR>
      <BR>
      pos<BR>
      はカメラ位置のXYZ座標へのインデックスです。<BR>
      <BR>
      target<BR>
      はカメラの注視点のXYZ座標へのインデックスです。<BR>
      <BR>
      up<BR>
      はカメラの上方向ベクトルのXYZ成分へのインデックスです。<BR>
      <BR>
      dist<BR>
      はカメラと注視点の距離へのインデックスです。<BR>
      <BR>
      nearz, farz<BR>
      はプロジェクションの一番近い距離と一番遠い距離へのインデックスです。<BR>
      <BR>
      fov<BR>
      はプロジェクションの視野角へのインデックスです。<BR>
      <BR>
      <S>orthosize<BR>
      は将来の拡張用のインデックスです。3000.0などの数値を入れておいてください。</S><BR>
      <BR>
      <BR>
      具体的な使用例は<BR>
      CameraAnimeソリューションをご覧ください。<BR>
      <BR>
      <BR>
      ver5.2.2.8で正射影に対応しました。<BR>
      orthoはパース表示のとき０、正射影表示のとき１を指定します。<BR>
      <BR>
      orthosizeは正射影のときのビューのサイズを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　camerano<BR>
      　　カメラ番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      4. [IN] E3DCAMERASTATE　：　camstate<BR>
      　　カメラキーのメンバをセットします。<BR>
      　　詳しくは前記をご覧ください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCameraKey</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメのキーの情報を取得します。<BR>
      指定したフレーム番号にキーが無い場合は補間計算して情報を取得します。<BR>
      <BR>
      E3DCAMERASTATEについてはE3DSetCameraKeyの説明をご覧ください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　camerano<BR>
      　　カメラ番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      4. [OUT] E3DCAMERASTATE*　：　csptr<BR>
      　　カメラキーのメンバが代入されます。<BR>
      <BR>
      5. [OUT] int*　：　exsitflag<BR>
      　　指定したフレーム番号にキーがあった場合は１が<BR>
      　　無かった場合には０が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDeleteCameraKey</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメのキーを削除します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　camerano<BR>
      　　カメラ番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCameraKeyframeNoRange</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">startとendで指定したフレーム範囲のキーフレームの個数とフレーム番号を取得します。<BR>
      <BR>
      arraylengに０を指定して呼び出すとframearray引数への代入を行わずにキーの個数のみを取得します。<BR>
      <BR>
      E3DGetCameraKeyframeNoRange( animno, camno, start, end, 0, 0, &amp;keynum );<BR>
      <BR>
      framearray = (int*)malloc( sizeof( int ) * keynum );<BR>
      <BR>
      E3DGetCameraKeyframeNoRange( animno, camno, start, end, framearray, keynum,
      &amp;chknum );<BR>
      <BR>
      のようにして使ってください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　camerano<BR>
      　　カメラ番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　start<BR>
      4. [IN] int　：　end<BR>
      　　キーを調べたいフレーム番号の最初と最後の値を指定してください。<BR>
      <BR>
      5. [OUT] int*　：　framearray<BR>
      　　フレーム番号がgetnum個だけ代入されます。<BR>
      　　arraylengが０の場合は代入されません。<BR>
      <BR>
      6. [IN] int　：　arrayleng<BR>
      　　framearrayの配列長（要素数）を指定してください。<BR>
      　　０を指定するとキーの個数だけを調べます。<BR>
      <BR>
      7. [OUT] int*　：　getnumptr<BR>
      　　取得したキーフレーム番号の個数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetCameraSWKey</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメのスイッチキーをセットします。<BR>
      指定したフレーム番号にキーが存在しない場合は自動的に作成してからセットします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　camerano<BR>
      　　カメラ番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCameraSWKey</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメのスイッチキーの情報を取得します。<BR>
      指定したフレーム番号にキーが存在しない場合は補間して情報を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　cameranoptr<BR>
      　　カメラ番号が代入されます。<BR>
      <BR>
      4. [OUT] int*　：　existflagptr<BR>
      　　指定したフレーム番号にキーがあった場合は１が<BR>
      　　無かった場合には０が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDeleteCameraSWKey</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメのスイッチキーを削除します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetCameraSWKeyframeNoRange</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">startとendで指定したフレーム範囲のスイッチキーフレームの個数とフレーム番号を取得します。<BR>
      <BR>
      arraylengに０を指定して呼び出すとframearray引数への代入を行わずにキーの個数のみを取得します。<BR>
      <BR>
      E3DGetCameraSWKeyframeNoRange( animno, start, end, 0, 0, &amp;keynum )<BR>
      <BR>
      framearray = (int*)malloc( sizeof(int) * keynum );<BR>
      <BR>
      E3DGetCameraSWKeyframeNoRange( animno, start, end, framearray, keynum,
      &amp;chknum );<BR>
      <BR>
      のようにして使ってください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　start<BR>
      3. [IN] int　：　end<BR>
      　　キーを調べたいフレーム番号の最初と最後の値を指定してください。<BR>
      <BR>
      4. [OUT] int*　：　framearray<BR>
      　　フレーム番号がgetnum個だけ代入されます。<BR>
      　　arraylengが０の場合は代入されません。<BR>
      <BR>
      5. [IN] int　：　arrayleng<BR>
      　　framearrayの配列長（要素数）を指定してください。<BR>
      　　０を指定するとキーの個数だけを調べます。<BR>
      <BR>
      6. [OUT] int*　：　getnumptr<BR>
      　　取得したキーフレーム番号の個数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetOrtho</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">正射影をオンにし、正射影のパラメータを設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] float　：　proj_near<BR>
      　　クリッピングの最小距離。<BR>
      　　実数。<BR>
      <BR>
      2. [IN] float　：　proj_far<BR>
      　　クリッピングの最大距離。<BR>
      　　実数。<BR>
      <BR>
      3. [IN] float　：　orthosize<BR>
      　　正射影のビューの大きさ。<BR>
      　　実数。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadGPFile</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">RokDeBone2で作成したGPAファイル（*.gpa）を読み込み<BR>アニメ番号を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] char*　：　filename<BR>
      　　GPAファイルのファイル名をフルパスで指定してください。<BR>
      <BR>
      3. [OUT] int*　：　animnoptr<BR>　　読み込んだアニメを識別するアニメ番号が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyGPAnim</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPAを破棄します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSaveGPFile</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメをテキストファイルに保存します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] char*　：　filename<BR>
      　　GPAファイルのファイル名をフルパスで指定してください。<BR>
      <BR>
      3. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetGPAnimNo</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">カレントのGPアニメ番号をセットします。<BR>フレーム番号は０に戻ります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetGPAnimNo</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">カレントのGPアニメ番号を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [OUT] int*　：　animnoptr<BR>
      　　GPアニメを識別する番号が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetGPFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">再生するGPアニメのアニメ番号とフレーム番号を設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>3. 
[IN] int　：　frameno<BR>　　フレーム番号を指定してください。<BR>
      <BR>4. [IN] 
int　：　isfirst<BR>
      　　この命令を呼んだ後にE3DSetNewGPを呼び出す場合は１を、呼び出さない場合は０を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetGPFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">現在再生中のGPアニメのアニメ番号、フレーム番号を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [OUT] int*　：　animnoptr<BR>
      　　GPアニメを識別する番号が代入されます。<BR>
      <BR>3. [OUT] 
int*　：　framenoptr<BR>　　フレーム番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetNewGP</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">アニメのフレームをアニメタイプに従って進め、新しいGP情報をセットします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetNextGPAnimFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">animnoで識別されるアニメがbefframenoのフレーム番号に達したらnextanimnoで識別されるアニメのnextframenoに切り替えることを予約します。<BR>
      アニメの切り替えはE3DSetNewGPで行われます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　nextanimno<BR>
      　　切り替え先のGPアニメを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　nextframeno<BR>
      　　切り替え先のGPアニメのフレーム番号を指定してください。<BR>
      <BR>
      5. [IN] int　：　befframeno<BR>
      　　切り替え前のGPアニメがbefframenoフレームまで達したらアニメの切り替えが起こります。<BR>　　-1を指定した場合は切り替え前のアニメが最終フレームに達したときにアニメが切り替わります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetNextGPAnimFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">E3DSetNextGPAnimFrameNoで設定した情報を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　nextanimnoptr<BR>
      　　切り替え先のGPアニメを識別する番号が代入されます。<BR>
      <BR>
      4. [OUT] int*　：　nextframenoptr<BR>
      　　切り替え先のGPアニメのフレーム番号が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateNewGPAnim</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメを作成しアニメを識別する番号を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] char*　：　animname<BR>　　アニメの名前を指定します。<BR>　　２５５バイトまでです。<BR>
      <BR>
      3. [IN] int　：　animtype<BR>　　アニメの振る舞いを指定します。<BR>　　１を指定するとフレーム番号は進みません。<BR>　　２を指定すると最終フレーム番号に達したらその状態を維持します。<BR>　　３を指定するとループします。<BR>　　４を指定するとピンポン再生します。<BR>　　５を指定すると最終フレームに達した後RokDeBone2で指定したフレームにジャンプします。<BR>
      <BR>
      4. [IN] int　：　framenum<BR>
      　　GPアニメをのフレーム数を指定します。<BR>
      <BR>
      5. [OUT] int*　：　animnoptr<BR>　　作成したアニメを識別する番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetGPFrameNum</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメのフレーム長を設定します。<BR>現在のフレーム長よりも小さい値を指定した場合は<BR>範囲からはみ出たキーは削除されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　framenum<BR>　　フレーム長を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetGPFrameNum</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメのフレーム長を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　framenumptr<BR>　　フレーム長が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetGPAnimName</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメの名前を設定します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] char*　：　srcname<BR>
      　　GPアニメの名前を指定します。<BR>　　２５５バイトまでです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetGPAnimName</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメの名前を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] char*　：　dstname<BR>　　名前を格納する文字列の変数を指定します。<BR>
      <BR>
      4. [IN] int　：　arrayleng<BR>　　dstnameの配列長を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetGPAnimType</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメのタイプを設定します。<BR>
      タイプの詳細はE3DCreateNewGPAnimのanimtype引数の説明をご覧ください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　type<BR>　　タイプを指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetGPAnimType</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメのタイプを取得します。<BR>
      タイプの詳細はE3DCreateNewGPAnimのanimtype引数の説明をご覧ください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　typeptr<BR>　　タイプが代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetGPKey</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメのキーを設定します。<BR>指定したフレーム番号にキーが存在しない場合は自動的に作成してから設定します。<BR>
      <BR>
      E3DGPSTATEはusercoef.hで定義されています。<BR>
      <BR>
      以下E3DGPSTATE構造体のメンバの説明。<BR>
      posは<BR>
      キャラクターの位置座標です。<BR>
      rotは<BR>
      キャラクターの回転角度です。<BR>
      Z,X,Yの順番に回転します。<BR>
      ongmodeは<BR>
      接地モードです。GROUND_NONEを指定したときは接地なし。GROUND_ONEを指定したときはキーの瞬間だけ接地。GROUND_ONを指定した場合は次のキーまでの間接地します。<BR>
      GROUND_で始まる定数はusercoef.hで定義されています。<BR>
      rayyは<BR>
      接地用のレイの始点のY座標です。<BR>
      raylengは<BR>
      接地用のレイの長さです。<BR>
      offsetyは<BR>
      接地用の地面からの高さです。<BR>
      interpは<BR>
      キー間の補間方法へのインデックスです。<BR>０を指定すると線形、１を指定するとスプライン補間になります。<BR>
      <BR>
      <BR>
      E3DSetGPKeyを呼び出しても再生用のデータには反映されません。再生用のデータに反映したい場合はE3DCalcGPFullFrameを呼び出してください。<BR>
      E3DCalcGPFullFrameは重い処理ですので全てのE3DSetGPKeyが終わってから最後に１度だけ呼び出すようにすると良いです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
int　：　frameno<BR>　　フレーム番号を指定してください。<BR>
      <BR>
      4. [IN] E3DGPSTATE　：　gpstate<BR>
      　　GPキーのメンバをセットします。<BR>　　詳しくは前記をご覧ください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetGPKey</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメのキーの情報を取得します。<BR>指定したフレーム番号にキーが無い場合は補間計算して情報を取得します。<BR>
      <BR>
      E3DGPSTATEについてはE3DSetGPKeyの説明をご覧ください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
int　：　frameno<BR>　　フレーム番号を指定してください。<BR>
      <BR>
      4. [OUT] E3DGPSTATE*　：　gsptr<BR>
      　　GPキーのメンバが代入されます。<BR>
      <BR>5. [OUT] 
int*　：　exsitflag<BR>　　指定したフレーム番号にキーがあった場合は１が<BR>　　無かった場合には０が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDeleteGPKey</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメのキーを削除します。<BR>
      <BR>
      E3DDeleteGPKeyを呼び出しても再生用のデータには反映されません。再生用のデータに反映したい場合はE3DCalcGPFullFrameを呼び出してください。<BR>
      E3DCalcGPFullFrameは重い処理ですので全てのE3DDeleteGPKeyが終わってから最後に１度だけ呼び出すようにすると良いです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
int　：　frameno<BR>　　フレーム番号を指定してください。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetGPKeyframeNoRange</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">startとendで指定したフレーム範囲のキーフレームの個数とフレーム番号を取得します。<BR>
      <BR>arraylengに０を指定して呼び出すとframearray引数への代入を行わずにキーの個数のみを取得します。<BR>
      <BR>
      E3DGetGPKeyframeNoRange( animno, start, end, 0, 0, &amp;keynum );<BR>
      <BR>framearray = 
(int*)malloc( sizeof( int ) * keynum );<BR>
      <BR>
      E3DGetGPKeyframeNoRange( animno, start, end, framearray, keynum, &amp;chknum
      );<BR>
      <BR>のようにして使ってください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] int　：　start<BR>4. [IN] 
int　：　end<BR>　　キーを調べたいフレーム番号の最初と最後の値を指定してください。<BR>
      <BR>5. [OUT] 
int*　：　framearray<BR>　　フレーム番号がgetnum個だけ代入されます。<BR>　　arraylengが０の場合は代入されません。<BR>
      <BR>6. 
[IN] 
int　：　arrayleng<BR>　　framearrayの配列長（要素数）を指定してください。<BR>　　０を指定するとキーの個数だけを調べます。<BR>
      <BR>7. 
[OUT] int*　：　getnumptr<BR>　　取得したキーフレーム番号の個数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCalcGPFullFrame</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメのキー情報から全てのフレームの姿勢情報を計算します。<BR>
      この結果はGPアニメの再生やE3DGetGPKeyなどに使われます。<BR>
      <BR>
      重い処理ですのでなるべく呼び出し回数は少なくしてください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetGPGroundHSID</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメの接地用の地面のHSIDを指定します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　ghsid<BR>
      　　接地用の地面のモデルデータを識別するID。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetGPGroundHSID</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメの接地用の地面のHSIDを取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　GPアニメを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　ghsidptr<BR>
      　　接地用の地面のモデルデータを識別するIDが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.2.9</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadMOEFile</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">RokDeBone2で作成したMOEファイル（*.moe）を読み込み<BR>アニメ番号を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
char*　：　filename<BR>
      　　MOEファイルのファイル名をフルパスで指定してください。<BR>
      <BR>3. [OUT] 
int*　：　animnoptr<BR>　　読み込んだアニメを識別するアニメ番号が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyMOEAnim</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメを破棄します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSaveMOEFile</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメをテキストファイルに保存します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
char*　：　filename<BR>
      　　MOEファイルのファイル名をフルパスで指定してください。<BR>
      <BR>3. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMOEAnimNo</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">カレントのMOEアニメ番号をセットします。<BR>フレーム番号は０に戻ります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOEAnimNo</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">カレントのGPアニメ番号を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [OUT] 
int*　：　animnoptr<BR>
      　　MOEアニメを識別する番号が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMOEFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">再生するMOEアニメのアニメ番号とフレーム番号を設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
int　：　frameno<BR>　　フレーム番号を指定してください。<BR>
      <BR>4. [IN] 
int　：　isfirst<BR>
      　　この命令を呼んだ後にE3DSetNewMOEを呼び出す場合は１を、呼び出さない場合は０を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOEFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">現在再生中のMOEアニメのアニメ番号、フレーム番号を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [OUT] 
int*　：　animnoptr<BR>
      　　MOEアニメを識別する番号が代入されます。<BR>
      <BR>3. [OUT] 
int*　：　framenoptr<BR>　　フレーム番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetNewMOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">アニメのフレームをアニメタイプに従って進め、新しいMOE情報をセットします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetNextMOEAnimFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">animnoで識別されるアニメがbefframenoのフレーム番号に達したらnextanimnoで識別されるアニメのnextframenoに切り替えることを予約します。<BR>
      アニメの切り替えはE3DSetNewMOEで行われます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
int　：　nextanimno<BR>
      　　切り替え先のMOEアニメを識別する番号を指定してください。<BR>
      <BR>4. [IN] 
int　：　nextframeno<BR>
      　　切り替え先のMOEアニメのフレーム番号を指定してください。<BR>
      <BR>5. [IN] 
int　：　befframeno<BR>
      　　切り替え前のMOEアニメがbefframenoフレームまで達したらアニメの切り替えが起こります。<BR>　　-1を指定した場合は切り替え前のアニメが最終フレームに達したときにアニメが切り替わります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetNextMOEAnimFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">E3DSetNextMOEAnimFrameNoで設定した情報を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [OUT] 
int*　：　nextanimnoptr<BR>
      　　切り替え先のMOEアニメを識別する番号が代入されます。<BR>
      <BR>4. [OUT] 
int*　：　nextframenoptr<BR>
      　　切り替え先のMOEアニメのフレーム番号が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateNewMOEAnim</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメを作成しアニメを識別する番号を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
char*　：　animname<BR>　　アニメの名前を指定します。<BR>　　２５５バイトまでです。<BR>
      <BR>3. [IN] 
int　：　animtype<BR>　　アニメの振る舞いを指定します。<BR>　　１を指定するとフレーム番号は進みません。<BR>　　２を指定すると最終フレーム番号に達したらその状態を維持します。<BR>　　３を指定するとループします。<BR>　　４を指定するとピンポン再生します。<BR>　　５を指定すると最終フレームに達した後RokDeBone2で指定したフレームにジャンプします。<BR>
      <BR>4. 
[IN] int　：　framenum<BR>
      　　MOEアニメをのフレーム数を指定します。<BR>
      <BR>5. [OUT] 
int*　：　animnoptr<BR>　　作成したアニメを識別する番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMOEFrameNum</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメのフレーム長を設定します。<BR>現在のフレーム長よりも小さい値を指定した場合は<BR>範囲からはみ出たキーは削除されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
int　：　framenum<BR>　　フレーム長を指定してください。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOEFrameNum</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメのフレーム長を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [OUT] 
int*　：　framenumptr<BR>　　フレーム長が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMOEAnimName</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメの名前を設定します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
char*　：　srcname<BR>
      　　MOEアニメの名前を指定します。<BR>　　２５５バイトまでです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOEAnimName</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメの名前を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [OUT] 
char*　：　dstname<BR>　　名前を格納する文字列の変数を指定します。<BR>
      <BR>4. [IN] 
int　：　arrayleng<BR>　　dstnameの配列長を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMOEAnimType</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメのタイプを設定します。<BR>
      タイプの詳細はE3DCreateNewMOEAnimのanimtype引数の説明をご覧ください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>　　GPアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
int　：　type<BR>　　タイプを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOEAnimType</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメのタイプを取得します。<BR>
      タイプの詳細はE3DCreateNewMOEAnimのanimtype引数の説明をご覧ください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>　　GPアニメを識別する番号を指定してください。<BR>
      <BR>3. [OUT] 
int*　：　typeptr<BR>　　タイプが代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOEKeyframeNoRange</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">startとendで指定したフレーム範囲のキーフレームの個数とフレーム番号を取得します。<BR>
      <BR>arraylengに０を指定して呼び出すとframearray引数への代入を行わずにキーの個数のみを取得します。<BR>
      <BR>
      E3DGetMOEKeyframeNoRange( animno, start, end, 0, 0, &amp;keynum );<BR>
      <BR>framearray = (int*)malloc( 
sizeof( int ) * keynum );<BR>
      <BR>
      E3DGetMOEKeyframeNoRange( animno, start, end, framearray, keynum, &amp;chknum
      );<BR>
      <BR>のようにして使ってください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] int　：　start<BR>4. [IN] 
int　：　end<BR>　　キーを調べたいフレーム番号の最初と最後の値を指定してください。<BR>
      <BR>5. [OUT] 
int*　：　framearray<BR>　　フレーム番号がgetnum個だけ代入されます。<BR>　　arraylengが０の場合は代入されません。<BR>
      <BR>6. 
[IN] 
int　：　arrayleng<BR>　　framearrayの配列長（要素数）を指定してください。<BR>　　０を指定するとキーの個数だけを調べます。<BR>
      <BR>7. 
[OUT] int*　：　getnumptr<BR>　　取得したキーフレーム番号の個数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOEElemNum</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメのキーに含まれるMOEELEMの数を取得します。<BR>
      MOEELEMはusercoef.hで定義されています。<BR>
      キーにはMOEELEM複数のMOEELEMとアイドリングモーションが含まれています。<BR>
      MOEELEMが０個でアイドリングモーションだけのキーも存在するので注意してください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      4. [OUT] int*　：　moeenumptr<BR>
      　　キーに含まれるMOEELEMの数が代入されます。<BR>
      <BR>
      5. [OUT] int*　：　existkeyptr<BR>
      　　指定したフレームにキーが存在するときは１、しないときは０が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOEElem</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">キーに含まれるMOEELEMの情報を取得します。<BR>
      MOEELEMはusercoef.hで定義されています。<BR>
      moeeindexにはE3DGetMOEElemNumで取得したMOEELEMの個数をmoeenumとすると、<BR>
      ０から(moeenum - 1)までの数を指定してください。<BR>
      MOELEMの構成要素の説明については<BR>
      RokDeBone2のマニュアルの「moaイベントアニメとは」のページをご覧ください。</TD>
      <TD class="hpb-cnt-tb-cell2"><BR>
      1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　moeeindex<BR>
      　　0からmoeenum - 1までの数を指定してください。<BR>
      <BR>
      5. [OUT] MOEELEM*　：　moeeptr<BR>
      　　MOEELEMの情報が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DAddMOEElem</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメのキーにMOEELEMを追加します。<BR>
      指定したフレームにキーが無い場合はキーを自動的にキーを作成した後にMOEELEMを追加します。<BR>
      <BR>
      MOEELEMのlistの最初の要素list[0]にのみ負の値-1を指定することが出来ます。<BR>
      -1は「全てのボーン」を意味します。<BR>
      <BR>      この命令を呼び出しても再生用のデータには反映されません。再生用のデータに反映したい場合はE3DCalcMOEFullFrameを呼び出してください。<BR>
      E3DCalcMOEFullFrameは重い処理ですので全ての編集命令が終わってから最後に１度だけ呼び出すようにすると良いです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      4. [IN] MOEELEM　：　moee<BR>
      　　MOEELEMのを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDeleteMOEElem</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメのキーからMOEELEMを削除します。<BR>
      moeeindexに-1を指定するとキー中の全てのMOEELEMを削除します。<BR>
      MOEELEMが０個になってもキーは削除されません。<BR>
      <BR>
      <BR>
      この命令を呼び出しても再生用のデータには反映されません。再生用のデータに反映したい場合はE3DCalcMOEFullFrameを呼び出してください。<BR>
      E3DCalcMOEFullFrameは重い処理ですので全ての編集命令が終わってから最後に１度だけ呼び出すようにすると良いです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　moeeindex<BR>
      　　通常0からmoeenum - 1までの数を指定してください。-1を指定すると全てのMOEELEMを削除します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMOEKeyIdling</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメのキーのアイドリングモーション情報を設定します。<BR>
      <BR>      この命令を呼び出しても再生用のデータには反映されません。再生用のデータに反映したい場合はE3DCalcMOEFullFrameを呼び出してください。<BR>
      E3DCalcMOEFullFrameは重い処理ですので全ての編集命令が終わってから最後に１度だけ呼び出すようにすると良いです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　motid<BR>
      　　アイドリングモーションのIDを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOEKeyIdling</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメのキーのアイドリングモーション情報を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      4. [IN] int*　：　motidptr<BR>
      　　アイドリングモーションのIDが代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDeleteMOEKey</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメのキーを削除します。<BR>
      <BR>
      E3DDeleteMOEKeyを呼び出しても再生用のデータには反映されません。再生用のデータに反映したい場合はE3DCalcMOEFullFrameを呼び出してください。<BR>
      E3DCalcMOEFullFrameは重い処理ですので全てのE3DDeleteMOEKeyが終わってから最後に１度だけ呼び出すようにすると良いです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>2. [IN] 
int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      <BR>3. [IN] 
int　：　frameno<BR>　　フレーム番号を指定してください。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCalcMOEFullFrame</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEアニメのキー情報から全てのフレームの姿勢情報を計算します。<BR>
      この結果はMOEアニメの再生に使われます。<BR>
      <BR>重い処理ですのでなるべく呼び出し回数は少なくしてください。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　MOEアニメを識別する番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateAndSaveTempMaterial</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">現在表示している頂点マテリアルの情報を一時メモリに退避します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRestoreAndDestroyTempMaterial</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateAndSaveTempMaterialで退避した頂点マテリアルを現在の頂点マテリアルに適用し、退避していたメモリを削除します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>　　形状データを識別するＩＤ<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMaterialFromInfElem</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">頂点マテリアルの色を影響度の計算方法情報の種類に応じて設定します。<BR>
      infcolarrayを省略したときはRokDeBone2の「影３」での頂点ペイント時の配色と同じです。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　jointno<BR>
      　　ここで指定したジョイントの影響度の色がセットされます。<BR>
      　　-1を指定すると対称ペイントの部分のみの色が表示されます。<BR>
      <BR>
      3. [IN] int　：　partno<BR>
      　　パーツを識別するID。<BR>
      　　-1を指定すると全てのパーツにセットします。<BR>
      <BR>
      4. [IN] int　：　vertno<BR>
      　　頂点の番号。<BR>
      　　-1を指定すると全ての頂点に設定します。<BR>
      <BR>
      5. [IN] E3DCOLOR3UC*　：　infcolarray<BR>
      　　影響度の各計算モードの色を指定します。<BR>
      　　E3DCOLOR3UC infcolarray[ CALCMODE_MAX ];で確保した配列を指定してください。<BR>
      　　CALCMODE_で始まる定数はusercoef.hで定義されています。<BR>
      　　各モードの説明はE3DGetInfElemの説明をご覧ください。<BR>
      　　この引数を省略した場合はRokDeBone2と同じ色になります。<BR>
      　　この引数を指定した場合はモデルを読み込んでいる間だけ配色情報が保存されます。<BR>
      （sigには保存されません。）<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.2.3.3<BR>
      ver5.2.3.4で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DUpdateSound</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">音の更新処理をします。<BR>
      同じ音の多重再生のための情報更新や３Dサウンドパラメータの反映などが主な動作です。<BR>
      <BR>
      毎フレーム呼び出してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">なし</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.0.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSoundSamplesPlayed</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">音の現在の再生位置を取得します。<BR>
      サンプル（周波数）単位の値です。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　音データを識別するＩＤ<BR>
      <BR>
      2. [OUT] double*　：　smpptr<BR>
      　　再生位置が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.0.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetSoundFrequency</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">音の周波数を設定します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　設定したい音を識別する番号<BR>
      　　-1を指定すると読み込み済みの全てのサウンドに対して処理します。<BR>
      <BR>
      2. [IN] float　：　freq<BR>
      　　ソース周波数との比率を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.0.1<BR>
      ver5.3.4.1で拡張<BR>
      </TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSoundFrequency</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">現在の周波数を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　音を識別する番号<BR>
      <BR>
      2. [OUT] float*　：　freqptr<BR>
      　　ソース周波数との比率が代入されます。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.0.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSet3DSoundEmiDist</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">３Dサウンドの音の届く距離を指定します。<BR>
      E3DUpdateSoundで適用されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　音データを識別するＩＤ<BR>
      <BR>
      2. [IN] float　：　dist<BR>
      　　音の届く最大距離。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.0.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DFadeSound</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">フェード処理をします。<BR>
      E3DPlaySoundよりも後で呼びます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　音データを識別するＩＤ<BR>
      <BR>
      2. [IN] int　：　msc<BR>
      3. [IN] float　：　startgain<BR>
      4. [IN] float　：　endgain<BR>
      　　mscミリセカンドの間に音のゲインをstartgainからendgainに変化させます。<BR>
      　　gainは実数。１．０が等倍。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.0.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGlobalToLocalParBone</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">グローバル座標系の座標値とクォータニオンを<BR>
      指定したボーンの親のボーンのローカル座標系に変換します。<BR>
      <BR>
      つまり親の影響を除いた値を取得できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      5. [IN] int　：　flag<BR>
      　　フラグに１をセットするとクォータニオンのみを変換します。２をセットすると座標値のみを変換します。３をセットするとクォータニオンと座標値の両方を変換します。<BR>
      <BR>
      6. [IN] int　：　srcqid<BR>
      　　変換前の情報が入っているクォータニオンのID。<BR>
      <BR>
      7. [IN, OUT] int　：　dstqid<BR>
      　　変換後のクォータニオン情報を格納するクォータニオンのID。<BR>
      　　E3DCreateQで作成したクォータニオンのIDを指定してください。<BR>
      <BR>
      8. [IN] D3DXVECTOR3*　：　srcvecptr<BR>
      　　変換前の座標値を指定します。<BR>
      <BR>
      9. [OUT] D3DXVECTOR3*　：　dstvecptr<BR>
      　　変換後の座標値が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.0.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLocalToGlobalParBone</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">ローカル座標系の座標値とクォータニオンを<BR>
      指定したボーンの親のボーンの影響を考慮したグローバル座標系に変換します。<BR>
      <BR>
      E3DGlobalToLocalParBoneの逆変換です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      5. [IN] int　：　flag<BR>
      　　フラグに１をセットするとクォータニオンのみを変換します。２をセットすると座標値のみを変換します。３をセットするとクォータニオンと座標値の両方を変換します。<BR>
      <BR>
      6. [IN] int　：　srcqid<BR>
      　　変換前の情報が入っているクォータニオンのID。<BR>
      <BR>
      7. [IN, OUT] int　：　dstqid<BR>
      　　変換後のクォータニオン情報を格納するクォータニオンのID。<BR>
      <BR>
      　　E3DCreateQで作成したクォータニオンのIDを指定してください。<BR>
      <BR>
      <BR>
      8. [IN] D3DXVECTOR3*　：　srcvecptr<BR>
      　　変換前の座標値を指定します。<BR>
      <BR>
      9. [OUT] D3DXVECTOR3*　：　dstvecptr<BR>
      　　変換後の座標値が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.0.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetInfElemSymParams</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響</TD>
      <TD class="hpb-cnt-tb-cell2">CALCMODE_SYMで頂点ペイントした頂点の対称軸と対称距離を取得します。<BR>
      <BR>
      対称軸はusercoef.hで定義されている<BR>
      SYMAXIS_ で始まる定数を使います。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　頂点の番号を指定してください。<BR>
      <BR>
      4. [OUT] int*　：　symaxisptr<BR>
      　　対称軸が代入されます。<BR>
      　　usercoef.hで定義されている<BR>
      　　SYMAXIS_*を参照してください。<BR>
      <BR>
      5. [OUT] float*　：　distptr<BR>
      　　対称距離が代入されます。<BR>
      　　対称距離とは、完全な対称な位置からどれくらいの距離にあるものを対称とみなすかを決める値です。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyMotion</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">モーションを１つだけ削除します。<BR>
      モーションを削除すると読み込み済みの全てのモーションのIDが変化します。<BR>
      それを取得するためにIDCHANGE構造体を使います。<BR>
      IDCHANGEはusercoef.hで定義されています。<BR>
      befidに削除前のIDを代入しておいてください。<BR>
      newidに削除後の新しいIDが代入されます。<BR>
      読み込み済みの全てのモーション分IDCHANGEの配列を作成してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　削除するモーションのID。<BR>
      <BR>
      3. [IN, OUT] IDCHANGE*　：　idchgptr<BR>
      　　削除後の新しいIDを受け取る構造体の配列へのポインタ。<BR>
      　　befidにはあらかじめ値をセットしてください。<BR>
      <BR>
      4. [IN] int　：　idnum<BR>
      　　IDCHANGE引数に渡した配列の要素数。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetIKTargetPos</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">IKターゲットの位置を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　bone<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] D3DXVECTOR3*　：　posptr<BR>
      　　位置が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetIKTargetState</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">IKターゲットの状態を取得します。<BR>
      ０のときは削除されている状態。<BR>
      １のときは有効になっている状態。<BR>
      ２のときは作成されてはいるが無効になっている状態。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　bone<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　stateptr<BR>
      　　状態が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetIKTargetCnt</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">IKターゲットの計算回数を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　bone<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　cntptr<BR>
      　　回数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetIKTargetLevel</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">IKターゲットの階層数を取得します。<BR>
      階層数分親までさかのぼってIK計算されます。<BR>
      ただし途中でIK伝達禁止フラグがあった場合は<BR>
      IK計算はそこでストップします。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　bone<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　levelptr<BR>
      　　階層数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetIKLevel</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">通常のIK計算時の計算階層数を取得します。<BR>
      階層数分親までさかのぼってIK計算されます。<BR>
      ただし途中でIK伝達禁止フラグがあった場合は<BR>
      IK計算はそこでストップします。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　bone<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　levelptr<BR>
      　　階層数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetIKTargetPos</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">IKターゲットの位置をセットします。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　bone<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] D3DXVECTOR3　：　srcpos<BR>
      　　位置を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetIKTargetState</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">IKターゲットの状態をセットします。<BR>
      ０のときは削除されている状態。<BR>
      １のときは有効になっている状態。<BR>
      ２のときは作成されてはいるが無効になっている状態。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　bone<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　srcstate<BR>
      　　状態を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetIKTargetCnt</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">IKターゲットの計算回数をセットします。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　bone<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　srccnt<BR>
      　　回数を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetIKTargetLevel</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">IKターゲットの階層数をセットします。<BR>
      階層数分親までさかのぼってIK計算されます。<BR>
      ただし途中でIK伝達禁止フラグがあった場合は<BR>
      IK計算はそこでストップします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　bone<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　srclevel<BR>
      　　階層数を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetIKLevel</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">通常のIK計算時の計算階層数をセットします。<BR>
      階層数分親までさかのぼってIK計算されます。<BR>
      ただし途中でIK伝達禁止フラグがあった場合は<BR>
      IK計算はそこでストップします。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　bone<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　srclevel<BR>
      　　階層数を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetQVal</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンの値を取得します。<BR>
      E3DQ構造体はusercoef.hで定義されています。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するIDを指定してください。<BR>
      <BR>
      2. [OUT] E3DQ*　：　qptr<BR>
      　　クォータニオンの値が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetQVal</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンの値をセットします。<BR>
      E3DQ構造体はusercoef.hで定義されています。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　qid<BR>
      　　クォータニオンを識別するIDを指定してください。<BR>
      <BR>
      2. [IN] E3DQ　：　srcq<BR>
      　　クォータニオンの値を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DMultQArray</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">クォータニオンの掛け算をします。<BR>
      qnum個のクォータニオンをqidarrayで指定した先頭のクォータニオンから順番に掛け算します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int*　：　qidarray<BR>
      　　クォータニオンを識別するIDの配列を指定してください。<BR>
      　<BR>
      2. [IN] int　：　qnum<BR>
      　　qidarrayで指定した配列の要素数を指定します。<BR>
      <BR>
      3. [IN, OUT] int　：　resultqid<BR>
      　　結果を格納するクォータニオンのIDを指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DEulerZXY2Q</TD>
      <TD class="hpb-cnt-tb-cell2">算術</TD>
      <TD class="hpb-cnt-tb-cell2">オイラー回転角度をクォータニオンに変換します。<BR>
      回転の順番はZ、X、Yです。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN, OUT] int　：　qid<BR>
      　　結果を格納するクォータニオンのIDを指定してください。<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　srceul<BR>
      　　オイラー角度を指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetEulerLimit</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">IKの制限角度情報を取得します。<BR>
      EULERLIMIT構造体はusercoef.hで定義されています。<BR>
      ignoreflagは１のとき制限角度を無視します。<BR>
      lim0とlim1は制限角度の両端のオイラー角を示します。<BR>
      回転の順序はZ,X,Yです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　bone<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] EULERLIMIT*　：　elptr<BR>
      　　制限角度情報が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetEulerLimit</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">IKの制限角度情報をセットします。<BR>
      EULERLIMIT構造体はusercoef.hで定義されています。<BR>
      ignoreflagは１のとき制限角度を無視します。<BR>
      lim0とlim1は制限角度の両端のオイラー角を示します。<BR>
      回転の順序はZ,X,Yです。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　bone<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] EULERLIMIT　：　srcel<BR>
      　　制限角度情報を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCalcEuler</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">指定モーションの全てのボーンの全てのモーションポイントのオイラー角を計算します。<BR>
      <BR>
      zakindには座標系を指定します。<BR>
      usercoef.hで定義されているZA_*を使ってください。<BR>
      RokDeBone2の「座１」から「座４」に対応しています。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　zakind<BR>
      　　座標系を指定します。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBoneEuler</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンごとにモーションポイントのオイラー角度を取得します。<BR>
      モーションポイントが存在しないときは補間計算してオイラー角を求めます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定してください。<BR>
      <BR>
      5. [OUT] D3DXVECTOR3*　：　eulptr<BR>
      　　オイラー角が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetZa4Elem</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">RokDeBone2の「座４」のパラメータを取得します。<BR>
      ZA4ELEM構造体はusercoef.hで定義されています。<BR>
      zatypeにはZA_*を指定します。<BR>
      rotaxisにはROTAXIS_*を指定します。<BR>
      za4qには追加の姿勢情報を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] ZA4ELEM*　：　z4eptr<BR>
      　　座４パラメータが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetZa4Elem</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">RokDeBone2の「座４」のパラメータをセットします。<BR>
      ZA4ELEM構造体はusercoef.hで定義されています。<BR>
      zatypeにはZA_*を指定します。<BR>
      rotaxisにはROTAXIS_*を指定します。<BR>
      za4qには追加の姿勢情報を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] ZA4ELEM　：　srcz4e<BR>
      　　座４パラメータを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCalcZa4LocalQ</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">座４での姿勢を表すクォータニオンを計算します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetZa4LocalQ</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCalcZaLocalQでの計算結果をボーンごとに取得します。<BR>
      E3DQ構造体はusercoef.hで定義されています。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] E3DQ*　：　dstq<BR>
      　　クォータニオンが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetZa3IniQ</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">座３の初期状態の座標系を表すクォータニオンを取得します。<BR>
      E3DQ構造体はusercoef.hで定義されています。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] E3DQ*　：　dstq<BR>
      　　クォータニオンが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBoneAxisQ</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンの座標系を表すクォータニオンを計算します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定してください。<BR>
      <BR>
      5. [IN] int　：　zakind<BR>
      　　座標系を指定します。<BR>
      　　usercoef.hで定義されているZA_*を使います。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBoneAxisQ</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">E3DSetBoneAxisQで計算した結果を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] E3DQ*　：　dstq<BR>
      　　クォータニオンが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBoneTra</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンの移動成分を取得します。<BR>
      モーションポイントが存在しない場合は補間計算して情報を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      5. [OUT] D3DXVECTOR3*　：　vecptr<BR>
      　　移動成分が代入されます。<BR>
      <BR>
      6. [OUT] int*　：　existptr<BR>
      　　指定したフレームにモーションポイントが存在する場合は１が、しない場合は０が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.4</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBoneScale</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンの拡大縮小成分を取得します。<BR>
      モーションポイントが存在しない場合は補間計算して情報を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      5. [OUT] D3DXVECTOR3*　：　vecptr<BR>
      　　拡大縮小成分が代入されます。<BR>
      <BR>
      6. [OUT] int*　：　existptr<BR>
      　　指定したフレームにモーションポイントが存在する場合は１が、しない場合は０が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.4</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBoneTra</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンの移動成分を設定します。<BR>
      モーションポイントが存在しない場合はエラーになります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      5. [IN] D3DXVECTOR3　：　srcvec<BR>
      　　移動成分を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.4</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetBoneScale</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンの拡大縮小成分を取得します。<BR>
      モーションポイントが存在しない場合はエラーになります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      5. [IN] D3DXVECTOR3　：　srcvec<BR>
      　　拡大縮小成分を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.4</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetBoneMatrix</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンの変換行列を取得します。<BR>
      モーションポイントが存在しなくても取得できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      <BR>
      5. [IN] int　：　kind<BR>
      　　親の変換行列を掛けた行列を取得したい場合は１を、親の影響を受けていない行列を取得したい場合は０を指定します。<BR>
      <BR>
      6. [OUT] D3DXMATRIX*　：　matptr<BR>
      　　変換行列が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.4</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateMotionPoint</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">モーションポイントを作成します。<BR>
      前後のモーションポイントを調べて補間計算したモーション情報をセットします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　フレーム番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.4</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DTransform</TD>
      <TD class="hpb-cnt-tb-cell2">描画準備</TD>
      <TD class="hpb-cnt-tb-cell2">表示オブジェクトとボーンに表示用の変換マトリックスをセットします。<BR>
      <BR>
      この命令はE3DRenderの内部で呼ばれますので通常は必要ありません。<BR>
      <BR>
      変換マトリックスセットと表示処理とを分けたいときに使ってください。<BR>
      <BR>
      この命令を呼んだときはE3DRenderのtransskip引数に１をセットしてE3DRenderでのマトリックスセットをスキップすることを想定しています。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneonly<BR>
      　　ボーンのマトリックスのみをセットしたいときに１を設定します。<BR>
      　　全てのマトリックスをセットしたいときは０を設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetIKSkip</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンのIKスキップのフラグを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　flagptr<BR>
      　　IKスキップフラグが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetIKSkip</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンのIKスキップのフラグを設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　flag<BR>
      　　IKスキップフラグを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.1.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialTexParams</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">面マテリアルのテクスチャに関するパラメータを取得します。<BR>
      <BR>
      パラメータの取得にはMATERIALTEXというusercoef.hで定義されている構造体を使います。<BR>
      <BR>
      以下、MATERIALTEXのメンバーの説明。<BR>
      <BR>
      texは１枚目のテクスチャのファイル名です。<BR>
      テクスチャが無い場合はtex[0]が0です。<BR>
      <BR>
      bumpはバンプマップテクスチャ名です。<BR>
      バンプを使わないときはbump[0]が０です。<BR>
      バンプを使う場合はbumpだけでなくtexにもテクスチャが指定されていなければなりません。<BR>
      <BR>
      exttexnumは拡張テクスチャの枚数です。MAXEXTTEXNUM（現在は１００）枚までテクスチャを指定できます。<BR>
      <BR>
      exttexは拡張テクスチャのファイル名です。<BR>
      使わない場合は０初期化します。<BR>
      <BR>
      exttexmodeはテクスチャモードです。<BR>
      EXTTEXMODE_で始まるusercoef.hで定義されている定数を使います。<BR>
      EXTTEXMODE_NORMALはテクスチャを１枚だけ指定するモードです。<BR>
      EXTTEXMODE_ANIMはテクスチャアニメを使用するモードです。<BR>
      EXTTEXMODE_GLOWは不透明グローを使用するモードです。<BR>
      EXTTEXMODE_GLOWALPHAは半透明グローを使用するモードです。<BR>
      <BR>
      transparentは透過モードです。<BR>
      ０は不透明。１は黒透過。２はテクスチャのアルファによる半透明。<BR>
      <BR>
      uanim, vanimはUVアニメの毎フレームの移動量です。<BR>
      <BR>
      texruleはテクスチャの貼り方です。<BR>
      usercoef.hで定義されているTEXRULE_で始まる定数を使います。<BR>
      TEXRULE_X, TEXRULE_Y, TEXRULE_ZはそれぞれX,Y,Z軸投影。<BR>
      TEXRULE_CYLINDERは円筒貼り付け。<BR>
      TEXRULE_SPHEREは球貼り付け。<BR>
      TEXRULE_MQはメタセコイア(mqoファイル)のUV値による貼り付け。<BR>
      <BR>
      texanimtypeはUVアニメのタイプです。<BR>
      TEXANIM_WRAPは0から１でラップします。<BR>
      TEXANIM_NOLIMITはラップしない無制限モードです。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　materialno<BR>
      　　マテリアルを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] MATERIALTEX*　：　dstparams<BR>
      　　パラメータを受け取る構造体へのポインタを指定してください。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMaterialTexParams</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">面マテリアルのテクスチャのパラメータを設定します。<BR>
      <BR>
      パラメータの指定にはusercoef.hで定義されているMATERIALTEX構造体を使用します。<BR>
      MATERIALTEX構造体のメンバーの説明はE3DGetMaterialTexParamsの説明をお読みください。<BR>
      <BR>
      exttexmodeがEXTTEXMODE_GLOWのときはtrasparentは０に、EXTTEXMODE_GLOWALPHAのときはtranspaerntが２に強制的にセットされます。<BR>
      <BR>
      テクスチャの複数指定の際には1枚目をtexに<BR>
      2枚目以降をexttexにセットしてください。<BR>
      exttexnumはexttexだけの（texを勘定しない）枚数です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　materialno<BR>
      　　マテリアルを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] MATERIALTEX*　：　srcparams<BR>
      　　パラメータを指定する構造体へのポインタを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateTexKey</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメ</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメのキーを作成します。<BR>
      キーは複数のTEXCHANGEから構成されます。<BR>
      TEXCHANGE構造体はusercoef.hで定義されています。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　テクスチャアニメ情報を格納するボーンを識別する番号を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションのIDを指定します。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定します。<BR>
      <BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDelTexKey</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメ</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメのキーを削除します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　テクスチャアニメ情報を格納するボーンを識別する番号を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションのIDを指定します。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DAddTexChange</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメ</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメのキーにTEXCHANGEを追加します。TEXCHANGEはusercoef.hで定義されています。テクスチャ変更のトリガーです。<BR>
      TEXCHANGEのtexnameに指定するテクスチャ名は面マテリアルにすでに追加されている必要があります。面マテリアルへのテクスチャの追加はE3DSetMaterialTexParamsで行います。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　テクスチャアニメ情報を格納するボーンを識別する番号を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションのIDを指定します。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定します。<BR>
      <BR>
      5. [IN] TEXCHANGE　：　srctc<BR>
      　　テクスチャの変更情報を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDelTexChange</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメ</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメのキーからTEXCHANGEを削除します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　テクスチャアニメ情報を格納するボーンを識別する番号を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションのIDを指定します。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定します。<BR>
      <BR>
      5. [IN] int　：　materialno<BR>
      　　面マテリアルを識別する番号を指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetTexChangeNum</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメ</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメのキーの中に何個TEXCHANGEが存在するかを取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　テクスチャアニメ情報を格納するボーンを識別する番号を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションのIDを指定します。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定します。<BR>
      <BR>
      5. [OUT] int*　：　tcnumptr<BR>
      　　TEXCHANGEの数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetTexChange</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメ</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメのキーの中のTEXCHANGEを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　テクスチャアニメ情報を格納するボーンを識別する番号を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションのIDを指定します。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定します。<BR>
      <BR>
      5. [IN] int　：　tcindex<BR>
      　　TEXCHANGEのインデックスを指定します。<BR>
      　　E3DGetTexChangeNumで取得した数をtcnumとすると、この引数には０から(tcnum - 1)までの数値を指定します。<BR>
      <BR>
      6. [OUT] TEXCHANGE*　：　dsttc<BR>
      　　情報を受け取る構造体へのポインタを指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetTexAnimKeyframeNoRange</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメ</TD>
      <TD class="hpb-cnt-tb-cell2">startとendで指定したフレーム範囲のキーフレームの個数とフレーム番号を取得します。<BR>
      <BR>
      arraylengに０を指定して呼び出すとframearray引数への代入を行わずにキーの個数のみを取得します。<BR>
      <BR>
      E3DGetTexAnimKeyframeNoRange( hsid, boneno, motid, start, end, 0, 0, &amp;keynum
      );<BR>
      <BR>
      framearray = (int*)malloc( sizeof( int ) * keynum );<BR>
      <BR>
      E3DGetTexAnimKeyframeNoRange( hsid, boneno, motid, start, end, framearray,
      keynum, &amp;chknum );<BR>
      <BR>
      のようにして使ってください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>      　　テクスチャアニメ情報を格納するボーンを識別する番号を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションのIDを指定します。<BR>
      <BR>
      4. [IN] int　：　start<BR>
      5. [IN] int　：　end<BR>
      　　キーを調べたいフレーム番号の最初と最後の値を指定してください。<BR>
      <BR>
      6. [OUT] int*　：　framearray<BR>
      　　フレーム番号がgetnum個だけ代入されます。<BR>
      　　arraylengが０の場合は代入されません。<BR>
      <BR>
      7. [IN] int　：　arrayleng<BR>
      　　framearrayの配列長（要素数）を指定してください。<BR>
      　　０を指定するとキーの個数だけを調べます。<BR>
      <BR>
      8. [OUT] int*　：　getnumptr<BR>
      　　取得したキーフレーム番号の個数が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateDSKey</TD>
      <TD class="hpb-cnt-tb-cell2">ディスプレイスイッチ</TD>
      <TD class="hpb-cnt-tb-cell2">DispSwitchアニメのキーを作成します。<BR>
      キーは複数のDSCHANGEから構成されます。<BR>
      DSCHANGE構造体はusercoef.hで定義されています。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　DispSwitchアニメ情報を格納するボーンを識別する番号を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションのIDを指定します。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDelDSKey</TD>
      <TD class="hpb-cnt-tb-cell2">ディスプレイスイッチ</TD>
      <TD class="hpb-cnt-tb-cell2">DispSwitchアニメのキーを削除します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　DispSwitch情報を格納するボーンを識別する番号を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションのIDを指定します。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DAddDSChange</TD>
      <TD class="hpb-cnt-tb-cell2">ディスプレイスイッチ</TD>
      <TD class="hpb-cnt-tb-cell2">DispSwitchアニメのキーにDSCHANGEを追加します。DSCHANGEはusercoef.hで定義されています。DispSwitch変更のトリガーです。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　DispSwitch情報を格納するボーンを識別する番号を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションのIDを指定します。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定します。<BR>
      <BR>
      5. [IN] DSCHANGE　：　srcdsc<BR>
      　　DispSwitch変更情報の構造体を指定します。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDelDSChange</TD>
      <TD class="hpb-cnt-tb-cell2">ディスプレイスイッチ</TD>
      <TD class="hpb-cnt-tb-cell2">DispSwitchアニメのキーからDSCHANGEを削除します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　DispSwitch情報を格納するボーンを識別する番号を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションのIDを指定します。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定します。<BR>
      <BR>
      5. [IN] int　：　switchno<BR>
      　　DispSwitchのスイッチ番号を指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetDSChangeNum</TD>
      <TD class="hpb-cnt-tb-cell2">ディスプレイスイッチ</TD>
      <TD class="hpb-cnt-tb-cell2">DispSwitchアニメのキーの中に何個DSCHANGEが存在するかを取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　DispSwitch情報を格納するボーンを識別する番号を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションのIDを指定します。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定します。<BR>
      <BR>
      5. [OUT] int*　：　dscnumptr<BR>
      　　DSCHANGEの個数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetDSChange</TD>
      <TD class="hpb-cnt-tb-cell2">ディスプレイスイッチ</TD>
      <TD class="hpb-cnt-tb-cell2">DispSwitchアニメのキーの中のDSCHANGEを取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　DispSwitchアニメ情報を格納するボーンを識別する番号を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションのIDを指定します。<BR>
      <BR>
      4. [IN] int　：　frameno<BR>
      　　モーションのフレーム番号を指定します。<BR>
      <BR>
      5. [IN] int　：　dscindex<BR>
      　　DSCHANGEのインデックスを指定します。<BR>
      　　E3DGetDSChangeNumで取得した数をdscnumとすると、この引数には０から(dscnum - 1)までの数値を指定します。<BR>
      <BR>
      6. [OUT] DSCHANGE*　：　dstdsc<BR>
      　　情報を受け取る構造体へのポインタを指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetDSAnimKeyframeNoRange</TD>
      <TD class="hpb-cnt-tb-cell2">ディスプレイスイッチ</TD>
      <TD class="hpb-cnt-tb-cell2">startとendで指定したフレーム範囲のキーフレームの個数とフレーム番号を取得します。<BR>
      <BR>
      arraylengに０を指定して呼び出すとframearray引数への代入を行わずにキーの個数のみを取得します。<BR>
      <BR>
      E3DGetDSAnimKeyframeNoRange( hsid, boneno, motid, start, end, 0, 0, &amp;keynum
      );<BR>
      <BR>
      framearray = (int*)malloc( sizeof( int ) * keynum );<BR>
      <BR>
      E3DGetDSAnimKeyframeNoRange( hsid, boneno, motid, start, end, framearray,
      keynum, &amp;chknum );<BR>
      <BR>
      のようにして使ってください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>      　　テクスチャアニメ情報を格納するボーンを識別する番号を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションのIDを指定します。<BR>
      <BR>
      4. [IN] int　：　start<BR>
      5. [IN] int　：　end<BR>
      　　キーを調べたいフレーム番号の最初と最後の値を指定してください。<BR>
      <BR>
      6. [OUT] int*　：　framearray<BR>
      　　フレーム番号がgetnum個だけ代入されます。<BR>
      　　arraylengが０の場合は代入されません。<BR>
      <BR>
      7. [IN] int　：　arrayleng<BR>
      　　framearrayの配列長（要素数）を指定してください。<BR>
      　　０を指定するとキーの個数だけを調べます。<BR>
      <BR>
      8. [OUT] int*　：　getnumptr<BR>
      　　取得したキーフレーム番号の個数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialAlphaTest</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルのアルファテストの情報を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアル番号。<BR>
      　　E3DGetMaterialNoByNameで取得した番号、<BR>
      　　もしくは<BR>
      　　RokDeBone2の「面マテリアル」メニューで<BR>
      　　表示されている「マテリアル番号」<BR>
      <BR>
      3. [OUT] int*　：　test0ptr<BR>
      　　不透明を描画時にアルファテストする場合は１が<BR>
      　　しない場合は０が代入されます。<BR>
      <BR>
      4. [OUT] int*　：　val0ptr<BR>
      　　不透明時のアルファテストのアルファの閾値が代入されます。<BR>
      　　（０から２５５）<BR>
      <BR>
      5. [OUT] int*　：　test1ptr<BR>
      　　半透明を描画時にアルファテストする場合は１が<BR>
      　　しない場合は０が代入されます。<BR>
      <BR>
      6. [OUT] int*　：　val1ptr<BR>
      　　半透明時のアルファテストのアルファの閾値が代入されます。<BR>
      　　（０から２５５）<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialTexParams1DIM</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルのテクスチャ情報を取得します。<BR>
      MATERIALTEX構造体がMATERIALTEX1DIMになっていること以外はE3DGetMaterialTexParamsと同じです。<BR>
      E3DGetMaterialTexParamsの説明をお読みください。<BR>
      <BR>
      変更箇所はexttexが１次元になったことです。<BR>
      exttexnum個分のテクスチャ名が'\n'終端で連結されて代入されます。<BR>
      exttexの一番最後の要素の最後にも'\n'が付きます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　materialno<BR>
      　　マテリアルを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] MATERIALTEX1DIM*　：　dstparams<BR>
      　　パラメータを受け取る構造体へのポインタを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMaterialTexParams1DIM</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルのテクスチャ情報を設定します。<BR>
      MATERIALTEX構造体がMATERIALTEX1DIMになっていること以外はE3DSetMaterialTexParamsと同じです。<BR>
      E3DSetMaterialTexParamsの説明をお読みください。<BR>
      <BR>
      変更箇所はexttexが１次元になったことです。<BR>
      <BR>
      exttexには各テクスチャ名を'\n'終端で連結して指定します。<BR>
      exttexの一番最後の要素の終端にも'\n'が必要です。<BR>
      テクスチャ名は２５５バイトまでです。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　materialno<BR>
      　　マテリアルを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] MATERIALTEX1DIM*　：　srcparams<BR>
      　　パラメータを指定する構造体へのポインタを指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSet3DSoundDopplerScaler</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">ドップラー効果の係数を設定します。<BR>
      値が大きいほどドップラー効果が大きくなります。<BR>
      <BR>
      ドップラー効果は音源やリスナーの速度によって生じます。<BR>
      <BR>
      音源の速度は<BR>
      E3DSet3DSoundMovementで指定する速度です。<BR>
      <BR>
      リスナーの速度は<BR>
      E3DSet3DSoundListenerMovementで指定したキャラクターまたはカメラの現在の位置から１回前の呼び出し時の位置を引いたものとなります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　音を識別する番号を、指定します。<BR>
      　　-1を指定すると読み込み済みの全ての音に対して処理をします。<BR>
      <BR>
      2. [IN] float　：　srcdp<BR>
      　　ドップラー効果の係数を指定します。<BR>
      　　０以上の数値を指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.2</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGet3DSoundDopplerScaler</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">ドップラー効果の係数を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　音を識別する番号を、指定します。<BR>
      <BR>
      2. [OUT] float*　：　dpptr<BR>
      　　ドップラー効果の係数が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.2</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadMQOFileAsChara</TD>
      <TD class="hpb-cnt-tb-cell2">モデルデータ</TD>
      <TD class="hpb-cnt-tb-cell2">mqoファイルをキャラクターとして読み込みます。<BR>
      ツール用の命令です。<BR>
      ゲームなどではRokDeBone2でmqoを読み込みsigで保存して、E3DSigLoadで読み込んでください。<BR>
      <BR>
      sigの読み込みのほうが高速です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　読み込む、mqo ファイル名。<BR>
      <BR>
      2. [IN] float　：　mult<BR>
      　　形状データの座標に掛ける数値。<BR>
      　　座標値　＊　mult で計算されます。<BR>
      　　等倍は１．０<BR>
      <BR>
      3. [IN] int　：　adjustuvflag<BR>
      　　UV座標を正規化したいときは１を、<BR>
      　　そうでないときは、０を指定してください。<BR>
      　　２を指定すると0.0から1.0の間にクランプします。<BR>
      <BR>
      4. [IN] int　：　bonetype<BR>
      　　mqoにボーンが含まれている場合は<BR>
      　　ボーンのタイプを指定します。<BR>
      　　BONETYPE_RDB2を指定するとRokDeBone2形式の<BR>
      　　線分をボーンと認識するタイプになります。<BR>
      　　BONETYPE_MIKOを指定すると<BR>
      　　mikoto形式のタイプになります。<BR>
      　　これらの定数はusercoef.hで定義されています。<BR>
      <BR>
      5. [OUT] int*　：　hsidptr<BR>
      　　作成したキャラクターを識別するhsidが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.2</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetPartPropName</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">パーツの名前を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] char*　：　nameptr<BR>
      　　名前を取得するための配列へのポインタを指定してください。<BR>
      <BR>
      4. [IN] int　：　arrayleng<BR>
      　　nameptrの配列の長さを指定してください。<BR>
      　　名前の最大長は２５５バイトなので配列は２５６バイトあれば十分です。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetPartPropName</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">パーツの名前を設定します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] char*　：　srcname<BR>
      　　名前のセットしてある配列へのポインタ。名前は最大２５５バイトまで。&nbsp;<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetPartPropDS</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">パーツのディスプレイスイッチ番号を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　dsptr<BR>
      　　ディスプレイスイッチ番号が代入されます。<BR>
      　　ディスプレイスイッチは０から(DISPSWITCHNUM - 1)までの数値です。DISPSWITCHNUMはusercoef.hで定義されています。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetPartPropDS</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">パーツにディスプレイスイッチ番号を設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　srcds<BR>
      　　ディスプレイスイッチ番号を指定します。<BR>
      　　ディスプレイスイッチは０から(DISPSWITCHNUM - 1)までの数値です。DISPSWITCHNUMはusercoef.hで定義されています。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetPartPropNotUse</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">パーツの無効化フラグを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　flagptr<BR>
      　　notuseが代入されます。<BR>
      　　notuseが０のときパーツは有効になっています。notuseが１のときパーツは無効となります。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetPartPropNotUse</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">パーツに無効化フラグを設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　srcflag<BR>
      　　notuseを指定します。<BR>
      　　０のときパーツは有効になっています。１のときパーツは無効となります。<BR>
      　　ジョイントの有効無効を切り替えた場合はE3DJointRemakeを呼び出す必要があります。</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadSSF</TD>
      <TD class="hpb-cnt-tb-cell2">音セット</TD>
      <TD class="hpb-cnt-tb-cell2">音セットファイル*.ssfを読み込みます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　ssfファイルのパスを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyAllSoundSet</TD>
      <TD class="hpb-cnt-tb-cell2">音セット</TD>
      <TD class="hpb-cnt-tb-cell2">読み込み済みの全ての音セットを破棄します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">なし</TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSoundSetNum</TD>
      <TD class="hpb-cnt-tb-cell2">音セット</TD>
      <TD class="hpb-cnt-tb-cell2">読み込み済みの音セットの数を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　numptr<BR>
      　　音セットの数が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSoundSetInfo</TD>
      <TD class="hpb-cnt-tb-cell2">音セット</TD>
      <TD class="hpb-cnt-tb-cell2">音セットの情報を取得します。<BR>
      音セットごとに呼び出します。<BR>
      ssindexには０からE3DGetSoundSetNumで取得したnum - 1までの数値を指定します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　ssindex<BR>
      　　音セットのインデックス。<BR>
      　　音セットのIDではありません。<BR>
      <BR>
      2. [OUT] E3DSSINFO*　：　infoptr<BR>
      　　音セットの情報が代入されます。<BR>
      　　E3DSSINFOはusercoef.hで定義されています。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSoundSetBGM</TD>
      <TD class="hpb-cnt-tb-cell2">音セット</TD>
      <TD class="hpb-cnt-tb-cell2">音セットに関連付けられているBGMのサウンドIDを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　setid<BR>
      　　音セットのIDを指定します。<BR>
      　　音セットのインデックスではありません。<BR>
      <BR>
      2. [OUT] int*　：　bgmidptr<BR>
      　　BGMのサウンドIDが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadSAF</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメ</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメファイル*.safを読み込みアニメを識別するIDを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　safファイルのパスを指定します。<BR>
      <BR>
      2. [OUT] int*　：　animnoptr<BR>
      　　読み込んだアニメを識別するIDが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyAllSndAnim</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメ</TD>
      <TD class="hpb-cnt-tb-cell2">読み込み済みの全ての音アニメを破棄します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">なし<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSndAnimFrameNum</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメ</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメのフレーム長を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　アニメを識別する番号を指定します。<BR>
      <BR>
      2. [OUT] int*　：　numptr<BR>
      　　アニメのフレーム長が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSndAnimBGM</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメ</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメに関連付けられているBGMのサウンドIDを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　アニメを識別する番号を指定します。<BR>
      <BR>
      2. [OUT] int*　：　bgmidptr<BR>
      　　BGMのサウンドIDが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSndAnimFPS</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメ</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメのFPSを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　アニメを識別する番号を指定します。<BR>
      <BR>
      2. [OUT] int*　：　fpsptr<BR>
      　　FPSが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSndAnimMode</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメ</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメの繰り返しモードを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　アニメを識別する番号を指定します。<BR>
      <BR>
      2. [OUT] int*　：　modeptr<BR>
      　　繰り返しなしの場合は１が繰り返し再生の場合は２５５が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DStartSndAnim</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメ</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメの再生を開始します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　アニメを識別する番号を指定します。<BR>
      <BR>
      2. [IN] int　：　startframe<BR>
      　　再生を開始する際のスタートフレーム番号を指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetSndAnimFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメ</TD>
      <TD class="hpb-cnt-tb-cell2">再生する音アニメのフレーム番号を指定します。<BR>
      この命令は音アニメで設定されている効果音用のものです。<BR>
      BGMには影響を与えません。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　アニメを識別する番号を指定します。<BR>
      <BR>
      2. [IN] int　：　frameno<BR>
      　　再生するフレーム番号を指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DStopSndAnim</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメ</TD>
      <TD class="hpb-cnt-tb-cell2">音アニメの再生を停止します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　アニメを識別する番号を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSoundTotalTime</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">音のトータルタイムを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　音を識別するIDを指定します。<BR>
      <BR>
      2. [OUT] double*　：　timeptr<BR>
      　　トータルタイムが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DConvSoundSampleToFrame</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">音のサンプル数をフレーム番号に変換します。<BR>
      現在再生中の位置（サンプル数）は<BR>
      E3DGetSoundSamplesPlayedで取得できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　音を識別するIDを指定します。<BR>
      <BR>
      2. [IN] int　：　srcfps<BR>
      　　音アニメのFPSを指定します。<BR>
      <BR>
      3. [IN] double　：　srcsample<BR>
      　　サンプル数を指定します。<BR>
      <BR>
      4. [OUT] int*　：　frameptr<BR>
      　　フレーム番号が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSoundStartCnt</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">音のstartcntを取得します。<BR>
      startcntは０から始まり、音の再生が実際に開始されたときに１ずつ増えます。<BR>
      音の再生命令を呼び出しても実際に再生されるまでには少し時間がかかります。<BR>
      このstartcntの値を監視することで<BR>
      実際に再生が開始された時を把握できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　音を識別するIDを指定します。<BR>
      <BR>
      2. [OUT] int*　：　cntptr<BR>
      　　startcntが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetSoundEndCnt</TD>
      <TD class="hpb-cnt-tb-cell2">サウンド</TD>
      <TD class="hpb-cnt-tb-cell2">音のendcntを取得します。<BR>
      endcntは０から始まり、音の再生が実際に終了したときに１ずつ増えます。<BR>
      音の停止命令を呼ばない場合でも再生が最後まで達し終了すればカウントが増えるので<BR>
      実際に再生が終了したときを把握できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　soundid<BR>
      　　音を識別するIDを指定します。<BR>
      <BR>
      2. [OUT] int*　：　cntptr<BR>
      　　endcntが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DPCWait</TD>
      <TD class="hpb-cnt-tb-cell2">同期</TD>
      <TD class="hpb-cnt-tb-cell2">指定したFPSに近くなるように待機します。<BR>
      E3DWaitByFPSよりも高精度ですがCPUを消費します。<BR>
      音の同期の際には正確なタイミングが必要になるのでこの命令を使ってください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　srcfps<BR>
      　　目標のFPSを指定します。<BR>
      <BR>
      2. [OUT] double*　：　dstfps<BR>
      　　実際のFPSが代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCloneDispObj</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">表示用オブジェクトを複製します。<BR>
      ボーンには使えません。<BR>
      モーフターゲットの複製などに使ってください。<BR>
      この命令を実行すると読み込み済みの全てのモーションが破棄されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　複製したい表示オブジェクトのパーツID。<BR>
      <BR>
      3. [IN] char*　：　newname<BR>
      　　新しいパーツの名前。<BR>
      　　２５５バイトまで。０終端。<BR>
      <BR>
      4. [OUT] int*　：　seriptr<BR>
      　　作成した表示オブジェクトを識別するID。<BR>
      <BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.2.5_2</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetJointNotSel</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ジョイントの選択禁止フラグを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーン（ジョイント）を識別する番号。<BR>
      <BR>
      3. [OUT] int*　：　notselptr<BR>
      　　選択禁止フラグが代入されます。<BR>
      　　０か１です。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.3.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetJointNotSel</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">ジョイントの選択禁止フラグを設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーン（ジョイント）を識別する番号。<BR>
      <BR>
      3. [IN] int　：　notsel<BR>
      　　選択禁止フラグを指定します。<BR>
      　　０か１を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.3.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyMorph</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">モーフオブジェクトを削除します。<BR>
      モーフのベースとターゲットは削除されずに通常の表示用オブジェクトとしてシリアル番号1の子供になります。<BR>
      <BR>
      モーフをまとめるオブジェクトが削除されます。<BR>
      今の仕様では削除してもどうしてもごみが残るので多用するのはお勧めしません。<BR>
      <BR>
      読み込み済みのモーションは削除されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　baseno<BR>
      　　モーフのベースを識別する番号。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.3.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyDispObj</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">表示用オブジェクトを削除します。<BR>
      モーフのベースには使えません。<BR>
      （モーフのベースを削除したい場合はまずE3DDestroyMorphを実行し、モーフの外に出してから削除します）<BR>
      モーフのターゲットには使えます。<BR>
      <BR>
      今の仕様では削除してもどうしてもごみが残るので多用するのはお勧めしません。<BR>
      <BR>
      読み込み済みのモーションは削除されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　表示オブジェクトを識別する番号。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.3.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetCameraOffset</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラのオフセットを設定します。<BR>
      詳しくはマニュアルのe3d_CameraOffset.htmをご覧ください。<BR>
      具体的な使用例は<BR>
      CameraOffsetソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] D3DXVECTOR3　：　camoffbef<BR>
      　　回転前の移動成分を指定してください。<BR>
      <BR>
      2. [IN] int　：　camqid<BR>
      　　回転を表すクォータニオンのIDを指定してください。<BR>
      <BR>
      3. [IN] D3DXVECTOR3　：　camoffaft<BR>
      　　回転後の移動成分を指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.3.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DAllClearInfElem</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響</TD>
      <TD class="hpb-cnt-tb-cell2">ボーンの影響度を全て削除しまっさらな状態にします。<BR>
      <BR>
      ボーンの影響度が１つも定義されていない状態で<BR>
      E3DCreateSkinMatや描画命令を呼び出すとエラーになります。<BR>
      <BR>
      この命令を呼び出した場合は<BR>
      必ず少なくとも１つはボーンの影響度を設定し<BR>
      影響度の設定が全部終わったら<BR>
      E3DCreateSkinMatを呼び出さなければなりません。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　表示オブジェクトを識別する番号。<BR>
      　　-1を指定すると全てのパーツに対して処理します。<BR>
      <BR>
      3. [IN] int　：　vertno<BR>
      　　頂点の番号。<BR>
      　　-1を指定すると全ての頂点に処理します。<BR>
      　　partnoに-1を指定した場合は<BR>
      　　自動的に内部でvertnoに-1がセットされます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.3.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetGPOffset</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPAの再生開始位置と向きを指定します。<BR>
      <BR>
      この命令を呼ぶ前に<BR>
      E3DSetGPGroundHSIDを呼び、<BR>
      この命令を呼んだ後に<BR>
      E3DCalcGPFullFrameを呼ばないとオフセットはアニメに反映されません。<BR>
      <BR>
      具体的な使用例は<BR>
      GPOffsetソリューションをご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　tra<BR>
      　　GPAを開始する位置。<BR>
      <BR>
      3. [IN] int　：　qid<BR>
      　　GPAを開始する向きを表すクォータニオンのID。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSelectLightType</TD>
      <TD class="hpb-cnt-tb-cell2">ライト</TD>
      <TD class="hpb-cnt-tb-cell2">この命令をltype引数に１を入れて<BR>
      <B>E3DInitより前に</B>呼び出すと<BR>
      平行光源とスポットライトを合計３個まで使うことが出来るようになります。<BR>
      <BR>
      この命令を呼び出さなかったりltypeに０を入れて呼び出すと平行光源とポイントライトを合計３個まで使うことが出来ます。<BR>
      <BR>
      呼び出す場合は必ずE3DInitより前で呼び出します。<BR>
      一度E3DInitを呼び出したら途中で変更することは出来ません。<BR>
      <BR>
      <BR>
      ポイントライトやスポットライトは<BR>
      シェーダータイプによってかなり見栄えが変わります。<BR>
      デフォルトのCOL_PHONGだと頂点単位で計算されるのでかなりポリゴンが細かくないときれいに効果が出ません。<BR>
      COL_PPHONGだとピクセル単位で計算されるため<BR>
      粗いポリゴンでもきれいに効果が出ます。<BR>
      一般にポリゴンを細かくするよりもCOL_PPHONGを使ったほうが実行速度が速いです。<BR>
      <BR>
      シェーダータイプはE3DSetShaderTypeで設定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　ltype<BR>
      　　１を指定すると平行光源とスポットライトを使用できます。<BR>
      　　０を指定すると平行光源とポイントライトを使用できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetSpotLight</TD>
      <TD class="hpb-cnt-tb-cell2">ライト</TD>
      <TD class="hpb-cnt-tb-cell2">E3DCreateLightで作成したライトに<BR>
      スポットライトのパラメータをセットする。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　lightID<BR>
      　　光源を識別するid<BR>
      <BR>
      2. [IN] D3DXVECTOR3　：　pos<BR>
      　　スポットライトの位置を<BR>
      　　（pos.x, pos.y, pos.z）に設定する。<BR>
      <BR>
      3. [IN] D3DXVECTOR3　：　dir<BR>
      　　スポットライトの向きを設定する。<BR>
      <BR>
      4. [IN] float　：　dist<BR>
      　　スポットライトの光が届く距離を設定します。<BR>
      <BR>
      5. [IN] float　：　angle<BR>
      　　スポットライトのコーンの角度を設定します。<BR>
      <BR>
      6. [IN] E3DCOLOR4UC　：　col<BR>
      　　スポットライトの色を<BR>
      　　（col.r, col.g, col.b）に設定する。<BR>
      　　col.aは無視される。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DRenderZandN</TD>
      <TD class="hpb-cnt-tb-cell2">描画</TD>
      <TD class="hpb-cnt-tb-cell2">モデルのZ情報と法線情報を書き出します。<BR>
      通常のスワップチェインやレンダーターゲットテクスチャに対して処理を行えます。<BR>
      <BR>
      Z出力,法線出力、Z入力のサーフェスの大きさは同じでなければならない。<BR>
      オブジェクトがない部分はアルファが０。<BR>
      <BR>Z出力はr, g, b３成分に＊１、＊２５６、２５６＊２５６スケール（小数部）で<BR>
分割出力しています。<BR>
<BR>
使用するときは<BR>
depth = r + g / 256.0f + b / (256.0f * 256.0f)<BR>
のようにして使います。<BR>
<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN, OUT] int　：　outzscid<BR>
　　Z情報を出力するscid<BR>
<BR>
      2. [IN, OUT] int　：　outnscid<BR>
　　法線情報を出力するscid<BR>
<BR>
      3. [IN] int　：　inzscid<BR>
　　出力の際に使用するZバッファのscid<BR>
<BR>
      4. [IN] int　：　hsid<BR>
　　形状データを識別するID<BR>
<BR>
      5. [IN] int　：　skipflag<BR>
　　処理のスキップフラグ。<BR>
　　１を足すとZ出力スキップ。<BR>
　　２を足すと法線出力スキップ。<BR>
　　４を足すとZバッファー初期化スキップ。<BR>
　　８を足すとモーションの姿勢計算スキップ。<BR>
　　１６を足すとBeginScene, EndSceneをスキップ。<BR>
<BR>
      6. [IN] int　：　renderflag<BR>
　　レンダーフラグ。<BR>
　　１を足すとZ情報を出力。<BR>
　　２を足すと法線情報を出力。<BR>
      　　４を足すとカメラ座標系の法線を出力。ただし２と組み合わせないと無効。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCreateInfScope</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">影響度２用の影響範囲形状を作成します。<BR>
      <BR>
      影響範囲形状はボーンの番号と表示オブジェクトの番号の組み合わせごとに１つだけ作成できます。<BR>
      <BR>
      この命令で得られるisindexの値は恒久的なものではありません。<BR>
      <BR>
      編集作業で<BR>
      影響範囲形状を削除したりした場合はE3DExistInfScopeでisindexを再取得しなければなりません。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンのパーツ番号。<BR>
      <BR>
      3. [IN] int　：　dispno<BR>
      　　表示オブジェクトのパーツ番号。<BR>
      <BR>
      4. [OUT] int*　：　isindexptr<BR>
      　　影響範囲形状操作用のインデックスが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyInfScope</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">影響範囲形状を削除します。<BR>
      <BR>
      この命令で得られるisindexの値は恒久的なものではありません。<BR>
      <BR>
      編集作業で<BR>
      影響範囲形状を削除したりした場合はE3DExistInfScopeでisindexを再取得しなければなりません。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　isindex<BR>
      　　削除する影響範囲形状のインデックス。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DExistInfScope</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">影響範囲形状が存在する場合はそのインデックスを取得し、存在しないときは-1を取得します。<BR>
      <BR>
      mikoto形式のデータを読み込むと<BR>
      アンカーが影響範囲形状に自動的に変換されるので、E3DCreateInfScopeを呼び出さなくても影響範囲形状が存在する場合があります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　boneno<BR>
      　　ボーンのパーツ番号。<BR>
      <BR>
      3. [IN] int　：　dispno<BR>
      　　表示オブジェクトのパーツ番号。<BR>
      <BR>
      4. [OUT] int*　：　isindexptr<BR>
      　　影響範囲形状操作用のインデックスが代入されます。<BR>
      影響範囲形状が存在しないときは-1が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetInfScopeNum</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">影響範囲形状の個数を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [OUT] int*　：　numptr<BR>
      　　影響範囲形状の総数が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetInfScopeInfo</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">影響範囲形状の情報を取得します。<BR>
      ISINFO構造体はusercoef.hで定義されています。<BR>
      <BR>
      E3DGetInfScopeNumで取得した総数をisnumとすると、isiptrにはisnum個以上の要素を持つ配列のポインタを渡してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [OUT] ISINFO*　：　isiptr<BR>
      　　影響範囲形状の情報が代入されます。<BR>
      <BR>
      3. [IN] int　：　arrayleng<BR>
      　　isiptrの配列要素数を指定します。<BR>
      <BR>
      4. [OUT] int*　：　getnumptr<BR>
      　　isiptrに格納した要素数が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetInfScopeVert</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">影響範囲形状の頂点位置を設定します。<BR>
      ISVERT構造体はusercoef.hで定義されています。<BR>
      <BR>
      ローカル座標系の位置を渡してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] ISVERT　：　srcisv<BR>
      　　頂点情報。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetInfScopeVert</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">影響範囲形状の頂点位置を取得します。<BR>
      <BR>ISVERT構造体はusercoef.hで定義されています。<BR>
      <BR>
      isv.isid、isv.vertnoに取得したい形状のインデックスと頂点番号をセットして呼び出します。<BR>
      <BR>
      ローカル座標系の位置です。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN, OUT] ISVERT*　：　isvptr<BR>
      　　頂点情報が代入されます。<BR>
      isidメンバには自分で値を設定してから渡してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetInfScopeVertNum</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">影響範囲形状の頂点数を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　isindex<BR>
      　　影響範囲形状のインデックス。<BR>
      <BR>
      3. [OUT] int*　：　numptr<BR>
      　　頂点数が代入されます。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DPickInfScopeVert</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">スクリーン座標に近い、影響範囲形状の頂点情報を取得します。<BR>
      <BR>
      モーションやキャラクターの位置と向きは初期化した状態で使用してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインID。<BR>
      <BR>
      2. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      3. [IN] POINT　：　scpos<BR>
      　　スクリーン（２D）座標。<BR>
      <BR>
      4. [IN] POINT　：　range<BR>
      　　scposからrangeだけずれていてもピックします。<BR>
      <BR>
      5. [IN] int　：　isindex<BR>
      　　影響範囲形状のインデックス。<BR>
      　　-1指定は出来ません。<BR>
      <BR>
      6. [OUT] ISVERT*　：　isvptr<BR>
      　　頂点情報が代入されます。<BR>
      　　arrayleng要素数のISVERT構造体の配列へのポインタを渡します。<BR>
      <BR>
      7. [IN] int　：　arrayleng<BR>
      　　isvptrの配列の要素数。<BR>
      <BR>
      8. [OUT] int*　：　getnumptr<BR>
      　　isvptrにセットした要素数が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetInfScopeAxis</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">影響範囲形状に関連付けられているボーンの座標軸（直交する３軸）を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　isindex<BR>
      　　影響範囲形状のインデックス。<BR>
      <BR>
      3. [OUT] D3DXVECTOR3*　：　dstvec3x3ptr<BR>
      　　３軸が代入されます。<BR>
      　　<BR>
      　　例えばD3DXVECTOR3 vec3[3];<BR>
      　　と宣言しvec3と指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetInfScopeColor</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">影響範囲形状の色を設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　isindex<BR>
      　　影響範囲形状のインデックス。<BR>
      <BR>
      3. [IN] E3DCOLOR4UC　：　srccol<BR>
      　　形状の色。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetInfScopeColor</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">影響範囲形状の色を取得します。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　isindex<BR>
      　　影響範囲形状のインデックス。<BR>
      <BR>
      3. [OUT] E3DCOLOR4UC*　：　colptr<BR>
      　　形状の色が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetInfScopeDispFlag</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">影響範囲形状を表示するかどうかのフラグを設定します。<BR>
      形状を作成してもこの命令でflagを１に設定しないと表示されません。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　isindex<BR>
      　　影響範囲形状のインデックス。<BR>
      　　-1指定で全ての影響範囲形状に設定。<BR>
      <BR>
      3. [IN] int　：　dispflag<BR>
      　　表示したいとき１、しないとき０。<BR>
      <BR>
      4. [IN] int　：　exclusiveflag<BR>
      　　isindexに-1以外を指定したときのみ有効。<BR>
      　　１を指定するとisindexにdispflagを設定し、isindex以外の形状に！dispflagを設定します。<BR>
      　　０を指定するとisindexのみに処理を行います。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetInfScopeDispFlag</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">影響範囲形状を表示するかどうかのフラグを取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] int　：　isindex<BR>
      　　影響範囲形状のインデックス。<BR>
      <BR>
      3. [OUT] int*　：　flagptr<BR>
      　　表示するかどうかのフラグが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DImportMQOAsInfScope</TD>
      <TD class="hpb-cnt-tb-cell2">ボーン影響２</TD>
      <TD class="hpb-cnt-tb-cell2">mqoファイルを読み込み、それを影響範囲形状に変換します。<BR>
      <BR>
      現在のバージョンでは形状は１立体のみで<BR>
      凸型である必要があります。<BR>
      <BR>
      直方体である必要はありません。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<BR>
      <BR>
      2. [IN] char*　：　mqoname<BR>
      　　mqoファイルのフルパス。<BR>
      <BR>
      3. [IN] float　：　mult<BR>
      　　読み込み倍率。<BR>
      <BR>
      4. [IN] int　：　boneno<BR>
      　　対応つけるボーンのパーツ番号。<BR>
      <BR>
      5. [IN] int　：　dispno<BR>
      　　対応つける表示オブジェクトのパーツ番号。<BR>
      <BR>
      6. [OUT] int*　：　isindexptr<BR>
      　　作成した影響範囲形状のインデックスが代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOELocalMotionFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">モーション(qua)のモーション番号とフレーム番号を取得します。<BR>
      <BR>
      moeanimno, moeframenoは<BR>
E3DGetMOEFrameNo hsid, moeanimno, moeframeno<BR>
で取得した値を指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　moeanimno<BR>
      　　MOEのアニメの番号を指定します。<BR>
      　　quaのアニメ番号ではありません。<BR>
      <BR>
      3. [IN] int　：　moeframeno<BR>
      　　MOEのフレーム番号を指定します。<BR>
      　　quaのフレーム番号ではありません。<BR>
      <BR>
      4. [OUT] int*　：　localanimno<BR>
      　　MOEの指定フレームに対応するquaのアニメ番号が代入されます。<BR>
      <BR>
      5. [OUT] int*　：　localframeno<BR>
      　　MOEの指定フレームに対応するquaのフレーム番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOELocalNextMotionFrameNo</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">次に再生が予約されているモーションの番号とフレーム番号を取得します。<BR>
      <BR>
      moeanimno, moeframenoは<BR>
E3DGetMOEFrameNo hsid, moeanimno, moeframeno<BR>
で取得した値を指定します。<BR>
<BR>
E3DGetMOELocalMotionFrameNo hsid, moeanimno, moeframeno, localanimno, localframeno<BR>
で取得したlocalanimnoが０のときにこの命令は意味を持ちます<BR>
（localnextanimnoに０以上の値が代入されます。）<BR>
<BR>
localnextframenoには補間が終わったときのジャンプ先のフレーム番号が入ります。<BR>
つまり補間フレーム長が５のときは、いつも(localnextanimnoが０以上のときはいつも)<BR>
５が入ります。<BR>
<BR>
ですのでlocalanimnoが０だったときは<BR>
現在再生中のモーションは<BR>
モーションID=localnextanimno<BR>
フレーム番号=localframeno<BR>
      となります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　moeanimno<BR>
      　　MOEのアニメの番号を指定します。<BR>
      　　quaのアニメ番号ではありません。<BR>
      <BR>
      3. [IN] int　：　moeframeno<BR>
      　　MOEのフレーム番号を指定します。<BR>
      　　quaのフレーム番号ではありません。<BR>
      <BR>
      4. [OUT] int*　：　localnextanimno<BR>
      　　MOEの指定フレームに再生中のquaの次に再生が予約されているアニメの番号が代入されます。<BR>
      <BR>
      5. [OUT] int*　：　localnextframeno<BR>
      　　MOEの指定フレームに再生中のquaの次に再生が予約されているアニメの開始フレーム番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.3.4.8</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMotionBlurMaxAlpha</TD>
      <TD class="hpb-cnt-tb-cell2">エフェクト</TD>
      <TD class="hpb-cnt-tb-cell2">モーションブラーの一番濃い部分の透明度の係数を指定します。<BR>
      マテリアルのアルファにこの命令で指定した係数を掛け算したものを、透明度として設定します。<BR>
      <BR>
      E3DSetMotionBlurMinAlphaは透明度の値を指定するのに対し、この命令は係数を指定する点に注意してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するID。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　設定したいパーツの番号。<BR>
      　　-1を指定すると全てのパーツに設定します。<BR>
      <BR>
      3. [IN] float　：　maxAlpha<BR>
      　　0.0から1.0までのfloat。<BR>
      　　ブラーの最大透明度の係数を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.4.0.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOEKeyGoOnFlag</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEのイベント継続フラグを取得します。<BR>
      <BR>
      指定したフレームにキーが無い場合はエラーになります。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　MOEのアニメ番号を指定します。<BR>
      <BR>
      3. [IN] int　：　frameno<BR>
      　　MOEアニメのフレーム番号。<BR>
      <BR>
      4. [OUT] int*　：　flagptr<BR>
      　　フラグが代入されます。<BR>
      　　継続のときは１。単発のときは０。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.4.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMOEKeyGoOnFlag</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEのイベント継続フラグを設定します。<BR>
      <BR>
      指定したフレームにキーが無い場合はエラーになります。<BR>
      <BR>
      E3DCalcMOEFullFrame命令を呼び出すとこの設定が反映されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　animno<BR>
      　　MOEのアニメ番号を指定します。<BR>
      <BR>
      3. [IN] int　：　frameno<BR>
      　　MOEアニメのフレーム番号。<BR>
      <BR>
      4. [IN] int　：　flag<BR>
      　　フラグを指定します。<BR>
      　　継続のときは１。単発のときは０。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.4.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMOATrunkNotComID</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">moaの共通分岐禁止IDの個数とIDを設定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　形状データを識別するid<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　Trunkのモーションを識別するid<BR>
      <BR>
      3. [IN] int*　：　arrayelng<BR>
      　　notcomid引数に指定する配列の要素数。<BR>
      <BR>
      4. [IN] int　：　notcomid<BR>
      　　IDを格納した配列。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.4.0.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOELocalMotionFrameNoML</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEのアニメ番号とフレーム番号に対応するquaのモーションの情報をボーンごとに取得します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　moeanimno<BR>
      　　MOEのアニメの番号を指定します。<BR>
      　　quaのアニメ番号ではありません。<BR>
      <BR>
      3. [IN] int　：　moeframeno<BR>
      　　MOEのフレーム番号を指定します。<BR>
      　　quaのフレーム番号ではありません。<BR>
      <BR>
      4. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      5. [OUT] int*　：　localanimno<BR>
      　　MOEの指定フレームに対応するquaのアニメ番号が代入されます。<BR>
      <BR>
      6. [OUT] int*　：　localframeno<BR>
      　　MOEの指定フレームに対応するquaのフレーム番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.4.1.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMOELocalNextMotionFrameNoML</TD>
      <TD class="hpb-cnt-tb-cell2">MOE</TD>
      <TD class="hpb-cnt-tb-cell2">MOEのアニメ番号とフレーム番号に対応するquaの次のモーションの情報をボーンごとに取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　moeanimno<BR>
      　　MOEのアニメの番号を指定します。<BR>
      　　quaのアニメ番号ではありません。<BR>
      <BR>
      3. [IN] int　：　moeframeno<BR>
      　　MOEのフレーム番号を指定します。<BR>
      　　quaのフレーム番号ではありません。<BR>
      <BR>
      4. [IN] int　：　boneno<BR>
      　　ボーンを識別する番号を指定してください。<BR>
      <BR>
      5. [OUT] int*　：　localnextanimno<BR>
      　　MOEの指定フレームに再生中のquaの次に再生が予約されているアニメの番号が代入されます。<BR>
      <BR>
      6. [OUT] int*　：　localnextframeno<BR>
      　　MOEの指定フレームに再生中のquaの次に再生が予約されているアニメの開始フレーム番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.4.1.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetDefaultGP</TD>
      <TD class="hpb-cnt-tb-cell2">GPA</TD>
      <TD class="hpb-cnt-tb-cell2">GPアニメのデフォルトのパラメータを設定します。<BR>
      <BR>
      gpstateの詳細はE3DSetGPKeyの説明をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] E3DGPSTATE　：　gpstate<BR>
      　　設定するパラメータ。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.4.1.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetDefaultCamera</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">カメラアニメのデフォルトのパラメータを<BR>
      カメラ番号ごとに設定します。<BR>
      <BR>
      camstateの詳細はE3DSetCameraKeyの説明をご覧ください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　camno<BR>
      　　カメラの番号（0から2）。<BR>
      　　-1は禁止。<BR>
      <BR>
      2. [IN] E3DCAMERASTATE　：　camstate<BR>
      　　設定するパラメータ。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.4.1.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DValidHsid</TD>
      <TD class="hpb-cnt-tb-cell2">描画パラメータ</TD>
      <TD class="hpb-cnt-tb-cell2">hsidが使用可能かどうかをチェックします。<BR>
      例えばE3DDestroyHandlerSetを呼び出した後のhsidに対して呼び出すと無効のフラグが返されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [OUT] int*　：　flagptr<BR>
      　　hsidが有効のときは１、無効のときは０が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.4.1.4</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DKinectLoadLib</TD>
      <TD class="hpb-cnt-tb-cell2">Kinect</TD>
      <TD class="hpb-cnt-tb-cell2">Kinect操作用のライブラリをロードします。<BR>
      OpenNIがインストールされていてOpenNIのサンプルが動く状態にマシンがないといけません。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　validflagptr<BR>
      　　正常にライブラリがロードできたら１が代入されます。失敗すると０が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DKinectSetChara</TD>
      <TD class="hpb-cnt-tb-cell2">Kinect</TD>
      <TD class="hpb-cnt-tb-cell2">KinectのキャプチャとEasy3Dのキャラクターの関連付けをします。<BR>
      <BR>
      kstファイルはRokDeBone2で作成します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] char*　：　kstname<BR>
      　　kstファイルのファイル名を指定します。<BR>
      <BR>
      3. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　capmode<BR>
      　　CAPMODE_ALLを指定するとmotidで指定したモーションの最初のフレームから最後のフレームまでキャプチャをします。最後のフレームに達したら自動的にキャプチャは終了します。<BR>
      　　CAPMODE_ONEを指定するとmotidで指定したモーションの最初の１フレーム（フレーム番号０）にキャプチャします。このモードではE3DKinectEndCaptureを呼ぶまでキャプチャーが続きます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DKinectStartCapture</TD>
      <TD class="hpb-cnt-tb-cell2">Kinect</TD>
      <TD class="hpb-cnt-tb-cell2">Kinectのモーションキャプチャを開始します。<BR>
      １０秒ほど時間が掛かります。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2"></TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">3DKinectEndCapture</TD>
      <TD class="hpb-cnt-tb-cell2">Kinect</TD>
      <TD class="hpb-cnt-tb-cell2">Kinectのモーションキャプチャを終了します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2"></TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DKinectIsTracking</TD>
      <TD class="hpb-cnt-tb-cell2">Kinect</TD>
      <TD class="hpb-cnt-tb-cell2">Kinectのモーションキャプチャがトラッキング状態にあるかどうかを調べます。<BR>
      トラッキング状態とはKinectが動作し、初期姿勢を認識して位置情報を送信し始めた状態です。<BR>
      初期姿勢はMedia/KinectSampleフォルダの中のsigファイルの姿勢と同じです。<BR>
      Kinectが動作し始めてからカメラに全身が入るように２，３ｍ離れ、正面を向いて初期姿勢を取ることでトラッキングが開始されます。<BR>
      この初期姿勢がいい加減だとモーションが乱れます。真面目にしっかり初期姿勢を取りましょう。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] int*　：　flagptr<BR>
      　　トラッキング状態のときに１、そうでないときに０が代入されます。<BR>
      <BR>
      2. [OUT] int*　：　capcntptr<BR>
      　　トラッキングが開始されてから何回E3DKinectSetSkelPosを呼び出したかを代入します。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DKinectGetSkelPos</TD>
      <TD class="hpb-cnt-tb-cell2">Kinect</TD>
      <TD class="hpb-cnt-tb-cell2">Kinectでキャプチャしたボーンの位置を取得します。<BR>
      ボーンの名前はusercoef.hにSKEL_*で定義されています。<BR>
      <BR>
      posptrには<BR>
      D3DXVECTOR3 pos[SKEL_MAX];<BR>
      で定義したposを指定してください。<BR>
      <BR>
      位置はトラッキングが開始されていないと取得できません。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [OUT] D3DXVECTOR3*　：　posptrd<BR>
      　　位置を格納する配列を指定してください。詳しくは前記をご覧ください。<BR>
      <BR>
      2. [OUT] int*　：　getflagptr<BR>
      　　位置が取得できたら１が出来なかったら０が代入されます。<BR>
      トラッキング状態でないと位置は取得できません。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DKinectSetSkelPos</TD>
      <TD class="hpb-cnt-tb-cell2">Kinect</TD>
      <TD class="hpb-cnt-tb-cell2">E3DKinectGetSkelPosで取得したボーンの位置を<BR>
      ボーンの姿勢情報に変換してからキャラクターに適応します。<BR>
      <BR>
      Kinectといっしょに使わない方法もあります。<BR>
      bulletなどで計算したボーンの位置をキャラクターに適用する場合はkinectflagに０を指定してください。その場合はこの命令を呼ぶ前に１回E3DKinectSetCharaを呼ぶ必要があります。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　kinectflag<BR>
      　　Kinectといっしょに使う場合は１を、Kinect以外で使う場合は０を指定してください。<BR>
      <BR>
      2. [IN] int　：　posmode<BR>
      　　全体移動の姿勢をどう処理するかを指定します。<BR>
      　　POSMODE_TOPOFJOINTを指定すると全体移動を一番親のボーンの姿勢に格納します。<BR>
      　　POSMODE_GLOBALを指定すると全体移動をキャラクターのグローバルの位置情報に格納します。つまりE3DGetPosでこの情報を取得できます。<BR>
      　　POSMODE_ZEROを指定すると全体移動をキャンセルします。<BR>
      <BR>
      3. [IN] D3DXVECTOR3*　：　posptr<BR>
      　　ボーンの位置情報を指定します。<BR>
      　　D3DXVECTOR3 pos[SKEL_MAX};のposを指定します。<BR>
      <BR>
      4. [OUT] int*　：　framenoptr<BR>
      　　再生されるフレーム番号が代入されます。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DKinectRenderSilhouette</TD>
      <TD class="hpb-cnt-tb-cell2">Kinect</TD>
      <TD class="hpb-cnt-tb-cell2">Kinectでキャプチャしているプレイヤーのシルエットを２D描画する命令です。<BR>
      <BR>
      E3DBeginSceneとE3DEndSceneの間に記述します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　withalpha<BR>
      　　半透明で描画するときは１、不透明で描画するときは０を指定します。<BR>
      <BR>
      2. [IN] TPOS*　：　tposptr<BR>
      　　描画するエリア（四角）の四隅の値を指定します。<BR>
      　　画面の中心が０です。<BR>
      　　横は左が-1.0f右が+1.0f<BR>
      　　上下は上が1.0f下が-1.0fです。<BR>
      　　TPOS構造体はusercoef.hで定義されています。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.0</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetInViewFlag</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">E3DChkInViewの後で呼び出します。<BR>
      E3DChkInViewの結果（視野内にあるかどうか）をパーツごとに取得できます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　flagptr<BR>
      　　視野内にある場合は１が、視野内にない場合は０が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DWriteBmpFromSurface</TD>
      <TD class="hpb-cnt-tb-cell2">出力</TD>
      <TD class="hpb-cnt-tb-cell2">画面をBMPファイルに出力します。<BR>
      アンチエイリアスを有効にしていても使用できます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　filename<BR>
      　　出力ファイルのフルパスを指定してください。<BR>
      <BR>
      2. [IN] int　：　scid<BR>
      　　出力したい画面のスワップチェインIDを指定してください。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMotionJumpFrame</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">モーションジャンプ設定を取得します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　jumpframeptr<BR>
      　　ジャンプするフレーム番号が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetMotionJumpFrame</TD>
      <TD class="hpb-cnt-tb-cell2">モーション</TD>
      <TD class="hpb-cnt-tb-cell2">モーションジャンプ設定を設定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　jumpframe<BR>
      　　ジャンプするフレーム番号を指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DCopyTexAnimFrame</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメ</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメをフレームコピーします。<BR>
      キーが無くても計算してコピーします。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　srcmotid<BR>
      　　コピー元のモーションを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　srcframe<BR>
      　　コピー元のフレーム番号を指定します。<BR>
      <BR>
      4. [IN] int　：　dstmotid<BR>
      　　コピー先のモーションを識別する番号を指定します。。<BR>
      <BR>
      5. [IN] int　：　dstframe<BR>
      　　コピー先のフレーム番号を指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DDestroyTexAnimFrame</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメ</TD>
      <TD class="hpb-cnt-tb-cell2">テクスチャアニメのフレームを削除します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　motid<BR>
      　　モーションを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　frameno<BR>
      　　フレーム番号を指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialExtTextureNum</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの拡張テクスチャがいくつ設定されているかを取得します。<BR>
      拡張テクスチャはテクスチャアニメで使用されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアルを識別する番号を指定してください。<BR>
      <BR>
      3. [OUT] int*　：　numptr<BR>
      　　拡張テクスチャの数が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DGetMaterialExtTexture</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの拡張テクスチャの名前を取得します。<BR>
      extnoには<BR>
      0からE3DGetMaterialExtTextureNumで取得した数字から1引いた数までの間の数値を指定します。<BR>
      <BR>
      nameptrには長さ２５６バイトのcharの配列のポインタを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアルを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　extno<BR>
      　　拡張番号。<BR>
      　　0から(exttexnum - 1)の値を指定。<BR>
      <BR>
      4. [OUT] char*　：　nameptr<BR>
      　　拡張テクスチャの名前が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DLoadMQOFileAsGroundFromBuf</TD>
      <TD class="hpb-cnt-tb-cell2">地面</TD>
      <TD class="hpb-cnt-tb-cell2">mqoファイルをバッファから読み込みます。<BR>
      地面として読み込みます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] char*　：　dirname<BR>
      　　テクスチャの存在するフォルダへのパスを指定します。<BR>
      <BR>
      2. [IN] char*　：　bufptr<BR>
      　　mqoをメモリに展開したバッファのポインタを指定します。<BR>
      <BR>
      3. [IN] int　：　bufsize<BR>
      　　読み込むバッファの長さを指定します。<BR>
      <BR>
      4. [OUT] int*　：　hsidptr<BR>
      　　モデルを識別する番号が代入されます。<BR>
      <BR>
      5. [IN] int　：　adjustuvflag<BR>
      　　UVの正規化をするかどうかのフラグ。<BR>
      　　通常０。<BR>
      <BR>
      6. [IN] float　：　mult<BR>
      　　読み込み倍率を指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChgMaterial1stTexFromBuf</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの1個目のテクスチャを変更します。<BR>
      削除と作成を行うので重い処理です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアルを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] char*　：　bufptr<BR>
      　　テクスチャをメモリに展開したバッファのポインタを指定します。<BR>
      <BR>
      4. [IN] int　：　bufsize<BR>
      　　読み込むバッファのサイズを指定します。<BR>
      <BR>
      5. [OUT] int*　：　texidptr<BR>
      　　テクスチャを識別する番号が代入されます。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChgMaterialExtTexFromBuf</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの拡張テクスチャを変更します。<BR>
      削除と作成を行うので重い処理です。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアルを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　extno<BR>
      　　拡張番号を指定してください。<BR>
      <BR>
      4. [IN] char*　：　bufptr<BR>
      　　テクスチャをメモリに展開したバッファのポインタを指定します。<BR>
      <BR>
      5. [IN] int　：　bufsize<BR>
      　　読み込むバッファのサイズを指定します。<BR>
      <BR>
      6. [OUT] int*　：　texidptr<BR>
      　　テクスチャを識別する番号が代入されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChgMaterial1stTexFromID</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの１つめのテクスチャの内容を<BR>
      指定したIDのテクスチャに変更します。<BR>
      <BR>
      内部ではテクスチャのコピーは行わず、テクスチャのリンクを行います。<BR>
      <BR>
      この命令を呼ぶと一番最初のオリジナルのテクスチャ内容は破棄されます。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアルを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　texid<BR>
      　　テクスチャIDを指定します。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DChgMaterialExtTexFromID</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアル</TD>
      <TD class="hpb-cnt-tb-cell2">マテリアルの拡張テクスチャ(テクスチャアニメ用)の内容を<BR>
      指定したIDのテクスチャに変更します。<BR>
      <BR>
      内部ではテクスチャのコピーは行わず、テクスチャのリンクを行います。<BR>
      <BR>
      この命令を呼ぶと一番最初のオリジナルのテクスチャ内容は破棄されます。</TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　matno<BR>
      　　マテリアルを識別する番号を指定してください。<BR>
      <BR>
      3. [IN] int　：　extno<BR>
      　　拡張番号を指定してください。<BR>
      <BR>
      4. [IN] int　：　texid<BR>
      　　テクスチャIDを指定します。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.6</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetCameraAnimeTargetHsidAll</TD>
      <TD class="hpb-cnt-tb-cell2">カメラ</TD>
      <TD class="hpb-cnt-tb-cell2">camファイルの注視点となるモデルのhsidを設定します。<BR>
      注視点のボーンやlooktypeも設定しないと機能しません。<BR>
      これらはRokDeBone2のカメラタブで設定します。<BR>
      <BR>
      RokDeBone2のカメラタブで注視ボーンの設定をすると、注視hsidは値「１」が設定されます。<BR>
      <BR>
      この数値を変更するのがこの命令の目的です。<BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　animno<BR>
      　　カメラアニメを識別する番号を指定してください。<BR>
      <BR>
      2. [IN] int　：　hsid<BR>
      　　モデルを識別する番号を指定してください。<BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.0.7</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">E3DSetDispSwitchForce</TD>
      <TD class="hpb-cnt-tb-cell2">モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">DispSwitchをプログラムから強制的に設定します。<br>
      この命令で設定すると、アニメーションに設定されているDispSwitchを無視して、設定内容が反映されます。<br>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<br>
      <br>
      2. [IN] int　：　swid<BR>
      　　スイッチのID。<br>
      　　０から９９。<br>
      <br>
      3. [IN] int　：　state<BR>
      　　スイッチの状態。<br>
      　　０はオフ。１はオン。２はモーションの設定を反映。<BR>
      <BR>
      <BR>
      </TD>
      <TD class="hpb-cnt-tb-cell2">ver5.5.1.1</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">&nbsp;E3DSetWindowRgn</TD>
      <TD class="hpb-cnt-tb-cell2">描画</TD>
      <TD class="hpb-cnt-tb-cell2">&nbsp;不定形リージョンをメインウインドウ(scid1)に設定します。<br>
      scid2はレンダーターゲットテクスチャを想定します。<br>
      scid2のアルファが０以外の部分がウインドウ領域になります。<br>
      具体的な使い方は<br>
      DesktopM_Rgnソリューション<br>
      をご覧ください。<br>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid1<BR>
      　　メインウインドウのスワップチェインID。<br>
      <br>
      2. [IN] int　：　scid2<BR>
      　　レンダーターゲットテクスチャのスワップチェインID。<br>
      <br>
      </TD>
      <TD class="hpb-cnt-tb-cell2">&nbsp;ver5.5.1.3</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">&nbsp;E3DDestroyDispPart</TD>
      <TD class="hpb-cnt-tb-cell2">&nbsp;モデル情報</TD>
      <TD class="hpb-cnt-tb-cell2">&nbsp;表示用のパーツを削除します。<br>
      使用しないパーツを削除することで<br>
      メモリを節約できます。<br>
      一度削除するともとには戻せません。<br>
      一時的に無効にする場合は<br>
      E3DSetValidFlagを使用してください。<br>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　hsid<BR>
      　　モデルデータを識別するID。<br>
      <br>
      2. [IN] int　：　partno<BR>
      　　パーツを識別する番号。<br>
      <br>
      </TD>
      <TD class="hpb-cnt-tb-cell2">&nbsp;ver5.5.1.5</TD>
    </TR>
    <TR>
      <TD class="hpb-cnt-tb-cell1">&nbsp;E3DPlayMovie</TD>
      <TD class="hpb-cnt-tb-cell2">&nbsp;描画</TD>
      <TD class="hpb-cnt-tb-cell2">wmv, mpegなどの拡張子のムービーを<br>
      再生します。<br>
      この命令は動画の再生が終わるまで<br>
      ブロックします。<br>
      つまり再生が終わるまで次のプログラム行に制御が戻りません。<br>
      </TD>
      <TD class="hpb-cnt-tb-cell2">1. [IN] int　：　scid<BR>
      　　スワップチェインを識別するID。<br>
      <br>
      2. [IN] const char*　：　filename<BR>
      　　ムービーのファイル名。<br>
      <br>
      </TD>
      <TD class="hpb-cnt-tb-cell2">&nbsp;ver5.5.1.6</TD>
    </TR>
  </TBODY>
</TABLE>
<P><BR>
</P>
</BODY>
</HTML>